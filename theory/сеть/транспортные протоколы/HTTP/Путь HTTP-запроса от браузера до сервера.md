
### 1. Ввод адреса в браузере

Ты пишешь в адресной строке:

```
https://example.com/users?id=10
```

Браузер сначала **разбирает URL**:

- `https` — схема (протокол)
    
- `example.com` — домен
    
- `/users?id=10` — путь и параметры запроса
    
- порт — 443 (по умолчанию для HTTPS)
    

---

### 2. DNS-разрешение

Браузер не знает, где “example.com”, поэтому идёт к **DNS-серверу** (через системный резолвер).  
Тот возвращает IP-адрес:

```
example.com → 185.199.109.153
```

Результат кешируется (в браузере, в системе, иногда у провайдера).

---

### 3. Установка TCP-соединения

Браузер открывает соединение с IP-адресом по порту 443 (HTTPS) или 80 (HTTP).  
Происходит **трёхходовое рукопожатие TCP**:

```
1. SYN → 
2. ← SYN+ACK
3. ACK →
```

Теперь канал установлен, можно слать байты.

---

### 4. TLS-рукопожатие (только для HTTPS)

Браузер и сервер договариваются о шифровании:

- Сервер отдаёт **SSL-сертификат**.
    
- Браузер проверяет его у доверенного центра.
    
- Генерируются ключи для симметричного шифрования.
    

После этого трафик становится **зашифрованным**, и даже провайдер не видит содержимого.

---

### 5. Отправка HTTP-запроса

Браузер формирует и шлёт запрос.  
Например:

```
GET /users?id=10 HTTP/1.1
Host: example.com
User-Agent: Chrome/141
Accept: application/json
Cookie: session=abc123
```

Если это POST — добавляет тело:

```
POST /login HTTP/1.1
Content-Type: application/json
Content-Length: 47

{"email":"mike@example.com","password":"secret"}
```

---

### 6. Пролёт через балансировщики / прокси

На реальных проектах запрос часто проходит через:

- CDN (Cloudflare, Fastly, Akamai)
    
- reverse-proxy (nginx, traefik, haproxy)
    
- балансировщик (AWS ELB, nginx upstream)
    

Каждый из них может:

- добавить или удалить заголовки (`X-Forwarded-For`, `X-Real-IP`)
    
- кэшировать статические файлы
    
- перекинуть запрос к нужному серверу или контейнеру
    

---

### 7. Попадание в **веб-сервер**

Допустим, nginx.

Пример правила:

```nginx
location ~ \.php$ {
    include fastcgi_params;
    fastcgi_pass unix:/run/php/php-fpm.sock;
}
```

Nginx сам **не исполняет PHP** — он лишь передаёт запрос в **PHP-FPM** через FastCGI.  
Если запрошен `.html` или `.js`, nginx отдаёт файл напрямую, без PHP.

---

### 8. PHP-FPM

FPM получает запрос от nginx, создаёт воркер (если его нет),  
и передаёт данные в скрипт `index.php` (или тот, что указан в `SCRIPT_FILENAME`).

PHP-код выполняется:

- читает $_GET, $_POST, $_COOKIE
    
- дергает базу данных
    
- формирует ответ (HTML, JSON и т.п.)
    

---

### 9. Ответ уходит обратно

FPM возвращает результат nginx’у:

```
Status: 200 OK
Content-Type: application/json

{"id":10,"name":"Mikhail"}
```

Nginx добавляет свои заголовки (например, `Server: nginx`, `Content-Length`),  
и отправляет ответ браузеру по тому же TCP-соединению.

---

### 10. Рендер в браузере

Браузер принимает ответ:

- Если `Content-Type: text/html` — рендерит страницу.
    
- Если JSON — отдаёт JS-приложению (fetch/AJAX).
    
- Если 301/302 — делает редирект.
    
- Если 4xx/5xx — показывает ошибку.
    

И всё. Цикл завершён.

---

### Короткая цепочка

```
Браузер
 ↓ DNS
 ↓ TCP + TLS
 ↓ HTTP-запрос
 ↓ CDN / балансировщик
 ↓ Nginx
 ↓ PHP-FPM
 ↓ Приложение (Symfony, Laravel и т.п.)
 ↓ Ответ
 ↑
Браузер (рендер)
```

---

### Полезные наблюдения

- **DNS и TCP-handshake** обычно занимают больше времени, чем сам PHP-код.
    
- **Keep-Alive** и **HTTP/2** позволяют использовать одно соединение для многих запросов.
    
- **TLS-сессии кешируются**, чтобы не делать handshake заново.
    
- При ошибке 502 виноват чаще **php-fpm** (умер или завис).
    

---

Хочешь — дальше сделаю заметку _«Структура HTTP-запроса и ответа»_:  
строки, заголовки, тело, различие GET/POST, параметры URL и content-type.  
Это как раз то, что спрашивают после “что происходит при вводе URL”.