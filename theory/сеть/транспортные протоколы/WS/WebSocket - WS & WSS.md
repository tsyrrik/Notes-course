### Что это

**WebSocket (WS)** — это **протокол двусторонней связи** между клиентом и сервером, поверх TCP.  
Он позволяет держать **постоянное соединение**, по которому данные могут идти **в обе стороны** без повторных HTTP-запросов.

`WSS` — то же самое, но с **шифрованием (TLS)**, аналог HTTPS.

---

### Зачем нужен WebSocket

Обычный HTTP устроен так: клиент делает запрос → сервер отвечает → связь закрыта.  
WebSocket делает наоборот:  
клиент открывает канал → и они могут **болтать постоянно**, без лишних заголовков.

Типичные кейсы:

- real-time чаты
    
- онлайн-игры
    
- уведомления (например, «новая ставка в аукционе»)
    
- live-доски и совместное редактирование (Google Docs)
    
- real-time графики (биржа, метрики, мониторинг)
    

---

### Как это работает (handshake)

1. Клиент отправляет HTTP-запрос с просьбой “перейти на WebSocket”:
    
    ```
    GET /chat HTTP/1.1
    Host: example.com
    Upgrade: websocket
    Connection: Upgrade
    Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
    Sec-WebSocket-Version: 13
    ```
    
2. Сервер отвечает:
    
    ```
    HTTP/1.1 101 Switching Protocols
    Upgrade: websocket
    Connection: Upgrade
    Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
    ```
    
3. Всё. Соединение остаётся открытым — дальше идёт бинарный поток фреймов, без HTTP-заголовков.
    

---

### В DevTools это выглядит так

(вкладка **Network → WS** в Chrome)

```
Status: 101 Switching Protocols
Frames:
← {"message":"Welcome!"}
→ {"text":"Hi, server!"}
← {"text":"Hey, client!"}
← {"online":42}
```

Каждая строчка — фрейм.  
Нет “Request/Response”, просто постоянный канал.

_(визуально там стрелочки “→” и “←”, показывающие направление сообщений)_

---

### В PHP-мире

PHP по природе — **неподходит для WebSocket**.  
Каждый PHP-скрипт живёт коротко: старт → выполняется → умирает.  
WebSocket требует **долгоживущего процесса**, который держит соединения.  
Поэтому решения обычно обходные:

|Подход|Что делает|
|---|---|
|**Centrifugo**|Отдельный Go-сервер WebSocket, PHP шлёт туда события через HTTP / Redis|
|**Soketi**|Аналог Pusher, Node.js, умеет совместимость с Laravel Echo|
|**Mercure**|От Symfony, работает по HTTP/2 и SSE, альтернатива WS|
|**Ratchet**|Чистый PHP WebSocket-сервер, но тяжёлый под нагрузкой|
|**RoadRunner / Swoole / ReactPHP**|асинхронные PHP-рантаймы, которые уже умеют держать WS-соединения|
|**Pusher / Ably / Firebase**|внешние SaaS-провайдеры, не изобретаешь велосипед|

---

### Как обычно делают в инфраструктуре PHP

```
[Браузер] ⇄ WebSocket ⇄ [Centrifugo / Soketi]
                                 ↑
                           HTTP / Redis
                                 ↑
                           [PHP Backend]
```

- PHP просто публикует события (`user.sent_message`, `new.order`, `server.alert`).
    
- WebSocket-сервер держит соединения с фронтом и рассылает уведомления.
    
- Таким образом PHP остаётся “умным бэком”, а real-time делает отдельный сервис.
    

---

### Пример: Centrifugo

Centrifugo — написан на Go, готов из коробки, не требует переписывать бэкенд.

1. PHP шлёт сообщение:
    
    ```php
    Http::post('http://centrifugo/api', [
        'method' => 'publish',
        'params' => [
            'channel' => 'chat#42',
            'data' => ['text' => 'Привет!']
        ]
    ]);
    ```
    
2. Пользователи в браузере, подписанные на `chat#42`, тут же получают фрейм:
    
    ```json
    {"text": "Привет!"}
    ```
    

Просто, быстро, не мешает PHP-флоу.

---

### Отличие WS от HTTP

|Особенность|HTTP|WebSocket|
|---|---|---|
|Соединение|одноразовое|постоянное|
|Направление|клиент → сервер|двустороннее|
|Заголовки|всегда есть|только при handshake|
|Трафик|текстовый, многословный|бинарный, компактный|
|Использование|API, запросы, страницы|чаты, уведомления, стриминг|
|Протокол|`http://` / `https://`|`ws://` / `wss://`|

---

### Когда WSS обязателен

WSS — это просто WebSocket через TLS.

- работает по порту 443, проходит через те же брандмауэры, что HTTPS
    
- обязателен, если сайт сам по HTTPS
    
- браузеры блокируют `ws://` с защищённых страниц
    

---

### Проблемы и тонкости

- Нельзя обслуживать WS через PHP-FPM — нужен отдельный процесс.
    
- Нужно **sticky-sessions** при балансировке (один клиент — один сервер).
    
- WebSocket-трафик **не кэшируется и не проксируется** обычными CDN.
    
- Нужен пинг-пакет или таймаут, иначе idle-соединения рвутся.
    
- При высокой нагрузке — ставь WS-сервер отдельно от PHP.
    

---

### Альтернатива: Server-Sent Events (SSE)

[[Server-Sent Events (SSE)]]

---

### Итого

- WebSocket даёт **реальное двустороннее соединение**, без поллинга.
    
- В PHP обычно делается через **отдельный сервис** (Centrifugo, Soketi, Mercure).
    
- В DevTools виден как постоянный канал во вкладке **Network → WS**.
    
- Поддерживается всеми современными браузерами, но требует живого процесса на бэке.
    


