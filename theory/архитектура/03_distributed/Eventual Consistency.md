**Eventual consistency (в конечном итоге согласованность)** — это модель,  
при которой данные **могут быть временно не согласованы**,  
но **все копии придут к одному состоянию спустя время**.

---

### 1. Почему это вообще нужно

В распределённых системах нельзя одновременно иметь:

- мгновенную согласованность,
    
- доступность,
    
- устойчивость к сетевым сбоям.
    

Поэтому многие системы (Kafka, Cassandra, микросервисы) выбирают модель:

> “пусть будет несогласованно пару секунд, зато работает”.

---

### 2. Пример

Представь, пользователь оформил заказ.  
Сервис заказов сохранил запись, но сервис аналитики получит событие через Kafka чуть позже.

```text
t0: OrderService → "OrderCreated"
t1: AnalyticsService ещё не знает
t2: AnalyticsService получил событие → догнал состояние
```

В момент `t1` данные разные, но через `t2` они выровняются.  
Это и есть **eventual consistency**.

---

### 3. Где это применяется

- Между микросервисами (через события или очереди).
    
- В репликах БД (например, чтение из slave-узла может отставать).
    
- В кэше или поисковом индексе (Elasticsearch догоняет источник).
    
- В системах с Outbox/Saga — там согласованность достигается не сразу.
    

---

### 4. Чем это отличается от строгой согласованности

|Модель|Гарантия|Пример|
|---|---|---|
|**Strong consistency**|После записи все видят одно и то же|Транзакция в одной БД|
|**Eventual consistency**|Сначала рассинхрон, потом выравнивание|Kafka, микросервисы|
|**Causal consistency**|Гарантирует порядок зависимых событий|CRDT, некоторые NoSQL|

---

### 5. Как жить с этим

- Проектировать систему так, чтобы **временный рассинхрон был допустим**.
    
- Работать через **события**, а не через прямые вызовы.
    
- Делать **идемпотентные операции**, чтобы повторная обработка не ломала данные.
    
- Использовать **retry / DLQ / reconciliation** (периодическую сверку состояния).
