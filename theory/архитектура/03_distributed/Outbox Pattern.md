
**Outbox pattern** решает проблему:

> как гарантировать, что событие не потеряется между записью в базу и отправкой в очередь (Kafka, RabbitMQ и т. п.).

---

### 1. Проблема

Типичная ситуация:

```php
$order = $db->createOrder($data);
$bus->publish(new OrderCreated($order->id));
```

Если приложение падает **между** этими двумя строками —  
в базе заказ появится, а событие не уйдёт.  
Получаем рассинхрон: система “знает”, что заказ создан,  
а другие сервисы — нет.

---

### 2. Суть решения

Outbox pattern говорит:  
**пиши событие в ту же транзакцию, что и бизнес-данные.**

```php
$db->transaction(function () use ($data) {
    $order = Order::create($data);
    Outbox::store('OrderCreated', ['order_id' => $order->id]);
});
```

Теперь база и событие атомарны.  
Даже если приложение упадёт, событие сохранится в таблице `outbox`.

---

### 3. Как это работает

1. **Транзакция:** сохраняем событие в таблицу `outbox`.
    
2. **Фоновый процесс (outbox processor):** периодически читает новые записи.
    
3. **Публикует** их в брокер (Kafka, RabbitMQ, Redis Streams).
    
4. **Помечает** как доставленные (например, `sent_at IS NOT NULL`).
    

---

### 4. Структура таблицы

|id|event_type|payload|created_at|sent_at|
|---|---|---|---|---|
|1|OrderCreated|{"order_id":123}|2025-11-04|NULL|

После успешной публикации:

```sql
UPDATE outbox SET sent_at = NOW() WHERE id = 1;
```

---

### 5. Зачем это нужно

- **Гарантированная доставка:** не потеряешь событие даже при падении.
    
- **Идемпотентность:** можно безопасно ретраить публикацию.
    
- **Транзакционная согласованность:** данные и событие всегда синхронны.
    

---

### 6. Частые дополнения

- **Debezium** или **Change Data Capture**: вместо фонового скрипта события подхватываются автоматически по изменению таблицы.
    
- **Outbox + Inbox**: симметричный паттерн на стороне получателя для обработки событий без дублей.
    
- **Batch-публикация:** можно отправлять пачками для производительности.

https://youtu.be/_r-UhMVeKhg?si=PuQmMO5ey-f-2yMx
