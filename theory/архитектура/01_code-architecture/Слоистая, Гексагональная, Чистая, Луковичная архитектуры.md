
## TL;DR различия

|Подход|Главная идея|Границы|Зависимости|Где контроллеры|Где ORM|
|---|---|---|---|---|---|
|Слоистая (Layered)|Логика по слоям: UI → Application/Service → Domain → Infra|Прозрачные, но слабые|Вниз по слоям|UI|Чаще в Infra, но часто протекает вверх|
|Гексагональная (Ports & Adapters)|Домейн изолирован, общение через порты|Чёткие: порт/адаптер|Только к абстракциям домейна|Адаптер входа|Адаптер выхода (репозиторий-адаптер)|
|Чистая (Clean)|Слои по правилам зависимостей (сутевые сущности → use cases → интерфейсы → фреймворк)|Жёсткие, с направлением зависимостей|Внутрь, к более «чистым» слоям|Interface Adapters|Frameworks & Drivers|
|Луковичная (Onion)|Концентрические кольца, ядро — домейн|Межкольцевые|Только к центру|Во внешнем кольце|Во внешнем кольце|

Практически: гексагональная, чистая и луковичная — это вариации одной идеи «домейн в центре, инфраструктура снаружи», отличаются терминологией и тем, как рисуют стрелочки.

---

## Общий словарь

- **Domain**: сущности, value objects, доменные сервисы, бизнес-правила.
    
- **Application / Use Case**: сценарии использования, координируют домейн и порты.
    
- **Ports (интерфейсы)**: входные (команда/запрос), выходные (репозитории, шины и т.д.).
    
- **Adapters**: реализации портов для конкретных технологий (HTTP, DB, MQ, CLI).
    
- **Infra / Framework**: фреймворки, драйверы, ORM, веб, хранилища.
    

---

## Пример предметной области: «Создание продукта»

### Требование

- Создать продукт с уникальным SKU, названием, ценой > 0.
    
- Возвращать ID созданного продукта.
    

### Базовые доменные элементы (общие для всех вариантов)

```php
<?php
// Domain/Model/Product.php
namespace App\Domain\Model;

final class Product
{
    private string $id;
    private string $sku;
    private string $name;
    private int $priceCents;

    private function __construct(string $id, string $sku, string $name, int $priceCents)
    {
        if ($priceCents <= 0) {
            throw new \InvalidArgumentException('Price must be positive');
        }
        $this->id = $id;
        $this->sku = $sku;
        $this->name = $name;
        $this->priceCents = $priceCents;
    }

    public static function create(string $id, string $sku, string $name, int $priceCents): self
    {
        return new self($id, $sku, $name, $priceCents);
    }

    public function id(): string { return $this->id; }
    public function sku(): string { return $this->sku; }
    public function name(): string { return $this->name; }
    public function priceCents(): int { return $this->priceCents; }
}
```

```php
<?php
// Domain/Repository/ProductRepository.php
namespace App\Domain\Repository;

use App\Domain\Model\Product;

interface ProductRepository
{
    public function nextId(): string;
    public function bySku(string $sku): ?Product;
    public function save(Product $product): void;
}
```

---

# 1) Слоистая архитектура (Layered)

### Идея

Функции распределены по слоям. Типичный стек: **Controller → Service → Repository**. Границы условные, легко «подтянуть» ORM в сервис.

### Структура каталогов

```
src/
  Controller/
    ProductController.php
  Application/
    ProductService.php
    Dto/CreateProductInput.php
    Dto/CreateProductOutput.php
  Domain/
    Model/Product.php
    Repository/ProductRepository.php
  Infrastructure/
    Persistence/DoctrineProductRepository.php
```

### Поток «Create Product»

1. Controller парсит HTTP, зовёт Application Service.
    
2. Service валидирует, координирует домейн, работает с репозиторием.
    
3. Репозиторий сохраняет через ORM.
    

```php
<?php
// Application/ProductService.php
namespace App\Application;

use App\Application\Dto\CreateProductInput;
use App\Application\Dto\CreateProductOutput;
use App\Domain\Model\Product;
use App\Domain\Repository\ProductRepository;

final class ProductService
{
    public function __construct(private ProductRepository $products) {}

    public function create(CreateProductInput $in): CreateProductOutput
    {
        if ($this->products->bySku($in->sku)) {
            throw new \DomainException('SKU must be unique');
        }
        $id = $this->products->nextId();
        $product = Product::create($id, $in->sku, $in->name, $in->priceCents);
        $this->products->save($product);

        return new CreateProductOutput($id);
    }
}
```

Плюсы: просто начать. Минусы: слабая изоляция домейна, легко «протечь» инфраструктурой наверх.

---

# 2) Гексагональная архитектура (Hexagonal, Ports & Adapters)

### Идея

Всё общение с внешним миром через порты. У нас есть **входной порт** (use case) и **выходной порт** (репозиторий). Контроллер и ORM — адаптеры.

### Структура каталогов

```
src/
  Domain/
    Model/Product.php
    Port/Out/ProductRepository.php
  Application/
    Port/In/CreateProductUseCase.php
    Service/CreateProductService.php
    Dto/CreateProductCommand.php
    Dto/CreateProductResult.php
  Adapter/
    In/Http/CreateProductController.php
    Out/Persistence/DoctrineProductRepository.php
```

### Поток

1. HTTP-адаптер преобразует запрос в `CreateProductCommand` и вызывает входной порт `CreateProductUseCase`.
    
2. Сервис use case работает только с портами домейна.
    
3. Выходной адаптер реализует `ProductRepository`.
    

```php
<?php
// Application/Port/In/CreateProductUseCase.php
namespace App\Application\Port\In;
use App\Application\Dto\CreateProductCommand;
use App\Application\Dto\CreateProductResult;

interface CreateProductUseCase
{
    public function handle(CreateProductCommand $command): CreateProductResult;
}
```

```php
<?php
// Application/Service/CreateProductService.php
namespace App\Application\Service;

use App\Application\Dto\CreateProductCommand;
use App\Application\Dto\CreateProductResult;
use App\Application\Port\In\CreateProductUseCase;
use App\Domain\Model\Product;
use App\Domain\Repository\ProductRepository;

final class CreateProductService implements CreateProductUseCase
{
    public function __construct(private ProductRepository $products) {}

    public function handle(CreateProductCommand $command): CreateProductResult
    {
        if ($this->products->bySku($command->sku)) {
            throw new \DomainException('SKU must be unique');
        }
        $id = $this->products->nextId();
        $product = Product::create($id, $command->sku, $command->name, $command->priceCents);
        $this->products->save($product);

        return new CreateProductResult($id);
    }
}
```

Плюсы: чёткие границы, тестируемость без фреймворка. Минусы: больше классов, дисциплина.

---

# 3) Чистая архитектура (Clean Architecture)

### Идея

Кольца зависимостей направлены внутрь: **Entities → Use Cases → Interface Adapters → Frameworks**. Терминология более строгая, чем в «гекса».

### Структура каталогов

```
src/
  Domain/Entities/Product.php
  UseCase/CreateProduct/
    CreateProductInput.php
    CreateProductOutput.php
    CreateProductInteractor.php
    Ports/ProductGateway.php         # аналог репозитория
  InterfaceAdapters/
    Controllers/CreateProductController.php
    Presenters/CreateProductPresenter.php
    Gateways/DoctrineProductGateway.php
  Frameworks/
    Symfony/Routes, Kernel, DI config
```

### Особенность

Часто добавляют Presenter/ResponseModel, чтобы не тянуть HTTP-модели внутрь. ORM живёт во внешнем кольце в виде Gateway.

Плюсы: максимальная изоляция бизнес-правил. Минусы: ещё больше артефактов.

---

# 4) Луковичная архитектура (Onion)

### Идея

Концентрические слои вокруг домейна. Похож на Clean/Hexagonal, но упор на «зависимости только к центру».

### Структура каталогов

```
src/
  Core/Domain/...
  Core/Application/...
  Infrastructure/...
  Presentation/...
```

По потокам и зависимостям практически совпадает с гексагональной, просто другое именование колец.

---

## Symfony-ориентированная проводка зависимостей

`services.yaml`:

```yaml
services:
  App\Application\Service\CreateProductService:
    arguments:
      $products: '@App\Adapter\Out\Persistence\DoctrineProductRepository'
```

Контроллер-адаптер:

```php
<?php
// Adapter/In/Http/CreateProductController.php
namespace App\Adapter\In\Http;

use App\Application\Dto\CreateProductCommand;
use App\Application\Port\In\CreateProductUseCase;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

final class CreateProductController
{
    public function __construct(private CreateProductUseCase $useCase) {}

    public function __invoke(Request $request): JsonResponse
    {
        $payload = json_decode((string)$request->getContent(), true, 512, JSON_THROW_ON_ERROR);

        $result = $this->useCase->handle(
            new CreateProductCommand(
                sku: $payload['sku'],
                name: $payload['name'],
                priceCents: (int)$payload['price_cents']
            )
        );

        return new JsonResponse(['id' => $result->id]);
    }
}
```

Репозиторий-адаптер (Doctrine):

```php
<?php
// Adapter/Out/Persistence/DoctrineProductRepository.php
namespace App\Adapter\Out\Persistence;

use App\Domain\Model\Product;
use App\Domain\Repository\ProductRepository;
use Doctrine\ORM\EntityManagerInterface;

final class DoctrineProductRepository implements ProductRepository
{
    public function __construct(private EntityManagerInterface $em) {}

    public function nextId(): string
    {
        return bin2hex(random_bytes(16));
    }

    public function bySku(string $sku): ?Product
    {
        return $this->em->getRepository(Product::class)->findOneBy(['sku' => $sku]);
    }

    public function save(Product $product): void
    {
        $this->em->persist($product);
        $this->em->flush();
    }
}
```

> Примечание: чтобы домейн действительно не тянул Doctrine, держи аннотации/атрибуты ORM вне доменных классов. Варианты: маппинг через XML/YAML, отдельные persistence-модели и мапперы.

---

## Как выбрать подход под себя

- **Нужна скорость и малый проект** → слоистая.
    
- **Хочешь тестируемый домейн без фреймворка** → гексагональная.
    
- **Требуется строгая модель слоёв и Presenter/Response** → чистая.
    
- **Нравится ментальная модель колец** → луковичная.
    

Функционально три последних почти одинаковы; различия в терминологии и строгости дисциплины.

---

## Тестирование

- **Юнит-тесты домейна**: без контейнера и фреймворка.
    
- **Use case тесты**: моки портов (репозитория).
    
- **Контрактные тесты адаптеров**: один и тот же контракт репозитория прогоняем на Doctrine-реализации.
    
- **Интеграционные**: happy-path через HTTP с тестовой БД.
    

---

## Быстрый шаблон для фичи «Create Product» (гекса/clean-совместимый)

```
src/
  Domain/
    Model/Product.php
    Repository/ProductRepository.php
  Application/
    Port/In/CreateProductUseCase.php
    Dto/CreateProductCommand.php
    Dto/CreateProductResult.php
    Service/CreateProductService.php
  Adapter/
    In/Http/CreateProductController.php
    Out/Persistence/DoctrineProductRepository.php
```

```php
<?php
// Application/Dto/CreateProductCommand.php
namespace App\Application\Dto;

final class CreateProductCommand
{
    public function __construct(
        public string $sku,
        public string $name,
        public int $priceCents
    ) {}
}

final class CreateProductResult
{
    public function __construct(public string $id) {}
}
```

---

## Частые ошибки

- Протаскивание ORM-аннотаций в домейн.
    
- Зависимости «наружу» из домейна на фреймворк.
    
- Контроллер, который знает бизнес-правила.
    
- Большие сервисы-божественные объекты вместо маленьких use cases.
    

---

## Итог

- Слоистая — просто и быстро, но легко теряет границы.
    
- Гексагональная/Чистая/Луковичная — одно семейство: домейн в центре, взаимодействие через порты, инфраструктура снаружи. Отличия в терминах и строгости.
