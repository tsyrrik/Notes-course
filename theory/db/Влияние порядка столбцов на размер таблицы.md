Порядок столбцов **в PostgreSQL реально влияет на размер и скорость доступа**, хоть это и кажется какой-то старореляционной магией из 80-х. Это не шаманство — просто физика данных, странички, выравнивания и то, как движок хранит строки внутри heap-страниц.


---

## 1. PostgreSQL хранит строки не “в порядке колонок”, а физически в одну длинную кучу байтов

Каждая строка (`tuple`) хранится в data-странице (8 KB по умолчанию).  
Структура примерно такая:

```
| tuple header (фикcированный размер) |
| fixed-size attributes                |
| variable-size attributes (offset table + data) |
| TOAST pointers (если слишком длинные) |
```

PostgreSQL не держит "ячейки" как в Excel. Он последовательно пишет поля в байтовом буфере, вставляя выравнивание (alignment) для каждого типа.

---

## 2. Выравнивание и “дыры”

Типы вроде `int4`, `int8`, `float8`, `timestamp` должны лежать на границе 4 или 8 байт.  
Если до них был `text` или `varchar`, у которых длина произвольная, Postgres **добавляет padding**, чтобы следующий `int8` начинался “ровно”.

Пример (упрощённо):

```sql
CREATE TABLE a (
  name text,
  age int4
);
```

В каждой строке после `name` появится 4 байта выравнивания перед `age`. На миллиарде строк — это уже лишние гигабайты.

Если поменять порядок:

```sql
CREATE TABLE a (
  age int4,
  name text
);
```

— padding исчезает, потому что фиксированные типы уже в начале, и после них нет требований к выравниванию.

---

## 3. Постоянная и переменная длина

Postgres делит типы по “storage class”:

- `char`, `int`, `bool`, `timestamp` и т.п. — **фиксированной длины**.
    
- `text`, `varchar`, `bytea`, `jsonb`, `array`, `uuid` — **переменной длины** (`varlena`).
    

Каждый `varlena`-тип хранится с 4-байтовым заголовком (длина/флаги).  
Если значение большое, оно может быть вынесено в TOAST-таблицу (о ней чуть ниже).

При расположении переменных полей **в конце**, Postgres может хранить строки компактнее:

- Укороченные строки не фрагментируют страницу.
    
- Фиксированные поля выровнены и доступны напрямую (без разыменований).
    
- Переменные можно частично обрезать (compression / out-of-line TOAST).
    

---

## 4. TOAST и выгрузка больших полей

Когда `text` или `bytea` становится слишком большим (> 2 KB по умолчанию), Postgres помещает значение в отдельную таблицу (TOAST).  
Если поле находится **в конце строки**, проще “обрубить” его и оставить pointer в конце кортежа.

Если бы оно стояло посередине, пришлось бы сдвигать всю последующую часть строки и двигать offset-таблицу — дольше и грязнее.  
Поэтому документация прямо советует: “Place variable-length columns at the end”.

---

## 5. Мелкие эффекты

- Короткие строки помещаются полностью в page cache, не выносятся в TOAST, быстрее читаются.
    
- `UPDATE` копирует всю строку в новый tuple; чем она короче и плотнее упакована, тем меньше I/O.
    
- Фиксированные поля в начале ускоряют доступ: Postgres может вычислить смещение нужного поля просто по смещениям фиксированных секций, не шагая по переменным.
    

---

## 6. Итог: порядок влияет на всё

|Что делаем|Почему|
|---|---|
|Фиксированные типы (int, bool, timestamp) — в начале|Устраняем padding, выравнивание|
|Переменные (varchar, text, jsonb) — в конце|Меньше фрагментации, проще TOAST|
|Редко используемые большие поля — в самом конце|Можно не трогать их при чтении|
|Не класть `text` между `int`|Иначе Postgres будет вставлять 4–8 байт выравнивания|

---

### Пример разницы в размере

```sql
CREATE TABLE good (
  id bigserial,
  created_at timestamp,
  active boolean,
  email varchar(255),
  bio text
);

CREATE TABLE bad (
  email varchar(255),
  id bigserial,
  bio text,
  created_at timestamp,
  active boolean
);
```

`pg_total_relation_size('bad')` будет заметно больше после вставки тех же данных.  
На больших объёмах эта "мелочь" выливается в десятки процентов диска, больше страниц, больше I/O, меньше кеш-хитов.

---

## 7. Коротко как запомнить

> “Сперва то, что короткое и ровное. Потом всё, что растёт и сжимается.”

То есть:

1. фиксированные типы,
    
2. переменные,
    
3. длинные и редко нужные в самом хвосте.
    

Это простое правило, но на огромных таблицах оно сэкономит гигабайты и сотни миллисекунд на каждом батче.