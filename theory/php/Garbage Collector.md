## Что делает

PHP управляет памятью **автоматически** — объекты, массивы и строки уничтожаются, когда на них больше нет ссылок.  
Но есть нюанс: **циклические ссылки** (когда A → B → A) не могут быть удалены простым счётчиком ссылок.  
Для таких случаев есть **Garbage Collector (GC)**.

## Как работает

1. PHP использует **счётчик ссылок (refcount)** для [[Zval]] — внутренней структуры, хранящей значение и метаданные переменной.  
2. Когда `refcount` падает до 0, память освобождается сразу.  
3. Если в структуре обнаруживаются **циклы**, их помещают в "корзину" GC.
4. Периодически GC проходит по этой корзине и ищет циклы, которые можно уничтожить.

## Настройки

| Опция | Назначение |
|-------|-------------|
| `zend.enable_gc` | Включает/выключает GC (по умолчанию: `1`) |
| `gc_enabled()` | Проверка статуса |
| `gc_enable()` / `gc_disable()` | Управление вручную |
| `gc_collect_cycles()` | Принудительный запуск сборщика |

## Когда GC срабатывает

- Автоматически при превышении порога накопленных "подозрительных" zval.  
- Ручным вызовом `gc_collect_cycles()`.

## Пример

```php
$a = new stdClass();
$b = new stdClass();
$a->b = $b;
$b->a = $a;

unset($a, $b); // refcount у циклов > 0, без GC — утечка

echo gc_collect_cycles(); // уничтожает цикл, вернёт 2
````

## Диагностика

- `gc_status()` — возвращает массив со статистикой GC.
    
- `memory_get_usage()` / `memory_get_peak_usage()` — полезны для отладки.
    
- В Xdebug можно видеть утечки и refcount.
    

## Практические советы

- Циклы чаще всего создаются в **объектах**, где свойства ссылаются друг на друга.
    
- После длительных скриптов (демонов, воркеров) стоит периодически вызывать `gc_collect_cycles()`.
    
- Избегай замыканий, которые замыкают `$this`, если не нужно.
    

## Полезные ссылки

- [PHP Internals: Garbage Collection](https://www.php.net/manual/en/features.gc.php)
    
- [Nikita Popov: Understanding PHP’s Memory Management](https://nikic.github.io/)
