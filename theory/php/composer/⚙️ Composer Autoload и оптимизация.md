### Как работает PSR-4 по умолчанию

- В дев-режиме Composer использует **динамический PSR-4**: при первом обращении к классу он проходит по маппингу `psr-4` и строит путь к файлу, затем **проверяет файловую систему** (несколько `stat()/file_exists()` по кандидатам, с реальным I/O).
    
- Это гибко, удобно для разработки, но платишь **системными вызовами на каждый новый класс**. Чем больше файлов и чем глубже дерево, тем заметнее.
    

### Что делает `-o` (optimize)

```bash
composer dump-autoload -o
```

- Генерирует **classmap**: `vendor/composer/autoload_classmap.php` — гигантский массив `FQN -> абсолютный путь`.
    
- При загрузке класса **нет перебора PSR-4 директорий и проверок диска**. Автолоадер сразу делает `require` по готовому пути из массива.
    
- Плюс включает **static autoloader** (второй уровень микро-оптимизаций в Composer 2), чтобы избежать лишних аллокаций.
    

Итог: меньше `stat()`, меньше syscalls, меньше realpath-разрешений. В реальных проектах это даёт **быстрее bootstrap и меньше latency на первые запросы**. Типовой выигрыш на “толстых” фреймворках: **1.3–2.5×** на время автозагрузки по сравнению с чистым PSR-4 (естественно, зависит от размера кода, FS и OPCache).

### Что делает `-a / --classmap-authoritative`

```bash
composer dump-autoload -a
```

- То же, что `-o`, но ещё **запирает** автозагрузку в classmap: Composer **перестаёт верить файловой системе** и больше **не пытается искать** класс по PSR-4 правилам, если его **нет** в карте.
    
- Минус: добавил новый класс в `src/` и не прогнал `dump-autoload` — автолоадер его **не увидит**.
    
- Плюс: минус ещё один fallback-путь, минус проверок диска. В проде — хорошо.
    

### APCu ускорение

```bash
composer dump-autoload -o --apcu-autoloader
```

- Включает **APCu-кэш путей классов** между запросами (FQN → файл).
    
- На FPM это экономит повторные обращения к огромным массивам map’а и уменьшает затраты на парсинг autoload-php. На долгоживущих рантаймах (RR/Swoole/Franken) эффект меньше, но остаётся.
    

### Конфиг через composer.json

```json
{
  "config": {
    "optimize-autoloader": true,
    "classmap-authoritative": true,
    "apcu-autoloader": true
  }
}
```

Так не забудешь включить оптимизацию на CI/CD.

---

## Почему это быстрее под капотом

1. **Меньше файлового I/O**: вместо перебора директорий и `file_exists` — прямой `require` по map.
    
2. **Меньше строковых операций**: не нужно собирать candidate-пути для каждого префикса.
    
3. **OPcache дружелюбно**: один и тот же автолоадер и classmap кэшируются в байткод.  
    Комбо с:
    
    ```ini
    opcache.enable=1
    opcache.enable_cli=0
    opcache.validate_timestamps=0
    opcache.max_accelerated_files=50000
    realpath_cache_size=4096k
    realpath_cache_ttl=600
    ```
    
    ещё режет накладные расходы.
    
4. **Без fallback’ов** в authoritative-режиме вообще нет “а вдруг тут ещё класс лежит” — экономия ветвлений и системных вызовов.
    

---

## Частые вопросы

### “Насколько быстрее, в цифрах?”

Зависит от проекта. На типичном Symfony/Laravel монолите:

- `-o` даёт **ощутимый** прирост старта приложения и первого запроса.
    
- `-a` добавляет ещё **10–20%** к времени на автозагрузке за счёт отсутствия fallback’ов.  
    Это порядок, а не контракт. Мерь `ab/wrk` до/после на своём стенде.
    

### “Что с `files` в autoload?”

```json
"autoload": {
  "psr-4": { "App\\": "src/" },
  "files": ["helpers.php"]
}
```

Секции `files` **подключаются всегда при старте**. Если там тяжёлый код — он бьёт в холодный старт. Держи `files` лёгкими, выноси всё прочее в классы, чтобы грузилось по требованию.

### “Dev vs prod?”

- В деве удобнее **динамический PSR-4**: добавил файл — сразу виден.
    
- В проде **обязательно**: `--no-dev`, `-o`, желательно `-a`, плюс APCu.  
    На долгоживущих рантаймах прод — ещё критичнее, чтобы не множить I/O.
    

### “Composer 2 и так быстрый — нужно ли `-o`?”

Да. Composer 2 оптимальнее, но **карта классов всё равно быстрее дисковых проверок**. На больших кодовых базах разница чувствуется.

---

## Рекомендуемый пайплайн для прод-сборки

```bash
composer install --no-dev --prefer-dist --no-progress --no-ansi
composer dump-autoload -o -a --apcu-autoloader
```

Проверки:

- Убедись, что **все** прод-классы попадают под `psr-4`/`classmap`.
    
- Если используешь `classmap-authoritative`, **обязательно** прогон `dump-autoload` при каждом деплое.
    

---

## Мини-чеклист

-  `--no-dev` в проде
    
-  `-o` всегда, `-a` если нет динамических магий за пределами map
    
-  `--apcu-autoloader` на FPM
    
-  Минимизируй `autoload.files`
    
-  OPcache настроен под размер проекта
    
-  На RR/Swoole — отделяй dev/prod образы, чтобы Xdebug и dev-тулы не утекали в рантайм
    

---

### Вывод

Оптимизация автолоадера — это не шаманство, а **резка дисковых проверок и ветвлений**. Чем больше кодовая база, тем выше выигрыш. В деве живи удобно, в проде — **classmap, authoritative, APCu, OPCache**.