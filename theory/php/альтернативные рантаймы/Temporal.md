**Temporal** — это фреймворк для написания **долгоживущих, надёжных и отказоустойчивых процессов**,  
которые переживают перезапуск, сбой, рестарт контейнера или даунтайм сети.

---

### 1. Суть проблемы

Обычно бизнес-процесс выглядит так:

```php
$order = $db->createOrder();
$gateway->charge($order);
$notifier->sendEmail($order);
```

Но если сервер упал между `charge` и `sendEmail`,  
получается полузавершённая операция — и руками разруливай.

Можно, конечно, городить retry-логику, дедупликацию, очереди, статусы…  
но это быстро превращается в ад.

---

### 2. Что делает Temporal

Temporal берёт на себя:

- **надёжное выполнение шагов** (автоматические retry, дедупликация);
    
- **сохранение состояния выполнения** (workflow state хранится в Temporal DB);
    
- **возможность пережить сбой и продолжить** с того же места;
    
- **оркестрацию асинхронных задач** (через _activities_ и _workflows_).
    

Ты пишешь код как будто он синхронный,  
а Temporal превращает его в устойчивый к сбоям workflow.

---

### 3. Пример

```php
// Workflow
class OrderWorkflow
{
    public function execute(int $orderId)
    {
        yield Workflow::callActivity('ChargePayment', [$orderId]);
        yield Workflow::callActivity('SendConfirmationEmail', [$orderId]);
    }
}

// Activity
function ChargePayment($orderId)
{
    // Сетевой запрос, может упасть
    $gateway->charge($orderId);
}
```

Если `ChargePayment` упадёт, Temporal:

- сохранит текущее состояние workflow,
    
- выполнит retry через заданный интервал,
    
- продолжит с этого места, как будто ничего не случилось.
    

---

### 4. Как устроено

|Компонент|Роль|
|---|---|
|**Workflow**|Определяет бизнес-процесс, управляет порядком шагов.|
|**Activity**|Конкретное действие (API-вызов, запись в БД, письмо).|
|**Temporal Server**|Оркестратор: хранит историю, состояния, ретраи.|
|**Worker**|Выполняет код workflow и activities.|

Сервер Temporal (Go) общается с воркерами по gRPC.  
Есть SDK для PHP, Python, TypeScript, Go, Java и др.  
(в PHP SDK — через клиент к Temporal API, обычно TypeScript или Go сервер крутится отдельно).

---

### 5. Почему это не просто “очередь”

Очередь (RabbitMQ, SQS, Kafka) даёт **доставку сообщений**,  
Temporal даёт **гарантию завершения процессов**.

|Что нужно|Решение|
|---|---|
|Отправить одно сообщение|Kafka / RabbitMQ|
|Убедиться, что **весь процесс** (из N шагов) завершится несмотря ни на что|Temporal|

---

### 6. Применение

- Платёжные процессы (чардж → подтверждение → уведомление → рефанд).
    
- Асинхронные интеграции (цепочки API вызовов, webhook-и).
    
- Фоновые задачи с долговременным контекстом.
    
- User onboarding (несколько шагов, может тянуться часами).
    
- Видеообработка, data pipelines.
    

---

### 7. Temporal и идемпотентность

Temporal сам обеспечивает идемпотентность за счёт **детерминированности workflow**.  
Workflow-функция должна быть чистой:  
никаких случайных чисел, текущих дат и внешних вызовов без обёртки в Activity.

> Workflow = детерминированная последовательность решений,  
> Activity = реальные side effects.

---

### 8. Аналогии

- **Event Sourcing** хранит историю состояний.
    
- **Temporal** хранит историю выполнения.
    
- В обоих случаях история = источник истины, просто разного типа.
    

---

### 9. В одной фразе

> Temporal — это когда ты пишешь обычный код,  
> а он выполняется как **надёжный распределённый workflow**,  
> который не ломается от слова «никогда». Этот workflow может растянуться хоть на полгода



https://github.com/temporalio/sdk-php

[[Saga Pattern]]
