### 1. Запуск: процесс от PHP-FPM


подробнее про [[PHP-FPM (FastCGI Process Manager)]]

---

### 2. Подготовка окружения

Воркер — это уже готовый процесс с загруженным интерпретатором Zend Engine.  
Перед выполнением запроса он:

- Загружает **php.ini** (глобально, при старте воркера, не на каждый запрос).
    
- Применяет **параметры пула FPM** (`php_admin_value`, `memory_limit`, `error_reporting`, и т.п.).
    
- Инициализирует SAPI (`fpm-fcgi`) — это слой, через который PHP взаимодействует с окружением (stdin/stdout, CGI, CLI и т.п.).
    

---

### 3. Разбор HTTP-запроса

- FPM парсит входящие **FastCGI-поля** и формирует суперглобальные переменные:
    
    - `$_SERVER` — заголовки, путь, метод, host, URI и т.п.
        
    - `$_GET` — из query string.
        
    - `$_POST` — если `Content-Type: form-urlencoded` или `multipart/form-data`.
        
    - `$_COOKIE`, `$_FILES`, `$_ENV`.
        
- На этом этапе уже готовы `$_REQUEST`, `$_SESSION` (если session.auto_start включен).
    

---

### 4. Старт пользовательского кода (`index.php`)

Когда SAPI всё подготовил, управление переходит к главному файлу — `index.php`.  
Здесь начинается исполнение кода пользователем.

---

### 5. Лексический анализ (Tokenizer)

Первый технический этап — **токенизация**:  
PHP читает текст скрипта и разбивает на токены — минимальные лексемы: ключевые слова, операторы, идентификаторы, числа, строки и т.д.

Пример:

```php
echo $x + 1;
```

превращается во что-то вроде:

```
T_ECHO, T_VARIABLE, '+', T_LNUMBER, ';'
```

Всё это делает встроенный **Zend Lex** (C-компонент интерпретатора).

---

### 6. Построение AST (Abstract Syntax Tree)

Дальше токены превращаются в **абстрактное синтаксическое дерево (AST)** —  
структуру, описывающую смысл программы.

```php
echo $x + 1;
```

→ AST из узлов:

```
Stmt_Echo
  └── Expr_BinaryOp_Add
      ├── Expr_Variable ($x)
      └── Scalar_LNumber (1)
```

AST появляется впервые в PHP 7 — раньше компиляция шла напрямую в опкоды.

---

### 7. Компиляция AST → Opcodes

AST транслируется в **опкоды (operation codes)** —  
низкоуровневые инструкции для **Zend Virtual Machine** (аналог байткода в JVM/Python).

Каждая инструкция — “операция стека”: загрузить переменную, сложить, вывести.

```
0: FETCH_R          $x
1: ADD              1
2: ECHO
3: RETURN           1
```

---

### 8. Кеширование в OpCache (если включено)

Перед исполнением PHP проверяет, есть ли готовый байткод в **OpCache**:

- если закеширован — берёт его из памяти (минуя парсер и компилятор);
    
- если нет — компилирует и сохраняет в кеше.
    

Поэтому `php.ini` директива:

```
opcache.enable=1
opcache.validate_timestamps=1
```

— делает разницу в миллисекунды на каждый запрос.

---

### 9. Выполнение (Zend Virtual Machine)

Zend VM — это стековая виртуальная машина, которая выполняет опкоды:

- У каждой функции свой стек (опкоды + таблица переменных).
    
- При каждом `require` или `include` PHP запускает новый цикл компиляции + исполнения (если не в кеше).
    
- Ошибки обрабатываются через `zend_error_cb()` (внутренний callback для error_handler).
    

---

### 10. Загрузка зависимостей (`require`, `autoload`)

Когда интерпретатор встречает:

```php
require 'vendor/autoload.php';
```

он:

- проверяет, нет ли файла в OpCache;
    
- если нет — токенизирует, строит AST, компилирует и кеширует;
    
- запускает полученные опкоды.
    

Composer’s autoloader регистрируется через:

```php
spl_autoload_register([...]);
```

и подгружает классы по мере их первого обращения.

---

### 11. JIT (Just-In-Time compilation)

С PHP 8 появился **JIT-компилятор**, который оптимизирует “горячие” участки кода:

- Zend VM анализирует трассы выполнения (опкоды, которые часто вызываются).
    
- Если трасса стабильна, JIT компилирует её в **машинные инструкции (x86-64)**.
    
- Следующие вызовы идут напрямую в CPU, минуя интерпретатор.
    

Это даёт прирост на CPU-heavy задачах (цикл, математика, сериализация).  
На типичных API/IO-heavy проектах (Symfony, Laravel) эффект скромный.

---

### 12. Завершение запроса

После выполнения:

- Интерпретатор вызывает все `register_shutdown_function()` колбэки.
    
- Освобождает переменные текущего запроса.
    
- Закрывает output buffer и возвращает тело + заголовки в SAPI.
    
- FPM отдаёт ответ nginx’у, который передаёт его клиенту.
    

**Воркеры PHP-FPM не умирают** — просто возвращаются в пул и ждут новый запрос.  
ОпCache, загруженные классы и расширения остаются в памяти.

---

### 13. Между запросами

Что **сохраняется** между запросами:

- PHP-интерпретатор и Zend Engine;
    
- ОпCache (скомпилированные опкоды);
    
- Расширения (PDO, mbstring и т.д.);
    
- Настройки php.ini.
    

Что **очищается**:

- Все пользовательские переменные и объекты;
    
- Суперглобальные массивы;
    
- Буферы вывода и ошибок;
    
- Контекст запроса (`$_SERVER`, `$_POST`, `$_GET` и т.д.).
    

---

### Кратко по шагам

|Этап|Что делает|
|---|---|
|1|nginx передаёт запрос PHP-FPM|
|2|FPM выбирает воркер|
|3|Инициализация окружения (php.ini, SAPI, суперглобальные)|
|4|PHP парсит код → токены → AST → опкоды|
|5|Опкоды кешируются в OpCache|
|6|Zend VM исполняет байткод|
|7|(опционально) JIT компилирует горячие трассы|
|8|Выполняется пользовательский код|
|9|Ответ возвращается через FPM|
|10|Воркеры остаются в пуле, всё готово к следующему запросу|

---

### Визуальная схема

```
[nginx] 
  ↓ FastCGI
[php-fpm master]
  ↓ выбирает
[php-fpm worker]
  ↓
Zend Engine
  ↓
Tokenizer → AST → Opcodes → OpCache
  ↓
Zend VM → (опционально JIT) → машинный код
  ↓
Output → FastCGI → nginx → клиент
```

---

### Итого

PHP на запрос не “интерпретирует код построчно” —  
он **компилирует** его в байткод, кеширует, и исполняет через виртуальную машину.

FPM держит воркеры живыми, OpCache экономит парсинг, а JIT ускоряет CPU-трассы.  
Всё остальное — просто слои вокруг этого процесса.


https://www.npopov.com/2012/07/27/How-to-add-new-syntactic-features-to-PHP.html#the-life-of-a-php-script

Никита Попов - топ контрибьютор php
[[Garbage Collector]]
