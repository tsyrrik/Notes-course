
Число воркеров (`pm.max_children` при `pm = static` или косвенно через `pm.max_spare_servers` и прочие при `pm = dynamic`) — это баланс между:

- **количеством одновременных запросов**,
    
- **доступной памятью**,
    
- и **временем жизни запроса**.
    

Если коротко и по делу:

---

### 1. Посчитай память

Каждый воркер PHP-FPM жрёт свой кусок RAM.  
Замерь реальное потребление:

```bash
ps -ylC php-fpm --sort:rss
```

Смотри колонку `RSS` — это примерно объём памяти на воркер (в КБ).  
Допустим, в среднем 80 МБ.

Если у тебя, скажем, 8 ГБ RAM под PHP, делаем:

```
8192 / 80 ≈ 102 воркеров максимум
```

Это потолок, не цель. Оставь запас на систему, Nginx, кеши и базу. Обычно вычитают 20–30%.

---

### 2. Посмотри нагрузку

Если у тебя:

- запросы короткие (до 50–100 мс),
    
- и трафика много,  
    то можно держать больше воркеров.
    

Если запросы долгие (по секунде и выше, например тяжёлые SQL или внешние API), лучше меньше воркеров, иначе при всплеске всё станет swap'ом.

---

### 3. Замерь пиковое количество одновременных запросов

Либо в логах Nginx (через `$upstream_response_time` и `$request_time`),  
либо через `pm.status_path` у PHP-FPM, который отдаёт JSON/HTML с метриками (active, idle, max children reached).

Если видишь в статусе `max children reached = yes` — мало воркеров.  
Если idle держится на 80–90% — слишком много.

---

### 4. Правило грубой прикидки

Для среднего backend без очередей и стриминга:

```
pm = dynamic
pm.max_children = (RAM_MB * 0.8) / AVERAGE_FPM_MB
pm.start_servers = pm.max_children / 4
pm.min_spare_servers = pm.max_children / 6
pm.max_spare_servers = pm.max_children / 2
```

---

### 5. Проверяй в бою

в `htop` по количеству php-fpm процессов.  
Если память стабильно не упирается и idle воркеров много — можно сократить.  
Если наоборот, начинается очередь в `waiting`, а CPU простаивает — добавь.


