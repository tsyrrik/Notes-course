### Что это

`php://` — это **виртуальная файловая система** PHP,  
которая даёт доступ к **потокам данных внутри самого интерпретатора**:  
входящий HTTP-трафик, вывод, stderr, память и т.п.

Можно читать и писать данные как будто это файлы,  
но на деле — это просто интерфейс к внутренним буферам и дескрипторам PHP.

---

## Основные типы php://

|Поток|Назначение|
|---|---|
|`php://input`|Сырое тело HTTP-запроса (raw body)|
|`php://output`|Буфер вывода, который уходит клиенту|
|`php://stdin`|Входной поток CLI-скрипта|
|`php://stdout`|Вывод в консоль (CLI)|
|`php://stderr`|Ошибки в консоль|
|`php://memory`|Временный буфер в RAM|
|`php://temp`|Временный буфер в RAM или файл (если большой объём)|
|`php://filter`|Обёртка для фильтрации данных (например, base64, zlib и т.п.)|

---

## `php://input`

**Самый часто используемый.**

Позволяет получить **тело HTTP-запроса как строку**,  
миновав парсер `$_POST`.

Пример:

```php
$raw = file_get_contents('php://input');
$data = json_decode($raw, true);
```

Бывает полезен при нестандартных запросах

Работает с любым `Content-Type`, не только `application/x-www-form-urlencoded`.

|Поведение|Описание|
|---|---|
|✅ Можно читать даже если тело не форм-encoded (JSON, XML и т.п.)||
|✅ Работает один раз (стрим, не массив)||
|⚠️ Не зависит от `$_POST` и `enctype`||
|⚠️ Если `enable_post_data_reading=0`, `$_POST` не заполняется, но `php://input` всё равно доступен||

---

### Отличие от `$_POST`

||`$_POST`|`php://input`|
|---|---|---|
|Источник|Распарсенное тело формы|Сырое тело запроса|
|Типы данных|Только `application/x-www-form-urlencoded`, `multipart/form-data`|Любой (JSON, XML, бинарь)|
|Множественное чтение|да|нет (только один раз)|
|Автозаполнение|PHP делает сам|читаешь вручную|

Если фронт шлёт JSON:

```js
fetch('/api', {
  method: 'POST',
  body: JSON.stringify({ name: 'Mike' }),
  headers: { 'Content-Type': 'application/json' }
});
```

то в PHP `$_POST` будет пуст, а `php://input` — содержать JSON.

---

## `php://output`

Дает доступ к **буферу вывода**, который уходит клиенту.  
Можно писать туда напрямую:

```php
$fp = fopen('php://output', 'w');
fwrite($fp, "Hello!\n");
```

Это фактически то же самое, что `echo`,  
но даёт гибкость при передаче файлов, потоков, больших ответов.

---

## `php://stdin`, `php://stdout`, `php://stderr`

Используются в CLI-скриптах.

```php
$input = trim(fgets(STDIN));            // php://stdin
fwrite(STDOUT, "Hello, $input\n");      // php://stdout
fwrite(STDERR, "Something went wrong"); // php://stderr
```

Можно явно открыть:

```php
$stdin = fopen('php://stdin', 'r');
```

Полезно в консольных утилитах, пайпах и cron-скриптах.

---

## `php://memory` и `php://temp`

Это **временные буферы**, похожие на файловые дескрипторы,  
но живут в оперативке (или во временном файле при переполнении).

```php
$fp = fopen('php://memory', 'r+');
fwrite($fp, "Data in memory\n");
rewind($fp);
echo stream_get_contents($fp);
```

- `php://memory` всегда в RAM
    
- `php://temp` — хранит в RAM до ~2 МБ, потом сбрасывает во временный файл
    

Полезно для генерации CSV, ZIP, PDF без записи на диск.

---


## Пример практического использования

### Чтение JSON-запроса

```php
$data = json_decode(file_get_contents('php://input'), true);
```

### Передача большого CSV без записи на диск

```php
$fp = fopen('php://output', 'w');
fputcsv($fp, ['id', 'name']);
fputcsv($fp, [1, 'Mike']);
```

### Временный буфер для обработки

```php
$tmp = fopen('php://temp', 'r+');
fwrite($tmp, $csvData);
rewind($tmp);
while (($row = fgetcsv($tmp)) !== false) { ... }
```

---
### Итого

`php://input` — твой инструмент, когда фронт шлёт **JSON**, **XML** или **сырой бинарь**,  
и `$_POST` остаётся пустым.

А вся `php://`-линейка — просто удобный способ **работать с данными в потоках**,  
не создавая временные файлы и не завися от окружения.

Если `fopen()` тебе кажется устаревшим — знай: под капотом PHP любой `echo`, `readfile`, `curl_exec` и `ob_*` всё равно гоняют данные через эти потоки.

## Смотри также

- [[PHP тип 'resource']]
