## Вопрос: Очереди (что и зачем)

## Простой ответ
- Коробка, куда кладут задачи, а воркеры забирают и делают.
- Позволяет не ждать ответ сразу и пережить временные падения получателя.

- FIFO механизм для задач/сообщений: отправитель кладет, потребитель обрабатывает и удаляет.
- Зачем: разгрузка, асинхронность, устойчивость при недоступности получателя, разделение отправителя/обработчика.
- Примеры: RabbitMQ, Kafka.

## Ответ

### Что такое очереди сообщений

Очередь сообщений (Message Queue) — это промежуточный буфер между отправителем (producer) и получателем (consumer), который принимает, хранит и доставляет сообщения в определённом порядке. Основной принцип — FIFO (First In, First Out): первое отправленное сообщение обрабатывается первым. Очередь реализует паттерн асинхронного взаимодействия: отправитель не ждёт, пока получатель обработает сообщение.

### Зачем нужны очереди

Очереди решают несколько ключевых архитектурных задач:

- **Развязка компонентов (Decoupling).** Продюсер и консьюмер не знают друг о друге — они общаются через очередь. Можно менять, масштабировать и деплоить их независимо.
- **Сглаживание нагрузки (Load Leveling).** При всплеске запросов очередь буферизирует задачи, и воркеры обрабатывают их в своём темпе, не перегружая систему.
- **Надёжность (Reliability).** Если потребитель упал, сообщения не теряются — они ждут в очереди. После восстановления обработка продолжается.
- **Масштабируемость.** Можно добавлять воркеров горизонтально: 1, 5, 50 потребителей на одну очередь.

### Основные паттерны

| Паттерн | Описание | Пример |
|---|---|---|
| Point-to-Point | Одно сообщение — один потребитель | Фоновая обработка заказа |
| Pub/Sub | Одно сообщение — все подписчики | Уведомления, события |
| Work Queue (Competing Consumers) | Несколько воркеров разбирают одну очередь | Обработка email-рассылки |
| Request-Reply | Отправитель ждёт ответа через другую очередь | RPC через очередь |

### Гарантии доставки

| Гарантия | Описание | Когда использовать |
|---|---|---|
| At-most-once | Сообщение может потеряться, но не дублируется | Метрики, логи (некритичная потеря) |
| At-least-once | Сообщение доставлено минимум раз (могут быть дубли) | Большинство задач (+ идемпотентность) |
| Exactly-once | Ровно одно вычисление (транзакции/дедупликация) | Финансы, критичные операции |

### Плюсы

- Развязывает темпы продюсеров и потребителей.
- Легко горизонтально масштабировать обработчиков.
- Можно ставить ретраи/DLQ и не терять задачи.
- Повышает отказоустойчивость — падение потребителя не ломает систему.
- Позволяет обрабатывать пиковые нагрузки без потери данных.

### Минусы

- Потенциальная задержка доставки, сложнее end-to-end трассировка.
- Нужно думать об идемпотентности/повторной обработке.
- Дополнительная инфраструктура: нужно поддерживать брокер.
- Усложняет отладку: сообщение проходит через несколько систем.
- Eventual consistency — данные обновляются не мгновенно.

### Ключевые концепции

**Acknowledgement (ACK)** — подтверждение обработки. Потребитель сообщает брокеру, что сообщение обработано. Без ACK брокер перевыдаст сообщение другому потребителю.

**Dead Letter Queue (DLQ)** — очередь для сообщений, которые не удалось обработать после N попыток. Позволяет не блокировать основную очередь и анализировать проблемы.

**TTL (Time to Live)** — максимальное время жизни сообщения. По истечении TTL сообщение удаляется или перемещается в DLQ.

**Идемпотентность** — свойство обработки, при котором повторное применение одного и того же сообщения не меняет результат. Критично при at-least-once доставке.

### Пример: простая очередь задач (PHP)

```php
// Продюсер — кладёт задачу
$queue->push([
    'id'       => Uuid::v4(),        // для идемпотентности
    'email'    => 'user@example.com',
    'template' => 'welcome',
    'retry'    => 0,
]);

// Воркер — обрабатывает задачи
while ($job = $queue->pop()) {
    try {
        sendEmail($job['email'], $job['template']);
        $queue->ack($job);
    } catch (TemporaryException $e) {
        if ($job['retry'] < 3) {
            $job['retry']++;
            $queue->push($job);       // повторная попытка
        } else {
            $queue->pushToDLQ($job);  // в dead letter queue
        }
        $queue->ack($job);
    }
}
```

### Популярные брокеры сообщений

| Брокер | Модель | Сильные стороны |
|---|---|---|
| RabbitMQ | Классические очереди + exchange | Маршрутизация, приоритеты, DLX, протокол AMQP |
| Apache Kafka | Append-only лог, партиции | Высокая пропускная способность, replay, stream processing |
| Redis (Streams/Lists) | In-memory, легковесный | Низкая задержка, простота, уже есть в стеке |
| Amazon SQS | Managed cloud queue | Без управления инфраструктурой, интеграция с AWS |
| NATS | Lightweight pub/sub | Микросервисы, IoT, минимальная задержка |

## Примеры
```text
At-least-once + идемпотентность — базовая связка для надёжной обработки.
```

## Доп. теория
- Очереди дают асинхронность, но добавляют задержку и eventual consistency.
- Важно проектировать ретраи и DLQ с первого дня.
