## Вопрос: Singleton как антипаттерн

## Простой ответ
- Глобальный единственный объект делает код зависимым от скрытого состояния и плохо тестируется.
- Если нужен «один экземпляр», лучше отдавать его через DI как shared-сервис.
```php
class Singleton {
    private static ?self $instance = null;
    private function __construct() {}
    public static function getInstance(): self {
        return self::$instance ??= new self();
    }
}
```

## Ответ

### Почему Singleton — антипаттерн

**1. Глобальное состояние**
Singleton — по сути глобальная переменная. Любой код может вызвать `Singleton::getInstance()` и изменить состояние. Отследить все точки взаимодействия сложно.

**2. Скрытые зависимости**
Зависимость от Singleton не видна в конструкторе — она спрятана внутри методов. Невозможно понять зависимости класса без чтения всего его кода.

**3. Сложное тестирование**
- Состояние Singleton сохраняется между тестами → тесты влияют друг на друга
- Невозможно подставить mock без хаков (Reflection, runkit)
- Параллельные тесты могут конфликтовать

**4. Нарушение SOLID**
- **SRP**: класс управляет и своей логикой, и своим жизненным циклом
- **DIP**: код зависит от конкретного класса, а не от абстракции
- **OCP**: невозможно расширить или заменить реализацию

**5. Проблемы при масштабировании**
- В многопоточной среде возможны гонки при создании экземпляра
- При горизонтальном масштабировании «единственный экземпляр» — иллюзия

### Альтернатива: DI + shared binding

```php
// Вместо Singleton
class Logger {
    // Обычный класс, без static getInstance()
    public function __construct(private string $path) {}
    public function info(string $msg): void { /* ... */ }
}

// В DI-контейнере — один экземпляр на приложение
// Laravel:
$this->app->singleton(Logger::class, fn() => new Logger('/var/log/app.log'));

// Symfony (services.yaml):
// App\Service\Logger:
//     shared: true  # singleton по умолчанию
```

**Результат**: один экземпляр, но без проблем Singleton — зависимость явная, тестируемая, подменяемая.

### Когда Singleton допустим

- Инфраструктурный код, который гарантированно один (подключение к БД в legacy-коде)
- Реестры/конфигурации, которые неизменяемы после инициализации
- Но и в этих случаях DI-контейнер предпочтительнее

## Примеры
```text
Вместо Singleton: регистрируйте сервис как shared в DI‑контейнере.
```

## Доп. теория
- Singleton часто маскирует глобальные зависимости.
- «Один экземпляр» на процесс ≠ один экземпляр в распределённой системе.
