## Вопрос: ООП: базовые принципы

## Простой ответ
- Прячем детали внутри классов (инкапсуляция), строим иерархии (наследование), работаем через общие интерфейсы (полиморфизм), оставляем только важное (абстракция).

| Принцип | Описание |
| --- | --- |
| Инкапсуляция | Сокрытие реализации, наружу — только интерфейс. |
| Наследование | Создание классов на основе существующих. |
| Полиморфизм | Разные классы обрабатываются одинаково через общий интерфейс. |
| Абстракция | Выделение ключевых характеристик, скрытие деталей. |

```php
interface Notifier { public function send(string $msg): void; }

class EmailNotifier implements Notifier {
    public function send(string $msg): void { /* ... */ }
}

class SmsNotifier implements Notifier {
    public function send(string $msg): void { /* ... */ }
}

function alertUser(Notifier $notifier): void { // полиморфизм
    $notifier->send('Hello!');
}
```

## Ответ

### Инкапсуляция

Сокрытие внутреннего состояния и реализации за публичным интерфейсом. Объект контролирует доступ к своим данным через модификаторы видимости (`public`, `protected`, `private`).

**Зачем**: защита от некорректного использования, возможность менять реализацию без изменения внешнего API.

```php
class BankAccount {
    private float $balance = 0;

    public function deposit(float $amount): void {
        if ($amount <= 0) throw new \InvalidArgumentException('Amount must be positive');
        $this->balance += $amount;
    }

    public function getBalance(): float { return $this->balance; }
    // Нельзя напрямую: $account->balance = -1000;
}
```

### Наследование

Создание нового класса на основе существующего. Наследник получает свойства и методы родителя и может их переопределять.

**Правило**: используйте наследование для отношения «является» (is-a), а не «имеет» (has-a). Предпочитайте композицию наследованию.

```php
class Animal {
    public function breathe(): void { /* ... */ }
}

class Dog extends Animal {
    public function bark(): void { /* ... */ }
}
// Dog является Animal, Dog умеет breathe() + bark()
```

### Полиморфизм

Возможность работать с объектами разных классов через единый интерфейс. Вызывающий код не знает конкретный класс — вызывается метод того объекта, который передан.

```php
interface Shape {
    public function area(): float;
}

class Circle implements Shape {
    public function __construct(private float $r) {}
    public function area(): float { return M_PI * $this->r ** 2; }
}

class Rectangle implements Shape {
    public function __construct(private float $w, private float $h) {}
    public function area(): float { return $this->w * $this->h; }
}

function printArea(Shape $shape): void {
    echo $shape->area(); // полиморфный вызов — не важно, Circle или Rectangle
}
```

### Абстракция

Выделение существенных характеристик объекта и игнорирование несущественных деталей. Реализуется через абстрактные классы и интерфейсы.

```php
// Абстракция: знаем ЧТО делает, не знаем КАК
interface Cache {
    public function get(string $key): mixed;
    public function set(string $key, mixed $value, int $ttl = 3600): void;
}

// Конкретная реализация скрыта за абстракцией
class RedisCache implements Cache { /* ... */ }
class FileCache implements Cache { /* ... */ }
```

### Связь с SOLID

- Инкапсуляция → Single Responsibility (класс отвечает за свои данные)
- Полиморфизм → Open/Closed, Dependency Inversion (зависим от абстракций)
- Наследование → Liskov Substitution (наследник заменяет родителя)

## Примеры
```text
Инкапсуляция: скрываем поля и даём методы доступа.
Полиморфизм: работаем через интерфейс, не зная конкретного класса.
```

## Доп. теория
- В ООП ценится композиция над наследованием для гибкости.
- Абстракция помогает отделить «что» от «как».
