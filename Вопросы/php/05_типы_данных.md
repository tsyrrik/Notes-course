## Вопрос: Типы данных
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
скаляры + составные + специальные; в PHP 8+ появились union/intersection/DNF, `mixed`, `never`, а также отдельные типы `true/false`.

## Ответ

PHP — язык с динамической типизацией: тип переменной определяется присвоенным значением и может меняться. Однако начиная с PHP 7.0 можно объявлять типы аргументов и возвращаемых значений, а с PHP 7.4 — типы свойств.

### Классификация типов

| Группа | Типы |
| --- | --- |
| Скалярные | `int`, `float`, `string`, `bool` |
| Составные | `array`, `object`, `callable`, `iterable` |
| Специальные | `null`, `resource`, `never`, `void` |

### Система типов в PHP 8.x

- **Union types** (8.0): `int|string` — значение может быть одним из перечисленных типов.
- **Intersection types** (8.1): `Countable&Iterator` — значение должно реализовывать все указанные интерфейсы.
- **DNF types** (8.2): `(A&B)|null` — комбинация union и intersection.
- **`mixed`** (8.0): эквивалент `object|resource|array|string|float|int|bool|null` — принимает всё.
- **`never`** (8.1): функция никогда не возвращает значение (бросает исключение или вызывает `exit`).
- **`void`** (7.1): функция ничего не возвращает (но завершается нормально).
- **`true`/`false`/`null`**: отдельные типы, полезны в union: `string|false` (тип `true` — с PHP 8.2, `false` — с PHP 8.0).
- **`static`** (8.0, только для return type): тип вызывающего класса (для fluent interfaces).

### Приведение типов (type juggling)

Без `strict_types=1` PHP автоматически приводит типы:
- `"123"` → `123` (string → int)
- `0` → `false`, `1` → `true` (int → bool)
- `""` → `false`, `"0"` → `false` — известная ловушка

С `declare(strict_types=1)` передача `"123"` где ожидается `int` выбросит `TypeError`.

> `strict_types` действует только в **вызывающем** файле, а не в файле с определением функции.

## Примеры

```php
declare(strict_types=1);

// Union type
function format(int|float $value): string {
    return number_format($value, 2);
}

// Intersection type
function count(Countable&Iterator $collection): int {
    return iterator_count($collection);
}

// DNF type (PHP 8.2)
function process((Stringable&Countable)|null $input): void {
    if ($input === null) return;
    echo count($input) . ': ' . (string) $input;
}

// never — функция не возвращает управление
function abort(string $msg): never {
    throw new \RuntimeException($msg);
}

// Приведение типов — ловушки
var_dump(0 == "foo");    // false (PHP 8.0+), было true в PHP 7
var_dump("" == "0");     // false
var_dump(null == false);  // true (оба falsy)
```

## Доп. теория
- `callable` и `iterable` — псевдотипы, они не существуют как реальные типы в рантайме.
- `mixed` эквивалентен объединению всех типов и означает «любой тип».
