## Вопрос: declare(strict_types)
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
`declare(strict_types=1);` заставляет PHP выбрасывать TypeError вместо тихого приведения аргументов/возвратов. По умолчанию PHP пытается конвертировать типы.

## Ответ

### Как работает strict_types

`declare(strict_types=1)` включает строгую проверку типов для скалярных аргументов и возвращаемых значений. Без этой директивы PHP использует **coercive mode** — пытается привести значение к нужному типу (например, `"42"` → `42`).

**Ключевые правила:**

1. Директива действует **только в файле, где объявлена** — это свойство вызывающего файла, а не определяющего. Если функция определена в файле без `strict_types`, но вызывается из файла с `strict_types=1`, проверка будет строгой.
2. Должна быть **первой инструкцией** в файле (после `<?php`). До неё допускается только `declare(encoding=...)`.
3. Влияет на **скалярные типы**: `int`, `float`, `string`, `bool`. Для классов и интерфейсов проверка всегда строгая.
4. Исключение: `int` → `float` допускается даже в строгом режиме (`function calc(float $v)` примет `42`).
5. Не влияет на операторы (`+`, `.` и т.д.) — только на вызовы функций.

### Coercive mode (по умолчанию)

Без `strict_types` PHP пытается привести типы:
- `"123"` → `123` (string → int) — успешно
- `"123abc"` → `123` + Deprecation notice (PHP 8.1+)
- `"abc"` → TypeError (не конвертируется)

### Рекомендации

- В новом коде **всегда** используйте `declare(strict_types=1)` — это ловит баги на раннем этапе.
- Современные IDE и CI (PHPStan, Psalm) в строгом режиме работают точнее.
- В legacy-коде включение может сломать неявные приведения — вводите постепенно.

## Примеры

```php
declare(strict_types=1);

function sum(int $a, int $b): int { return $a + $b; }

sum(1, 2);     // OK → 3
sum(1, "2");   // TypeError: Argument #2 must be of type int, string given
sum(1, 2.0);   // TypeError: float не приводится к int в строгом режиме

// int → float допустимо даже в strict mode
function divide(float $a, float $b): float { return $a / $b; }
divide(10, 3); // OK → 3.333... (int 10 приведён к float)
```

```php
// Возвращаемый тип тоже проверяется
function getName(): string {
    return 123; // TypeError: Return value must be of type string, int returned
}
```

## Доп. теория
- `strict_types` действует на **вызовы**, сделанные из файла, где он объявлен. Это касается и вызовов внутренних функций.
- Вызовы, сделанные **изнутри внутренних функций**, не наследуют строгий режим вызывающего файла.
- Типы свойств проверяются **всегда**, независимо от `strict_types`.
