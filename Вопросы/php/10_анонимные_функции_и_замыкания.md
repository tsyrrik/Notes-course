## Вопрос: Анонимные функции и замыкания
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
- Анонимки — обычные функции без имени; замыкания захватывают внешние переменные (`use` или стрелочные с неявным `use` по значению).

## Ответ

### Анонимные функции (Closures)

Анонимная функция — это объект класса `Closure`. Она не имеет имени и может быть присвоена переменной, передана как аргумент или возвращена из функции.

```php
$greet = function(string $name): string {
    return "Hello, $name";
};
echo $greet('Alice'); // Hello, Alice
```

### Захват переменных (use)

По умолчанию анонимная функция **не имеет доступа** к переменным из внешней области видимости. Для захвата используется `use`:

```php
$prefix = 'Dear';
$greet = function(string $name) use ($prefix): string {
    return "$prefix $name";
};
// $prefix захвачена **по значению** — изменение оригинала не влияет
$prefix = 'Hey';
echo $greet('Bob'); // Dear Bob

// Захват по ссылке
$counter = 0;
$increment = function() use (&$counter): void {
    $counter++;
};
$increment();
echo $counter; // 1
```

### Стрелочные функции (PHP 7.4+)

Короткий синтаксис для однострочных замыканий. Все переменные из внешнего scope захватываются **неявно по значению**:

```php
$factor = 3;
$multiply = fn(int $x): int => $x * $factor;
echo $multiply(5); // 15

// Удобно в array_map/array_filter
$even = array_filter([1,2,3,4], fn($n) => $n % 2 === 0); // [2, 4]
```

### Closure::bind и Closure::call

Можно привязать замыкание к конкретному объекту/классу, получив доступ к его private/protected:

```php
class Wallet {
    private int $balance = 100;
}

$getBalance = Closure::bind(
    function() { return $this->balance; },
    new Wallet(),
    Wallet::class
);
echo $getBalance(); // 100

// Closure::call — быстрее, без создания нового замыкания
$fn = function() { return $this->balance; };
echo $fn->call(new Wallet()); // 100
```

### First-class callable syntax (PHP 8.1+)

Позволяет получить `Closure` из любой функции/метода:

```php
$len = strlen(...);         // Closure из глобальной функции
$arr = [3, 1, 2];
usort($arr, strcmp(...));    // передаём функцию как callable

class Math {
    public static function square(int $n): int { return $n ** 2; }
}
$sq = Math::square(...);    // Closure из статического метода
echo $sq(4); // 16
```

### Отличия анонимных функций от стрелочных

| Свойство | `function() use ()` | `fn() =>` |
| --- | --- | --- |
| Многострочное тело | Да | Нет (только выражение) |
| Захват переменных | Явный через `use` | Неявный, все по значению |
| Захват по ссылке | `use (&$var)` | Невозможно |
| PHP версия | 5.3+ | 7.4+ |

## Примеры
```php
// Замыкание как фабрика
function makeAdder(int $n): Closure {
    return fn(int $x): int => $x + $n;
}
$add5 = makeAdder(5);
echo $add5(10); // 15
```

```php
// Привязка к объекту
class User { private string $name = 'Alice'; }
$getName = function() { return $this->name; };
echo $getName->call(new User()); // Alice
```

## Доп. теория
- Анонимные функции — экземпляры `Closure`, их можно типизировать как `Closure` или `callable`.
- Стрелочные функции захватывают переменные **по значению** и не поддерживают `use (&$var)`.
