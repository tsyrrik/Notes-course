## Вопрос: Конфликт методов трейта и класса
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
если метод есть и в классе, и в трейте, победит метод класса. Для явного вызова метода из трейта — алиас через `as` (а для конфликтующих трейтов — `insteadof`).

## Ответ

### Приоритет разрешения методов

PHP использует чёткий порядок при конфликте имён:

1. **Метод класса** — всегда побеждает
2. **Метод трейта** — переопределяет метод родителя
3. **Метод родительского класса** — самый низкий приоритет

```
Класс > Трейт > Родительский класс
```

### Конфликт между классом и трейтом

Метод класса автоматически побеждает — конфликта нет:

```php
trait Hello {
    public function sayHello(): string { return 'Trait'; }
}

class Greeter {
    use Hello;

    public function sayHello(): string {
        return 'Class'; // этот метод побеждает
    }
}

echo (new Greeter())->sayHello(); // "Class"
```

### Вызов метода трейта из класса

Через `as` можно создать алиас и вызвать метод трейта:

```php
class Greeter {
    use Hello {
        sayHello as traitHello;
    }

    public function sayHello(): string {
        return 'Class then ' . $this->traitHello();
    }
}

echo (new Greeter())->sayHello(); // "Class then Trait"
```

### Конфликт между двумя трейтами

Если два трейта определяют метод с одинаковым именем — это **fatal error**. Решается через `insteadof`:

```php
trait A {
    public function greet(): string { return 'A'; }
}

trait B {
    public function greet(): string { return 'B'; }
}

class C {
    use A, B {
        A::greet insteadof B; // greet() берём из A
        B::greet as greetB;   // greet() из B доступен как greetB()
    }
}

$c = new C();
echo $c->greet();  // A
echo $c->greetB(); // B
```

### Конфликт свойств

Если два трейта определяют свойство с **одинаковым именем, типом и видимостью** — конфликта нет. Если различаются — fatal error, и `insteadof` для свойств не работает. Решение — вынести свойство в класс.

## Примеры
```php
trait T1 { public function hello(): string { return 't1'; } }
trait T2 { public function hello(): string { return 't2'; } }

class C {
    use T1, T2 {
        T1::hello insteadof T2;
        T2::hello as helloT2;
    }
}
```

## Доп. теория
- `as` можно использовать и для изменения видимости методов трейта (`as private`).
