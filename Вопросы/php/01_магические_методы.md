## Вопрос: Магические методы
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
методы с `__`, которые PHP вызывает сам при особых ситуациях (создание, доступ к свойствам/методам, сериализация, вывод).

## Ответ
Магические методы позволяют переопределять стандартные действия PHP над объектами: создание/уничтожение, доступ к свойствам, вызов методов, приведение типов и сериализация.

### Конструктор / деструктор / клонирование

- `__construct()` — вызывается при создании объекта (`new`). Основное место для инициализации зависимостей. В PHP 8.0+ поддерживает constructor promotion (`public function __construct(private string $name) {}`).
- `__destruct()` — вызывается при уничтожении объекта (когда refcount = 0 или при завершении скрипта). Используется для освобождения ресурсов (закрытие файлов, соединений). Порядок вызова деструкторов не гарантирован.
- `__clone()` — вызывается при `clone $obj`. Позволяет сделать глубокую копию вложенных объектов (по умолчанию клонируются только примитивы, объекты копируются по ссылке).

### Перехват свойств

- `__get($name)` — вызывается при чтении недоступного (private/protected/несуществующего) свойства.
- `__set($name, $value)` — вызывается при записи в недоступное свойство.
- `__isset($name)` — вызывается при `isset()` / `empty()` на недоступном свойстве.
- `__unset($name)` — вызывается при `unset()` на недоступном свойстве.

> В PHP 8.4 для контроля доступа к свойствам предпочтительнее использовать Property Hooks вместо `__get`/`__set`.

### Перехват методов

- `__call($name, $args)` — вызывается при обращении к недоступному методу объекта.
- `__callStatic($name, $args)` — аналог для статических вызовов.

Часто используется в ORM (Eloquent: `User::findByEmail(...)`) и для реализации паттерна Proxy/Decorator.

### Приведение типов

- `__toString()` — вызывается при приведении объекта к строке (`echo $obj`, строковая интерполяция, конкатенация). Обязательно возвращает `string`.
- `__invoke(...$args)` — позволяет использовать объект как функцию: `$obj()`. Применяется в middleware, стратегиях, callable-объектах.

### Сериализация

- `__sleep()` / `__wakeup()` — старый механизм: `__sleep()` возвращает массив имён свойств для `serialize()`, `__wakeup()` восстанавливает ресурсы после `unserialize()`.
- `__serialize()` / `__unserialize(array $data)` — новый механизм (PHP 7.4+), заменяет `__sleep`/`__wakeup`. Возвращает произвольный массив данных, что даёт полный контроль над форматом.

Если класс определяет и `__serialize`, и `__sleep`, PHP вызывает только `__serialize`.

### Экспорт и отладка

- `__set_state(array $props)` — вызывается при `var_export()`. Должен вернуть новый экземпляр класса.
- `__debugInfo()` — управляет выводом `var_dump()`. Позволяет скрыть чувствительные поля (пароли, токены).

### Важные нюансы для собеседования

1. Магические методы **медленнее** обычных вызовов — PHP выполняет дополнительные проверки.
2. `__toString()` не должен бросать исключений до PHP 7.4; с PHP 7.4 разрешено.
3. `__clone()` — единственный способ контролировать глубокое клонирование.
4. Чрезмерное использование `__get`/`__set` усложняет IDE-автокомплит и статический анализ (PHPStan/Psalm). Предпочитайте явные свойства.

## Примеры

**Пример 1: магия свойств и stringify**
```php
class User {
    private array $data = [];

    public function __get(string $name) { return $this->data[$name] ?? null; }
    public function __set(string $name, $value) { $this->data[$name] = $value; }
    public function __toString(): string { return $this->data['name'] ?? 'no-name'; }
}

$u = new User();
$u->name = 'Alice';
echo $u;          // Alice
echo $u->age;     // null, но без Notice
```

**Пример 2: __invoke — объект как callable**
```php
class Multiplier {
    public function __construct(private int $factor) {}
    public function __invoke(int $value): int { return $value * $this->factor; }
}

$double = new Multiplier(2);
echo $double(5);  // 10
echo array_map($double, [1, 2, 3]); // [2, 4, 6]
```

**Пример 3: __clone — глубокое клонирование**
```php
class Order {
    public function __construct(
        public int $id,
        public Address $address,
    ) {}

    public function __clone(): void {
        $this->address = clone $this->address; // глубокая копия
    }
}

$order1 = new Order(1, new Address('Moscow'));
$order2 = clone $order1;
$order2->address->city = 'SPb';
echo $order1->address->city; // Moscow — не изменился
```

**Пример 4: __serialize / __unserialize (PHP 7.4+)**
```php
class Connection {
    private \PDO $pdo;

    public function __construct(private string $dsn) {
        $this->pdo = new \PDO($dsn);
    }

    public function __serialize(): array {
        return ['dsn' => $this->dsn]; // PDO не сериализуется
    }

    public function __unserialize(array $data): void {
        $this->dsn = $data['dsn'];
        $this->pdo = new \PDO($this->dsn); // пересоздаём
    }
}
```

## Доп. теория
- Все магические методы, кроме `__construct()`, `__destruct()`, `__clone()`, должны быть `public`, иначе будет `E_WARNING`.
- Сигнатуры магических методов должны соответствовать документации; иначе фатальная ошибка (актуально с PHP 8.0).
- `__serialize()`/`__unserialize()` появились в PHP 7.4 и предназначены для замены `Serializable`.
