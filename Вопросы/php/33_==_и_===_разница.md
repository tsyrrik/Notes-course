## Вопрос: == и ===
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
`==` может дать сюрпризы из-за приведения (`"0"`, `""`, `"0e123"`, `false`, `[]`), поэтому по умолчанию — только `===`.

## Ответ

### Нестрогое сравнение (==)

Оператор `==` приводит операнды к одному типу перед сравнением (type juggling). Правила приведения сложные и часто неинтуитивные.

### Строгое сравнение (===)

Оператор `===` сравнивает **и тип, и значение**. Никакого приведения — разные типы всегда дают `false`.

### Таблица опасных сравнений с == (PHP 8.0+)

```php
// PHP 8.0 ИЗМЕНИЛ поведение — стало безопаснее, но ловушки остались:
0 == "foo"      // false (PHP 8.0+), было true в PHP 7!
0 == ""         // false (PHP 8.0+), было true в PHP 7!

// Всё ещё опасно:
"" == null      // true
"" == false     // true
0 == false      // true
0 == null       // true
"0" == false    // true
"0" == null     // false (!)
[] == false     // true
"1" == true     // true

// Ловушка с хешами:
"0e123" == "0e456"  // true! Оба = 0 в научной нотации
"0e123" === "0e456" // false
```

### Правила приведения при ==

1. `null`/`false` == пустая строка `""` → `true`
2. Строка из цифр vs число → строка приводится к числу
3. `bool` vs что угодно → второй операнд приводится к `bool`
4. `null` vs `0` → `true` (null приводится к 0)

### Рекомендации

1. **Всегда используйте `===`** — предсказуемое поведение
2. Используйте `match` вместо `switch` — `match` использует строгое сравнение
3. Для массивов: `===` проверяет порядок ключей, `==` — нет

```php
// Массивы: == vs ===
$a = ['x' => 1, 'y' => 2];
$b = ['y' => 2, 'x' => 1];
var_dump($a == $b);  // true (одинаковые пары ключ-значение)
var_dump($a === $b); // false (порядок разный)
```

## Примеры
```php
// Всегда используйте ===
if ($status === 0) { /* ... */ }
```

### Связанные функции

```php
// in_array — по умолчанию использует ==
in_array(0, ['foo', 'bar']);          // true в PHP 7! false в PHP 8
in_array(0, ['foo', 'bar'], true);   // false — третий параметр strict

// array_search — аналогично
array_search('', [0, 1, 2]);         // 0 в PHP 7! false в PHP 8
array_search('', [0, 1, 2], true);   // false — strict mode
```

## Доп. теория
- Нестрогое сравнение — источник уязвимостей (например, "0e"-хэши). В критичных местах сравнивайте строки строго.
