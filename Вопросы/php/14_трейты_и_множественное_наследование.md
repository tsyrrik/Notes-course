## Вопрос: Множественное наследование и трейты
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
в PHP нет множественного наследования классов; код переиспользуем через интерфейсы (контракты) и трейты (вмешивание реализаций).

## Ответ

PHP не поддерживает множественное наследование классов (в отличие от C++). Вместо этого используются **интерфейсы** (контракт) и **трейты** (переиспользование кода).

### Трейты (traits)

Трейт — это механизм горизонтального переиспользования кода. По сути, компилятор «вставляет» код трейта в класс на этапе компиляции.

Трейт может содержать:
- Методы (public, protected, private)
- Свойства
- Абстрактные методы
- Константы (PHP 8.2+)

### Приоритет методов

1. **Метод класса** — высший приоритет
2. **Метод трейта** — средний
3. **Метод родительского класса** — низший

### Разрешение конфликтов

Если два трейта имеют метод с одинаковым именем — PHP выбросит fatal error. Решение:

```php
trait A { public function hello(): string { return 'A'; } }
trait B { public function hello(): string { return 'B'; } }

class C {
    use A, B {
        A::hello insteadof B;  // используем hello из A
        B::hello as helloB;    // hello из B доступен как helloB
    }
}

$c = new C();
echo $c->hello();  // A
echo $c->helloB(); // B
```

### Изменение видимости

```php
trait Secret {
    public function reveal(): string { return 'secret'; }
}

class Vault {
    use Secret {
        reveal as private; // делаем метод приватным
    }
}
```

### Абстрактные методы в трейтах

Трейт может требовать, чтобы класс реализовал определённые методы:

```php
trait Cacheable {
    abstract protected function cacheKey(): string;

    public function cache(): void {
        $key = $this->cacheKey();
        // логика кеширования
    }
}

class User {
    use Cacheable;

    protected function cacheKey(): string {
        return 'user_' . $this->id;
    }
}
```

## Примеры
```php
trait Timestamps {
    public function touch(): void { $this->updatedAt = time(); }
}

class Post {
    use Timestamps;
    public int $updatedAt = 0;
}
```

## Доп. теория
- Трейты могут использовать другие трейты (`use AnotherTrait;` внутри трейта).
- Трейт — не тип: нельзя сделать type-hint на трейт, только на интерфейс/класс.

### Когда использовать трейты

- **Подходит**: переиспользование кода между несвязанными классами (логирование, soft delete, timestamps).
- **Не подходит**: замена интерфейсов и наследования. Трейт — это «copy-paste на уровне компилятора», не абстракция.
- **Антипаттерн**: «God trait» — трейт с десятками методов. Трейт должен быть маленьким и сфокусированным.
