## Вопрос: Создание объекта абстрактного класса
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
- Абстрактный класс — только базовый для наследников, напрямую `new` делать нельзя.

## Ответ

Абстрактный класс — это класс с модификатором `abstract`, который **нельзя создать напрямую** через `new`. Попытка приведёт к: `Fatal error: Cannot instantiate abstract class`.

### Зачем это нужно

Абстрактный класс задаёт **шаблон** для наследников. Он может содержать:
- Обычные методы с реализацией (общий код)
- Абстрактные методы без реализации (обязательные к переопределению)
- Свойства, конструктор, константы

Наследник **обязан** реализовать все абстрактные методы, иначе тоже должен быть объявлен `abstract`.

## Примеры

```php
abstract class Shape {
    abstract public function area(): float;

    // Обычный метод — общая реализация
    public function describe(): string {
        return static::class . ': area = ' . $this->area();
    }
}

class Circle extends Shape {
    public function __construct(private float $radius) {}
    public function area(): float { return M_PI * $this->radius ** 2; }
}

// new Shape(); // Fatal error: Cannot instantiate abstract class Shape
$c = new Circle(5);
echo $c->describe(); // Circle: area = 78.539...
```

### Можно ли обойти?

Технически через Reflection (`ReflectionClass::newInstanceWithoutConstructor`), но это антипаттерн — используется только в тестах и ORM (Doctrine hydration). В бизнес-коде — никогда.

```php
// Только для понимания — НЕ делайте так
$ref = new ReflectionClass(Shape::class);
// $ref->newInstanceWithoutConstructor(); // всё равно Fatal error для abstract
```

## Доп. теория
- Абстрактные методы задают обязательные «точки расширения» для наследников.
- Если хотя бы один абстрактный метод не реализован, класс тоже должен быть `abstract`.
