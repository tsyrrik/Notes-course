## Вопрос: Передача по ссылке
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
две переменные указывают на один и тот же zval, изменение одной видно в другой. По умолчанию PHP копирует при записи (COW), ссылки ломают эту оптимизацию.

## Ответ

В PHP переменные по умолчанию передаются **по значению** — функция получает копию. При передаче **по ссылке** (`&`) обе переменные указывают на одну и ту же структуру данных (zval), и изменения в одной отражаются в другой.

### Как это работает на уровне движка

PHP использует zval-структуру для хранения значений. При присваивании `$b = $a` (без `&`) PHP не копирует данные сразу — используется механизм Copy-on-Write (COW). Но при создании ссылки `$b = &$a` COW **отключается** для этого zval: обе переменные привязаны к одному значению напрямую.

### Когда использовать

- **Оправдано**: когда функция должна модифицировать переданный аргумент (например, `preg_match($pattern, $str, &$matches)`, `array_walk`).
- **Не нужно**: для «оптимизации» передачи больших массивов/строк — PHP уже делает COW, и копия создастся только при изменении.
- **Объекты**: всегда передаются «по handle» — переменная содержит идентификатор объекта, а не сам объект. `&` на объекте позволяет заменить саму переменную на другой объект, но редко нужен.

### Опасности

1. **Неожиданные побочные эффекты** — вызывающий код не ожидает, что его переменная изменится.
2. **Ломает COW** — использование ссылки приводит к реальному копированию данных при присваивании другой переменной.
3. **foreach по ссылке** — классическая ловушка: `&$value` остаётся ссылкой после цикла.

## Примеры

**Базовая передача по ссылке**
```php
$b = 1;
$a = &$b; // $a и $b указывают на одно zval
$b = 2;
echo $a; // 2
```

**Передача по ссылке в функцию**
```php
function increment(int &$value): void {
    $value++;
}

$x = 5;
increment($x);
echo $x; // 6
```

**Ловушка foreach по ссылке**
```php
$items = [1, 2, 3];
foreach ($items as &$item) {
    $item *= 2;
}
// ВАЖНО: unset($item) после цикла!
// Без unset: $item — ссылка на последний элемент
unset($item);

$items[] = 4;
var_dump($items); // [2, 4, 6, 4]

// Без unset($item) выше, следующий foreach перезапишет последний элемент:
foreach ($items as $item) {
    // $item всё ещё ссылка на $items[2]!
}
```

**Объекты — уже «по handle»**
```php
function changeName(User $user): void {
    $user->name = 'Bob'; // изменяет оригинал, & не нужен
}

function replaceUser(User &$user): void {
    $user = new User('New'); // заменяет саму переменную
}
```

## Доп. теория
- В PHP ссылки — это **алиасы** переменных, а не «указатели» на память в стиле C.
- По ссылке можно передавать только переменные: `foo(1)` или `foo($a + 1)` нельзя, а `foo($a)` можно.
- Возможен возврат по ссылке `function &getRef()` — это редко нужно и легко приводит к неявным побочным эффектам.
