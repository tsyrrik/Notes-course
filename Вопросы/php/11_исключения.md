## Вопрос: Исключения в PHP
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
`try/catch/finally` для обработки ошибок; всё, что выбрасывается, реализует `Throwable` (как `Exception`, так и `Error`).

## Ответ

### Иерархия Throwable

Начиная с PHP 7.0 все исключения реализуют интерфейс `Throwable`:

```
Throwable (interface)
├── Error (внутренние ошибки движка)
│   ├── TypeError
│   ├── ValueError (PHP 8.0+)
│   ├── ArithmeticError
│   │   └── DivisionByZeroError
│   ├── ParseError
│   └── UnhandledMatchError (PHP 8.0+)
└── Exception (ошибки приложений/библиотек)
    ├── LogicException (ошибки в логике программы)
    │   ├── InvalidArgumentException
    │   ├── BadMethodCallException
    │   ├── DomainException
    │   ├── LengthException
    │   └── OutOfRangeException
    └── RuntimeException (ошибки во время выполнения)
        ├── OutOfBoundsException
        ├── OverflowException
        ├── UnderflowException
        └── UnexpectedValueException
```

### Ключевые правила

1. **`Error`** — ошибки движка (TypeError, ParseError). Обычно не ловятся в бизнес-логике.
2. **`Exception`** — ошибки приложений. `LogicException` — баги в коде (должны быть исправлены), `RuntimeException` — проблемы среды (сеть, файлы).
3. **`finally`** выполняется **всегда** — даже после `return` в try/catch. Используется для очистки ресурсов.
4. **Multi-catch** (PHP 7.1+): `catch (TypeA | TypeB $e)`.
5. **Non-capturing catch** (PHP 8.0+): `catch (NotFoundException)` — без переменной.

### Создание собственных исключений

```php
// Доменное исключение с контекстом
class InsufficientFundsException extends \DomainException
{
    public function __construct(
        public readonly float $balance,
        public readonly float $amount,
    ) {
        parent::__construct(
            "Cannot withdraw {$amount}: balance is {$balance}"
        );
    }
}

// Использование
function withdraw(Account $acc, float $amount): void {
    if ($acc->balance < $amount) {
        throw new InsufficientFundsException($acc->balance, $amount);
    }
    $acc->balance -= $amount;
}
```

## Примеры

**try/catch/finally**
```php
try {
    $data = fetchFromApi('/users');
} catch (HttpTimeoutException $e) {
    $data = getFromCache('/users'); // fallback
} catch (HttpException $e) {
    logger()->error('API error', ['code' => $e->getCode()]);
    throw $e; // проброс наверх
} finally {
    metrics()->increment('api.calls'); // всегда выполняется
}
```

**Non-capturing catch (PHP 8.0+)**
```php
try {
    $config = json_decode($raw, true, 512, JSON_THROW_ON_ERROR);
} catch (\JsonException) {
    $config = []; // значение по умолчанию, сама ошибка не нужна
}
```

### Рекомендации для собеседования

- Бросай осмысленные исключения с контекстом (Message + код/данные), не используй исключения для нормального управления потоком.
- Не оставляй пустые catch — логируй или преобразуй в понятный ответ.
- Разделяй доменные / HTTP / транспортные исключения на разные классы.
- Ловите `Throwable` только на самом верхнем уровне (middleware, error handler), не в бизнес-логике.

## Доп. теория
- `Error` и его наследники тоже можно ловить, но обычно это делают только в глобальном обработчике.
- Исключения — это объекты: можно добавлять контекст через свойства или предыдущую причину (`$previous`).
