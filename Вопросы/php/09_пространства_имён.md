## Вопрос: Пространства имён
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
неймспейсы группируют код и убирают конфликты имён; по PSR-4 путь к файлу соответствует пространству имён.

## Ответ

Пространства имён (namespaces) появились в PHP 5.3 и решают проблему конфликтов имён классов, интерфейсов, функций и констант.

### Базовый синтаксис

```php
namespace App\Controllers;

class UserController {} // полное имя: App\Controllers\UserController
```

### Виды обращений к именам

| Вид | Пример | Описание |
| --- | --- | --- |
| Неквалифицированное | `UserController` | Ищется в текущем namespace |
| Квалифицированное | `Controllers\UserController` | Относительно текущего namespace |
| Полностью квалифицированное | `\App\Controllers\UserController` | Абсолютный путь от корня |

### Импорт (use)

```php
use App\Controllers\UserController;           // класс
use App\Controllers\UserController as UC;      // алиас
use function App\Helpers\formatDate;           // функция
use const App\Config\VERSION;                  // константа

// Группировка (PHP 7.0+)
use App\Models\{User, Post, Comment};
```

### PSR-4 автозагрузка

PSR-4 задаёт соответствие namespace → каталог. В `composer.json`:
```json
{
  "autoload": {
    "psr-4": {
      "App\\": "src/"
    }
  }
}
```
Класс `App\Controllers\UserController` → файл `src/Controllers/UserController.php`.

### Важные нюансы

1. **Глобальные функции/классы** — если PHP не находит функцию/константу в текущем namespace, он ищет в глобальном. Для классов fallback **не работает** — нужно писать `\Exception` или `use Exception`.
2. **Один namespace на файл** — технически можно объявить несколько, но PSR-4 и все фреймворки используют один namespace на файл.
3. **Разделитель** — `\` (обратный слэш). В строках нужно экранировать: `"App\\Models\\User"`.
4. **namespace должен быть первой инструкцией** в файле (после `declare(strict_types=1)` и `<?php`).

## Примеры

```php
// src/Services/PaymentService.php
namespace App\Services;

use App\Models\User;
use App\Exceptions\PaymentException;
use Psr\Log\LoggerInterface;

class PaymentService
{
    public function __construct(
        private LoggerInterface $logger,
    ) {}

    public function charge(User $user, float $amount): void
    {
        if ($amount <= 0) {
            throw new PaymentException('Invalid amount');
        }
        // \DateTimeImmutable — обращение к глобальному классу
        $now = new \DateTimeImmutable();
        $this->logger->info("Charged {$amount} at {$now->format('c')}");
    }
}
```

## Доп. теория
- PHP сначала ищет функцию/константу в текущем namespace и только потом в глобальном; для классов такого fallback нет.
- `use` работает только на уровне файла и не распространяется на другие файлы.
