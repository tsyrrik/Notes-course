## Вопрос: Генераторы и файберы
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
- Генераторы (`yield`) — ленивые итераторы: возвращают значения по одному, не держат всю коллекцию в памяти. Не сохраняют стек вызовов, только позицию итерации.

## Ответ

### Генераторы (PHP 5.5+)

Генератор — это функция, которая использует `yield` вместо `return`. При вызове возвращает объект `Generator` (реализует `Iterator`), но **не выполняет тело функции** — выполнение начинается при первом обращении к элементу.

**Преимущества:**
- Ленивая генерация — значения создаются по одному, не занимая всю память
- Бесконечные последовательности
- Чтение больших файлов построчно

**Ключевые возможности:**
- `yield $value` — отдать значение и приостановить
- `yield $key => $value` — отдать пару ключ-значение
- `yield from $iterable` — делегация другому генератору/массиву (PHP 7.0+)
- `$received = yield $value` — двусторонний обмен через `send()`
- `return $value` — финальное значение, доступно через `getReturn()`

```php
// Чтение огромного файла без загрузки в память
function readLines(string $file): Generator {
    $fh = fopen($file, 'r');
    try {
        while (($line = fgets($fh)) !== false) {
            yield trim($line);
        }
    } finally {
        fclose($fh);
    }
}

foreach (readLines('/var/log/app.log') as $line) {
    if (str_contains($line, 'ERROR')) {
        echo $line . PHP_EOL;
    }
}

// Делегация генераторов
function numbers(): Generator {
    yield 1;
    yield from [2, 3];        // массив
    yield from innerGen();     // другой генератор
}
```

### Файберы (PHP 8.1+)

Файбер (Fiber) — это полноценная **сопрограмма** (coroutine). В отличие от генератора, файбер может приостановить выполнение **из любой точки стека вызовов**, а не только из самой функции-генератора.

**Ключевые отличия от генераторов:**
- Сохраняет весь стек вызовов при приостановке
- Может приостанавливаться из вложенных функций
- Предназначен для асинхронного I/O и кооперативной многозадачности

```php
$fiber = new Fiber(function (): void {
    $val = Fiber::suspend('step1'); // приостановка, отдаём 'step1'
    echo "Resumed with $val";       // выполнится после resume
});

$first = $fiber->start();      // 'step1'
$fiber->resume('step2');       // продолжает, напечатает "Resumed with step2"
```

### Практическое применение файберов

Файберы напрямую редко используются в прикладном коде. Они — фундамент для **асинхронных фреймворков** (ReactPHP, Amp, Revolt):

```php
// Revolt event loop использует файберы под капотом
// Вместо callback-hell:
$response = async(fn() => httpGet('https://api.example.com/data'));
$result = $response->await(); // приостанавливает файбер до получения ответа
```

### Сравнительная таблица

| Свойство | Генератор | Файбер |
| --- | --- | --- |
| Версия PHP | 5.5+ | 8.1+ |
| Приостановка | Только из `yield` | Из любой точки стека |
| Сохранение стека | Нет | Да |
| Основное применение | Ленивые итераторы | Асинхронный I/O |
| Интерфейс | `Iterator` | `Fiber` |
| Двусторонний обмен | `yield`/`send()` | `suspend()`/`resume()` |

## Примеры
```php
function gen(): Generator {
    $name = yield 'Who are you?';
    yield "Hello, $name";
}

$g = gen();
echo $g->current();      // Who are you?
$g->send('Alice');
echo $g->current();      // Hello, Alice
```

```php
$fiber = new Fiber(function (): void {
    $step = Fiber::suspend('step1');
    echo "Resumed with $step";
});

echo $fiber->start();  // step1
$fiber->resume('step2'); // Resumed with step2
```

## Доп. теория
- Генераторы — это итераторы; они не предназначены для асинхронности и не сохраняют стек вызовов.
- Файберы — низкоуровневый примитив для кооперативной многозадачности; обычно используются через event-loop библиотеки.
