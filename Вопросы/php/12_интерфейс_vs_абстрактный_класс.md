## Вопрос: Интерфейс vs абстрактный класс
Версия: PHP 8.4; где есть исторические детали — см. по тексту.

## Простой ответ
- Интерфейс — только контракт (без состояния и реализации); абстрактный класс даёт общий код и состояние. Интерфейсы можно реализовывать множественно.

## Ответ

### Сравнительная таблица

| Свойство | Интерфейс | Абстрактный класс |
| --- | --- | --- |
| Множественная реализация | Да (`implements A, B, C`) | Нет (один `extends`) |
| Свойства | Нет | Да, любые |
| Конструктор | Нет | Да |
| Реализация методов | Нет | Да, обычные + abstract |
| Модификаторы доступа | Только `public` | Любые |
| Константы | Да (с PHP 8.1 — `final`) | Да |
| `final` методы | Нет | Да |
| Type-hint в аргументах | Да | Да |

### Когда что выбирать

**Интерфейс** — когда нужен **контракт** (что объект умеет делать):
- Определяет «способность»: `Cacheable`, `Renderable`, `Loggable`
- Позволяет разным иерархиям реализовать один контракт
- Лучше для Dependency Inversion (SOLID «D»)
- Один класс может реализовать несколько интерфейсов

**Абстрактный класс** — когда нужна **общая реализация** (базовый код + шаблон):
- Определяет «семейство»: `BaseRepository`, `AbstractCommand`
- Содержит общие поля, конструктор, утилитные методы
- Паттерн Template Method — абстрактные методы как точки расширения
- Используется когда наследники разделяют состояние и поведение

### Практическое правило

> Зависьте от интерфейсов, наследуйте от абстрактных классов. Если сомневаетесь — начинайте с интерфейса.

## Примеры

```php
// Интерфейс — контракт
interface Logger {
    public function log(string $level, string $msg): void;
}

// Абстрактный класс — общая реализация
abstract class BaseService {
    public function __construct(
        protected Logger $logger,
    ) {}

    public function now(): string { return date(DATE_ATOM); }

    // Template Method: наследник реализует
    abstract protected function handle(): void;

    public function execute(): void {
        $this->logger->log('info', 'Starting ' . static::class);
        $this->handle();
        $this->logger->log('info', 'Done');
    }
}

// Конкретный класс — наследует абстрактный + реализует интерфейс
class OrderService extends BaseService implements \Stringable {
    protected function handle(): void {
        // бизнес-логика заказа
    }

    public function __toString(): string {
        return 'OrderService';
    }
}
```

## Доп. теория
- Интерфейс — это контракт: все методы в нём **только public**.
- Если нужна «реализация по умолчанию», используйте абстрактный класс или трейт.
