## Вопрос: Микросервисы: плюсы/минусы, выбор, сценарии

## Простой ответ
- Монолит — один большой сервис и БД: просто стартовать, но релизы и масштаб — целиком.
- Микросервисы — много маленьких с отдельными БД: гибкие релизы и масштаб, но растёт сложность сети/инфры.
- Дробить оправдано, если есть разные темпы релизов, нагрузки и чёткие границы домена.
- Монолит (+): проще деплой/отладка/транзакции, единый код/БД, меньше DevOps‑нагрузки.
- Монолит (−): релизы «по всему», масштабирование только целиком, узкое горлышко команды и CI.
- Микросервисы (+): независимые релизы и масштабирование, изоляция отказов, технологическая гибкость, ownership по доменам.
- Микросервисы (−): сеть/latency, распределённые транзакции, рост инфраструктуры (оркестрация, observability, сервис‑мэш), дублирование данных/логики.

## Ответ

### Что такое микросервисная архитектура

Микросервисная архитектура -- это подход к проектированию системы, при котором приложение разбивается на набор небольших, автономных сервисов, каждый из которых реализует одну бизнес-возможность (business capability), имеет собственную базу данных и деплоится независимо. Термин популяризировали Мартин Фаулер и Джеймс Льюис в 2014 году. Микросервисы противопоставляются монолитной архитектуре, где всё приложение -- единый деплоимент с общей базой данных.

Важно понимать, что микросервисы -- это не цель, а инструмент. Они решают организационные и масштабные проблемы, но вносят значительную операционную сложность. Решение о переходе должно быть обоснованным, а не модным.

### Монолит vs микросервисы: сравнение

```text
┌─────────────────────────────────────────────────────────────────────┐
│                         МОНОЛИТ                                    │
│                                                                     │
│  ┌──────────┬──────────┬──────────┬──────────┐                     │
│  │  Auth    │ Catalog  │ Billing  │  Notify  │  ← модули           │
│  └──────────┴──────────┴──────────┴──────────┘                     │
│  ┌──────────────────────────────────────────┐                      │
│  │          Общая база данных               │                      │
│  └──────────────────────────────────────────┘                      │
│  Один деплоймент, одна БД, одна команда                            │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                      МИКРОСЕРВИСЫ                                   │
│                                                                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐           │
│  │  Auth    │  │ Catalog  │  │ Billing  │  │  Notify  │           │
│  │  Service │  │  Service │  │  Service │  │  Service │           │
│  ├──────────┤  ├──────────┤  ├──────────┤  ├──────────┤           │
│  │  DB auth │  │ DB catalog│ │ DB billing│ │ DB notify│           │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘           │
│       ▲              ▲             ▲             ▲                  │
│       └──────────────┴─────────────┴─────────────┘                  │
│                    API Gateway / Message Bus                         │
└─────────────────────────────────────────────────────────────────────┘
```

| Критерий | Монолит | Микросервисы |
| --- | --- | --- |
| Деплой | Один артефакт, всё вместе | Каждый сервис отдельно |
| Масштабирование | Только целиком | Каждый сервис отдельно |
| Транзакции | ACID в одной БД | Distributed: Saga, Outbox |
| Отладка | Stack trace, один процесс | Distributed tracing (Jaeger, Zipkin) |
| Команды | Одна команда, общий код | Отдельные команды, ownership |
| Технологии | Один стек | Polyglot (разные языки/БД) |
| Задержка | Вызовы в памяти (наносекунды) | Сетевые вызовы (миллисекунды) |
| Сложность инфры | Низкая | Высокая (K8s, Service Mesh, CI/CD) |

## Когда оставить монолит
- Ранний продукт, быстрый цикл фич, маленькая команда (< 8-10 человек).
- Сильно связанный домен: бизнес-операции требуют "жёстких" транзакций и общей схемы.
- Нет зрелого CI/CD/мониторинга/алертинга -- микросервисы только усилят хаос.
- **Modular Monolith** -- хороший компромисс: монолит с чёткими модулями, которые при необходимости можно вынести в отдельные сервисы.

## Когда делить на микросервисы
- Разные темпы релизов/жизненные циклы: биллинг vs уведомления vs каталоги.
- Разные нелинейные нагрузки: поиск/каталог (горячие чтения) vs оплата (строгие записи).
- Чёткие bounded contexts и отдельные команды/SLAs; требование технологической изоляции.
- Гео/регуляторика: данные/функции должны жить отдельно.
- Организационный масштаб: более 3-4 команд, работающих параллельно -- merge-конфликты и зависимости в монолите становятся блокером.

## Как пилить монолит (Strangler Fig Pattern)

Паттерн Strangler Fig (по аналогии с фикусом-душителем) предполагает постепенное "удушение" монолита -- новая функциональность пишется в микросервисе, а старый код постепенно отключается.

```text
Этап 1: Монолит обслуживает всё
┌──────────────────────────┐
│        Монолит           │
│  [Auth] [Catalog] [Pay]  │
└──────────────────────────┘

Этап 2: Выносим Catalog за прокси
┌────────────┐    ┌──────────────┐
│  Монолит   │    │ Catalog Svc  │
│ [Auth][Pay]│    │  (новая БД)  │
└────────────┘    └──────────────┘
       ▲                 ▲
       └────┬────────────┘
       API Gateway / Feature Flag

Этап 3: Монолит уменьшается
┌──────┐  ┌───────────┐  ┌──────────┐
│ Auth │  │ Catalog   │  │ Payment  │
│ Svc  │  │ Svc       │  │ Svc      │
└──────┘  └───────────┘  └──────────┘
```

Шаги:
1. Выбрать кандидат-функцию с понятными границами и потребностью в независимом масштабе/релизах.
2. Описать контракт: API/gRPC для команд + события для реакций; спроектировать модель данных.
3. Выделить собственную БД; добавить Anti-Corruption Layer (ACL) в монолите; feature flag.
4. Перенаправить маршрутизацию на новый сервис, очистить код в монолите.
5. Мониторить метрики нового сервиса, убедиться в стабильности, удалить старый код.

## Коммуникации между сервисами

### Синхронная коммуникация (запрос-ответ)
- **REST/HTTP** -- простой, понятный, но связывает сервисы во времени (один ждёт ответа другого).
- **gRPC** -- бинарный протокол на базе HTTP/2 + Protobuf, более быстрый, со строгой схемой контрактов, поддержкой стриминга.
- Риск: каскадные отказы -- если один сервис упал, вся цепочка встаёт. Решение: Circuit Breaker (Hystrix, Resilience4j).

### Асинхронная коммуникация (события)
- **Message Broker** (RabbitMQ, Kafka, NATS) -- сервис публикует событие, потребители обрабатывают когда могут.
- Разделяет сервисы во времени: публикатор не ждёт обработки.
- **Event-Driven Architecture** позволяет строить реактивные системы с eventual consistency.

```text
┌──────────────┐   event: order.placed   ┌─────────────────┐
│ Order Service│ ──────────────────────► │  Message Broker  │
└──────────────┘                         │  (Kafka/RabbitMQ)│
                                         └───────┬─────────┘
                              ┌──────────────────┼───────────────────┐
                              ▼                  ▼                   ▼
                     ┌──────────────┐   ┌──────────────┐   ┌──────────────┐
                     │ Billing Svc  │   │ Notify Svc   │   │ Analytics Svc│
                     │ (списать $)  │   │ (отправить   │   │ (записать    │
                     │              │   │  email)       │   │  метрику)    │
                     └──────────────┘   └──────────────┘   └──────────────┘
```

## Согласованность данных

В микросервисах нет единой БД, значит нет ACID-транзакций между сервисами. Используются:

### Saga Pattern
Цепочка локальных транзакций с компенсирующими действиями при ошибке.

```text
1. Order Service: создать заказ (status=pending)
2. Payment Service: списать деньги
   └─ ошибка? → компенсация: Order Service отменяет заказ
3. Inventory Service: зарезервировать товар
   └─ ошибка? → компенсация: Payment Service вернуть деньги,
                              Order Service отменить заказ
4. Order Service: подтвердить заказ (status=confirmed)
```

Два подхода к Saga:
- **Choreography** -- сервисы слушают события друг друга (проще, но сложнее отслеживать поток).
- **Orchestration** -- центральный оркестратор (Saga Manager) управляет шагами (прозрачнее, но единая точка отказа).

### Transactional Outbox
Гарантирует, что событие будет отправлено при изменении данных. Запись в таблицу `outbox` происходит в одной транзакции с бизнес-данными, а отдельный процесс (relay) публикует события из outbox в брокер.

```sql
BEGIN TRANSACTION;
  INSERT INTO orders (id, status) VALUES ('abc', 'confirmed');
  INSERT INTO outbox (event_type, payload) VALUES ('order.confirmed', '{"id":"abc"}');
COMMIT;
-- Relay-процесс читает outbox и публикует в Kafka/RabbitMQ
```

## Инфраструктурные паттерны

| Паттерн | Назначение |
| --- | --- |
| **API Gateway** | Единая точка входа, маршрутизация, аутентификация, rate limiting. |
| **Service Discovery** | Динамическое обнаружение адресов сервисов (Consul, Eureka, K8s DNS). |
| **Circuit Breaker** | Защита от каскадных отказов: если сервис не отвечает -- "размыкаем цепь". |
| **Sidecar / Service Mesh** | Прозрачная сетевая инфраструктура (Istio, Linkerd): mTLS, retry, observability. |
| **Distributed Tracing** | Сквозная трассировка запросов через все сервисы (Jaeger, Zipkin, OpenTelemetry). |
| **Centralized Logging** | Агрегация логов всех сервисов (ELK Stack, Loki + Grafana). |

## Пример взаимодействия сервисов

```text
User Service (DB users)
  POST /users {email, name}
  emits event user.created

Notifications Service (DB notifications)
  consumes user.created -> send welcome email

Billing Service (DB billing)
  consumes user.created -> create billing account with trial period
```

```php
// Пример: Order Service (Application Layer)
final class PlaceOrderHandler {
    public function __construct(
        private OrderRepository $orders,
        private MessageBus      $bus
    ) {}

    public function __invoke(PlaceOrderCommand $cmd): string {
        $order = Order::create(
            id:         $this->orders->nextId(),
            customerId: $cmd->customerId,
            items:      $cmd->items
        );

        $this->orders->save($order);

        // Публикуем событие для других сервисов
        $this->bus->publish(new OrderPlaced(
            orderId:    $order->id(),
            customerId: $cmd->customerId,
            total:      $order->total()->amount
        ));

        return $order->id();
    }
}
```

## Примеры
```text
Пример границ: Billing, Catalog, Notifications — отдельные сервисы с разными SLA.
```

## Доп. теория
- Микросервисы требуют зрелого DevOps/observability, иначе сложность съедает выгоду.
- Чаще всего разумно начинать с modular monolith и выделять сервисы постепенно.
