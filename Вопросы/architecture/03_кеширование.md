## Вопрос: Кеширование

## Простой ответ
- Храним часто нужный результат рядом, чтобы читать быстрее, чем из «медленного» источника.
- Должен сам очищаться (TTL/инвалидация), иначе получим мусор и баги.

## Ответ
## Быстрое напоминание
- Технологии: Redis, Memcached.
- Стратегии: read-through, write-through, write-behind.
- Политики вытеснения: LRU/LFU.

## Плюсы
- Быстрые ответы, разгрузка БД/сервисов.
- Можно пережить краткие пики нагрузки.

## Минусы/риски
- Устаревшие данные, рассинхрон с источником.
- Сложно правильно инвалидировать; прогрев/холодный старт.
- Дополнительная инфраструктура, кэш шторм/догон.

## Когда использовать
- Есть тяжёлые одинаковые запросы/вычисления.
- Есть допустимая eventual consistency или TTL.
- Нужно дешёвое масштабирование чтения.

## Когда не стоит
- Требуются строгие транзакции/всегда свежие данные.
- Нет операционного контроля: мониторинг/лимиты/алерты.

## Примеры
```text
Cache-aside: приложение сначала читает кэш, при промахе — БД, затем кладёт в кэш.
```

## Доп. теория
- Главное в кэшировании — корректная инвалидация и измерение cache‑hit ratio.
- Для критичных данных используйте короткий TTL и fallback на источник.
