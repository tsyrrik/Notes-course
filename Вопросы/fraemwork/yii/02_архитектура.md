## Вопрос: Архитектура Yii2
Версия: Yii2 2.0.54; Yii3 релизнут (2025‑12‑31).

## Простой ответ
Приложение — это набор компонентов, настроенных в конфиге. Запрос проходит через Front Controller, роутер, контроллер и возвращает ответ.

## Ответ

### Как устроено приложение Yii2?

Приложение Yii2 представляет собой объект класса `yii\web\Application` (или `yii\console\Application`), который создается в точке входа (`web/index.php`). Этот объект является одновременно **Service Locator** — он хранит все зарегистрированные компоненты и предоставляет к ним доступ через `Yii::$app`. Конфигурация приложения задается в виде PHP-массива, который передается в конструктор. При создании приложение проходит фазы: preInit (базовая настройка), init (инициализация), bootstrap (загрузка модулей/компонентов), после чего готово обрабатывать запросы.

### Жизненный цикл запроса

Каждый HTTP-запрос в Yii2 проходит строго определенный путь. Сначала `web/index.php` (Front Controller) создает экземпляр приложения и вызывает `run()`. Приложение разрешает маршрут через `UrlManager`, определяет контроллер и action, применяет фильтры (`behaviors`), выполняет action и формирует ответ. Контроллер может вернуть строку (HTML), массив (JSON) или объект `Response`. Этот цикл можно представить так:

```
Request → Application::run()
       → UrlManager::parseRequest()    // определяет route
       → Controller::runAction()       // создает контроллер
       → behaviors/filters             // AccessControl, VerbFilter...
       → beforeAction()                // хук до выполнения
       → actionXxx()                   // выполнение action
       → afterAction()                 // хук после выполнения
       → Response::send()              // отправка ответа клиенту
```

### MVC в Yii2

Yii2 следует паттерну MVC, но с расширениями. **Model** — это не только ORM-модель (`ActiveRecord`), но и любой класс, наследующий `yii\base\Model`, который предоставляет валидацию, массовое присваивание атрибутов и сценарии. **View** — PHP-шаблоны с возможностью использования layouts, виджетов, ассетов и фрагментного кэширования. **Controller** — обработчик запроса, содержащий actions и фильтры. Кроме того, Yii2 активно использует компоненты (components) и модули (modules) для организации бизнес-логики.

```php
// Model — бизнес-логика и данные
class Post extends \yii\db\ActiveRecord
{
    public function rules() { /* ... */ }
    public function getAuthor()
    {
        return $this->hasOne(User::class, ['id' => 'author_id']);
    }
}

// Controller — обработка запроса
class PostController extends \yii\web\Controller
{
    public function actionView($id)
    {
        $model = Post::findOne($id);
        if ($model === null) {
            throw new \yii\web\NotFoundHttpException('Страница не найдена');
        }
        return $this->render('view', ['model' => $model]);
    }
}

// View (views/post/view.php) — отображение
<?= $model->title ?>
<?= $model->author->name ?>
```

### Структура каталогов

Yii2 предлагает два официальных шаблона. **Basic** подходит для небольших проектов — все в одной директории. **Advanced** разделяет приложение на frontend, backend и console с общим кодом в common. Типичная структура basic-шаблона:

```
project/
├── assets/            # AssetBundle классы
├── commands/          # Консольные контроллеры
├── config/            # Конфигурационные файлы
│   ├── web.php        # Конфиг веб-приложения
│   ├── console.php    # Конфиг консольного приложения
│   ├── db.php         # Настройки БД
│   └── params.php     # Параметры
├── controllers/       # Веб-контроллеры
├── models/            # Модели
├── modules/           # Модули (подсистемы)
├── runtime/           # Логи, кэш, временные файлы
├── views/             # Шаблоны
│   ├── layouts/       # Layouts
│   └── site/          # Views для SiteController
├── web/               # Публичная директория
│   └── index.php      # Точка входа
├── widgets/           # Виджеты
└── vendor/            # Зависимости Composer
```

### Модули (Modules)

Модули — это мини-приложения внутри основного приложения. Каждый модуль имеет собственные контроллеры, модели, views и конфигурацию. Модули удобны для изоляции крупных подсистем: например, модуль `admin`, модуль `api`, модуль `blog`. Модуль регистрируется в конфигурации и доступен по URL-префиксу.

```php
// config/web.php
'modules' => [
    'admin' => [
        'class' => 'app\modules\admin\Module',
    ],
    'api' => [
        'class' => 'app\modules\api\Module',
    ],
],

// Модуль app/modules/admin/Module.php
namespace app\modules\admin;

class Module extends \yii\base\Module
{
    public function init()
    {
        parent::init();
        // настройка модуля
        $this->defaultRoute = 'dashboard';
    }
}

// URL: /admin/dashboard/index -> AdminModule → DashboardController → actionIndex
```

### Компоненты и их lazy loading

Все сервисы в Yii2 — это компоненты приложения. Они регистрируются в конфигурации и создаются **лениво** — экземпляр объекта появляется только при первом обращении через `Yii::$app->componentName`. Это критично для производительности: если в конфиге зарегистрировано 30 компонентов, но в текущем запросе используется только 5, остальные 25 не будут созданы. Компоненты наследуют `yii\base\Component`, который добавляет поддержку свойств (properties), событий (events) и поведений (behaviors).

```php
// Регистрация компонента
'components' => [
    'pdf' => [
        'class' => 'app\components\PdfGenerator',
        'format' => 'A4',
        'orientation' => 'portrait',
    ],
],

// Использование — объект создастся только здесь
$pdf = Yii::$app->pdf;
$pdf->generate($html);
```

### Практические советы

Для масштабных проектов рекомендуется использовать advanced-шаблон с модулями для разделения доменных областей. Бизнес-логику лучше выносить в отдельные сервисные классы (components), а не хранить в контроллерах или моделях — это упрощает тестирование и поддержку. Используйте интерфейсы и DI-контейнер для слабого связывания компонентов. При работе с событиями (events) помните, что они позволяют расширять логику модулей без модификации их кода — это основа принципа Open/Closed.

## Примеры

1. Поток запроса: `/post/view?id=10` → `UrlManager` → `PostController::actionView()` → `render('view')`.
2. Модуль `admin`: URL `/admin/user/index` вызывает `app\modules\admin\controllers\UserController`.
3. Lazy loading: компонент `mailer` не создаётся, пока не вызван `Yii::$app->mailer`.

## Доп. теория

1. Service Locator упрощает доступ к компонентам, но усиливает связанность.
2. Модули помогают разделять домены, но усложняют общие зависимости и конфиг.
