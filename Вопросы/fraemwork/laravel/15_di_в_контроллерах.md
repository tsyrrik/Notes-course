## Вопрос: Dependency Injection в контроллерах
Версия: Laravel 12.x (актуальная), 11.x в security-fixes; PHP 8.2–8.4.

## Простой ответ
DI — зависимости приходят в контроллер автоматически из контейнера.

## Ответ

Dependency Injection (DI) — это паттерн проектирования, при котором зависимости объекта передаются извне (через конструктор или параметры метода), а не создаются внутри. В Laravel DI работает автоматически благодаря Service Container: вы указываете type-hint в сигнатуре, и Laravel сам создаёт и внедряет нужный объект.

**DI в контроллерах работает в двух местах:**

**1. Constructor Injection (внедрение через конструктор)** — зависимости доступны во всех методах контроллера:

```php
class UserController extends Controller
{
    // Laravel автоматически создаст экземпляры этих классов
    public function __construct(
        private UserService $userService,
        private NotificationService $notificationService,
    ) {}

    public function index()
    {
        $users = $this->userService->getActiveUsers();
        return view('users.index', compact('users'));
    }

    public function store(UserRequest $request)
    {
        $user = $this->userService->create($request->validated());
        $this->notificationService->welcomeEmail($user);
        return redirect()->route('users.show', $user);
    }
}
```

**2. Method Injection (внедрение через параметры метода)** — зависимости нужны только в одном конкретном методе:

```php
class OrderController extends Controller
{
    public function store(
        StoreOrderRequest $request,       // Form Request — валидация + авторизация
        OrderService $orderService,        // Сервис бизнес-логики
        PaymentGateway $paymentGateway,    // Внешняя зависимость
    ) {
        $order = $orderService->create($request->validated());
        $paymentGateway->charge($order);
        return redirect()->route('orders.show', $order);
    }

    // Route Model Binding + Request — комбинация DI
    public function show(User $user, Request $request)
    {
        return view('users.show', compact('user'));
    }

    // DI с интерфейсом (нужен binding в Service Provider)
    public function export(UserRepositoryInterface $repository)
    {
        $users = $repository->getAllForExport();
        return Excel::download(new UsersExport($users), 'users.xlsx');
    }
}
```

**Привязка интерфейса к реализации** — чтобы DI работал с интерфейсами, нужно зарегистрировать binding:

```php
// app/Providers/AppServiceProvider.php
class AppServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        // Каждый раз новый экземпляр
        $this->app->bind(
            UserRepositoryInterface::class,
            EloquentUserRepository::class
        );

        // Один экземпляр на всё время жизни приложения
        $this->app->singleton(
            PaymentGateway::class,
            fn ($app) => new StripePaymentGateway(
                config('services.stripe.secret')
            )
        );

        // Contextual binding — разные реализации для разных потребителей
        $this->app->when(PhotoController::class)
            ->needs(StorageInterface::class)
            ->give(S3Storage::class);

        $this->app->when(AvatarController::class)
            ->needs(StorageInterface::class)
            ->give(LocalStorage::class);
    }
}
```

**DI в Invokable контроллерах:**

```php
class ProcessPaymentController extends Controller
{
    public function __construct(
        private PaymentGateway $gateway,
    ) {}

    public function __invoke(PaymentRequest $request): RedirectResponse
    {
        $result = $this->gateway->process($request->validated());
        return redirect()->route('payments.success');
    }
}
```

**Зачем DI, а не прямое создание объектов?**
- **Тестируемость:** в тестах можно подменить реальный PaymentGateway на mock
- **Слабая связанность:** контроллер зависит от интерфейса, а не от конкретного класса
- **Гибкость:** смена реализации (например, Stripe на PayPal) — одна строка в ServiceProvider
- **Single Responsibility:** контроллер не знает, как создавать свои зависимости

```php
// В тесте можно подменить зависимость
$this->mock(PaymentGateway::class, function ($mock) {
    $mock->shouldReceive('charge')->once()->andReturn(true);
});

$this->post('/orders', $orderData)->assertRedirect();
```

**Практический совет:** используйте constructor injection для зависимостей, нужных в нескольких методах, и method injection для одноразовых. Привязывайте интерфейсы к реализациям — это основа тестируемого кода. В Laravel 11 автоматический DI работает для любых классов, которые можно инстанцировать (имеют конструктор без обязательных примитивных параметров или все зависимости резолвятся контейнером). PHP 8.1+ constructor promotion (`private UserService $userService`) делает код лаконичнее.

## Примеры

1. Внедрение сервиса через конструктор.
2. Метод‑инъекция: `public function store(Request $r, Mailer $m)`.
3. Контроллер получает `FormRequest` с валидацией.

## Доп. теория

1. Container резолвит зависимости по типам.
2. Избегайте `app()` внутри методов без необходимости.
