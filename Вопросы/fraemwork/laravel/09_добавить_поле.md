## Вопрос: Добавить новое поле в таблицу
Версия: Laravel 12.x (актуальная), 11.x в security-fixes; PHP 8.2–8.4.

## Простой ответ
Добавление поля — отдельная миграция, которую можно откатить; она вносит изменение в схему под контролем версий.

## Ответ

Добавление нового поля в существующую таблицу — это одна из самых частых операций с миграциями. Важно никогда не редактировать уже выполненную миграцию создания таблицы, а создавать новую миграцию для каждого изменения. Это гарантирует корректную работу в команде и на production-серверах.

**Конвенция именования:** Laravel автоматически определяет таблицу, если имя миграции следует паттерну `add_{column}_to_{table}_table`. Флаг `--table` явно указывает, что это изменение существующей таблицы (а не создание новой).

```bash
# Создание миграции для добавления поля
php artisan make:migration add_phone_to_users_table --table=users
```

```php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->string('phone', 20)->nullable()->after('email');
            $table->index('phone');
        });
    }

    public function down(): void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropIndex(['phone']);
            $table->dropColumn('phone');
        });
    }
};
```

**Различные сценарии изменения таблицы:**

```php
// Добавление нескольких полей
public function up(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->string('phone', 20)->nullable()->after('email');
        $table->date('birth_date')->nullable()->after('phone');
        $table->json('settings')->nullable();
        $table->foreignId('department_id')->nullable()->constrained()->nullOnDelete();
    });
}

// Изменение существующего поля (требует doctrine/dbal для Laravel < 11)
// В Laravel 11 doctrine/dbal больше не нужен для нативных типов
public function up(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->string('name', 500)->change();             // увеличить длину
        $table->string('email')->nullable()->change();     // сделать nullable
        $table->text('bio')->nullable()->change();         // сменить тип
    });
}

// Переименование поля
public function up(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->renameColumn('phone', 'mobile_phone');
    });
}

// Удаление полей
public function up(): void
{
    Schema::table('users', function (Blueprint $table) {
        $table->dropColumn(['phone', 'fax']);  // удалить несколько полей
    });
}

// Добавление/удаление индексов и ограничений
public function up(): void
{
    Schema::table('orders', function (Blueprint $table) {
        $table->unique(['user_id', 'product_id']);          // составной уникальный
        $table->index(['status', 'created_at']);            // составной индекс
        $table->foreign('user_id')->references('id')->on('users')->cascadeOnDelete();
    });
}
```

**down() — правила отката:**

```php
public function down(): void
{
    Schema::table('users', function (Blueprint $table) {
        // Порядок важен: сначала удаляем индексы/FK, затем колонки
        $table->dropForeign(['department_id']);  // имя: {table}_{column}_foreign
        $table->dropIndex(['phone']);            // имя: {table}_{column}_index
        $table->dropUnique(['email', 'tenant_id']);
        $table->dropColumn(['phone', 'birth_date', 'settings', 'department_id']);
    });
}
```

**Практический совет:** каждая миграция должна быть атомарной — одно логическое изменение. Не добавляйте 10 несвязанных полей в одну миграцию. Всегда делайте новые поля `nullable()` или задавайте `default()`, иначе миграция упадёт на таблице с существующими данными. Используйте `after()` для контроля порядка полей (MySQL). Метод `down()` должен полностью откатывать изменения `up()`. Перед production-деплоем тестируйте миграцию на копии production-данных.

## Примеры

1. `php artisan make:migration add_phone_to_users_table`.
2. `Schema::table('users', fn($t) => $t->string('phone')->nullable())`.
3. Добавить поле в `$fillable` модели.

## Доп. теория

1. Добавляйте `nullable` или `default` для существующих строк.
2. После миграции обновите формы и DTO.
