## Вопрос: Контроллеры
Версия: Symfony 8.0 (stable), LTS 7.4; PHP 8.4+ / 8.2+.

## Простой ответ
методы, которые принимают Request и возвращают Response/JsonResponse/View, обычно как сервисы в контейнере.

## Ответ

### Что такое контроллер в Symfony

Контроллер -- это PHP callable (метод класса, замыкание или invocable-объект), который принимает HTTP-запрос и возвращает HTTP-ответ. Контроллер -- единственное место, где бизнес-логика «склеивается» с HTTP-слоем. В идеале контроллер должен быть тонким: получить данные из запроса, передать их в сервис, сформировать ответ.

### AbstractController

Symfony предоставляет базовый класс `AbstractController`, который даёт доступ к удобным хелперам: `render()`, `json()`, `redirectToRoute()`, `createForm()`, `getUser()`, `addFlash()` и др. Наследование от него необязательно -- контроллер может быть обычным классом-сервисом.

```php
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Routing\Attribute\Route;

class UserController extends AbstractController
{
    #[Route('/users', name: 'users_index', methods: ['GET'])]
    public function index(UserRepository $repo): Response
    {
        $users = $repo->findAll();
        return $this->render('users/index.html.twig', ['users' => $users]);
    }

    #[Route('/users/{id}', name: 'user_show', methods: ['GET'])]
    public function show(User $user): Response
    {
        // User автоматически загружен через EntityValueResolver (ParamConverter)
        return $this->render('users/show.html.twig', ['user' => $user]);
    }

    #[Route('/api/users', name: 'api_users', methods: ['GET'])]
    public function apiIndex(UserRepository $repo): JsonResponse
    {
        return $this->json($repo->findAll(), 200, [], ['groups' => 'user:read']);
    }
}
```

### Контроллер как сервис (без AbstractController)

Контроллер можно написать как обычный класс без наследования. Все зависимости приходят через конструктор (autowiring). Это более чистый подход с точки зрения SOLID:

```php
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Twig\Environment;

class UserController
{
    public function __construct(
        private readonly UserRepository $userRepository,
        private readonly Environment $twig,
    ) {}

    #[Route('/users', name: 'users_index', methods: ['GET'])]
    public function index(): Response
    {
        $users = $this->userRepository->findAll();
        $html = $this->twig->render('users/index.html.twig', ['users' => $users]);
        return new Response($html);
    }
}
```

### Invocable-контроллеры (Single Action Controller)

Для контроллеров с единственным действием можно использовать метод `__invoke()`. Это удобно для соблюдения принципа единственной ответственности:

```php
#[AsController]
#[Route('/dashboard', name: 'dashboard')]
class DashboardController
{
    public function __construct(private readonly StatsService $stats) {}

    public function __invoke(): Response
    {
        return new Response('...');
    }
}
```

### Внедрение зависимостей в аргументы метода

В Symfony 7 зависимости можно инжектить не только через конструктор, но и напрямую в аргументы метода контроллера. Фреймворк использует `ArgumentResolver` для резолвинга аргументов:

```php
#[Route('/users', name: 'users_index')]
public function index(
    UserRepository $repo,          // Autowiring сервиса
    Request $request,              // Текущий Request
    #[CurrentUser] ?User $user,    // Текущий аутентифицированный пользователь
    CacheInterface $cache,         // Любой сервис
): Response {
    $page = $request->query->getInt('page', 1);
    // ...
}
```

### Типы ответов

```php
// HTML ответ через Twig
return $this->render('page.html.twig', ['data' => $data]);

// JSON ответ
return $this->json(['status' => 'ok'], Response::HTTP_OK);

// Редирект
return $this->redirectToRoute('users_index');
return $this->redirect('https://example.com');

// Файл для скачивания
return $this->file('/path/to/file.pdf', 'report.pdf');

// Stream response
return new StreamedResponse(function () { /* ... */ });

// Пустой ответ (204 No Content)
return new Response('', Response::HTTP_NO_CONTENT);
```

### Flash-сообщения

```php
#[Route('/users/{id}/delete', name: 'user_delete', methods: ['POST'])]
public function delete(User $user, EntityManagerInterface $em): Response
{
    $em->remove($user);
    $em->flush();

    $this->addFlash('success', 'Пользователь удалён.');
    return $this->redirectToRoute('users_index');
}
```

### Практические советы

- Контроллер должен быть «тонким» -- вся бизнес-логика в сервисах, контроллер лишь координирует
- Используйте `#[AsController]` атрибут для автоконфигурации контроллера как сервиса
- Избегайте прямого доступа к `$_GET`, `$_POST` -- используйте объект `Request`
- Для API-контроллеров используйте `#[MapRequestPayload]` (Symfony 6.3+/7) для автоматического маппинга тела запроса в DTO
- Всегда указывайте return type `: Response` или `: JsonResponse` для ясности

## Примеры

1. `return $this->render('users/index.html.twig', ['users' => $users]);`.
2. JSON‑ответ: `return $this->json(['ok' => true]);`.
3. Инжект `Request` и `UserRepository` в аргументы метода.

## Доп. теория

1. Контроллеры — сервисы контейнера, могут быть invocable.
2. Бизнес‑логику лучше выносить в отдельные сервисы.
