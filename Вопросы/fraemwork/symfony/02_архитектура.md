## Вопрос: Архитектура Symfony
Версия: Symfony 8.0 (stable), LTS 7.4; PHP 8.4+ / 8.2+.

## Простой ответ
ядро HttpKernel получает запрос, прогоняет через событийнyю систему (middleware), роутит, вызывает контроллер, возвращает Response. Всё строится на сервис-контейнере.

## Ответ

### Общий поток обработки запроса

Архитектура Symfony построена по принципу **Request-Response**. Каждый HTTP-запрос проходит через единую точку входа `public/index.php`, где создаётся объект `Request` (из HttpFoundation), передаётся в `Kernel`, а на выходе формируется `Response`. Весь процесс управляется событийной системой `EventDispatcher`, что делает его полностью расширяемым.

```
Client → index.php → Kernel::handle(Request) → EventDispatcher → Controller → Response → Client
```

### Ядро HttpKernel

`HttpKernel` -- это сердце фреймворка. Он реализует интерфейс `HttpKernelInterface` с единственным методом `handle(Request): Response`. Внутри HttpKernel последовательно диспатчит события ядра, каждое из которых даёт возможность вмешаться в процесс:

1. **kernel.request** -- можно вернуть ранний Response (например, для кэша или авторизации), здесь же RouterListener определяет контроллер
2. **kernel.controller** -- можно подменить или декорировать контроллер
3. **kernel.controller_arguments** -- можно изменить аргументы контроллера
4. **kernel.view** -- если контроллер вернул не Response, а данные (например, массив), слушатель превращает их в Response
5. **kernel.response** -- финальная обработка ответа (заголовки, кэш)
6. **kernel.finish_request** -- очистка после вложенных запросов
7. **kernel.terminate** -- выполняется после отправки ответа клиенту (логирование, отправка email и т.д.)
8. **kernel.exception** -- обработка любого исключения на любом этапе

```php
// Упрощённая схема HttpKernel::handle()
public function handle(Request $request, int $type = self::MAIN_REQUEST, bool $catch = true): Response
{
    // 1. Dispatch kernel.request
    $event = new RequestEvent($this, $request, $type);
    $this->dispatcher->dispatch($event, KernelEvents::REQUEST);

    if ($event->hasResponse()) {
        return $this->filterResponse($event->getResponse(), $request, $type);
    }

    // 2. Resolve controller
    $controller = $this->resolver->getController($request);

    // 3. Resolve arguments
    $arguments = $this->argumentResolver->getArguments($request, $controller);

    // 4. Call controller
    $response = $controller(...$arguments);

    // 5. If not Response — dispatch kernel.view
    // 6. Dispatch kernel.response
    // 7. Return Response
}
```

### Service Container (DI-контейнер)

Все объекты (сервисы) в Symfony управляются контейнером зависимостей. Контейнер создаётся один раз при загрузке приложения и компилируется в оптимизированный PHP-класс. Ключевые возможности:

- **Autowiring** -- контейнер автоматически подставляет зависимости на основе type-hints аргументов конструктора
- **Autoconfigure** -- автоматически применяет теги к сервисам на основе реализуемых интерфейсов (например, `EventSubscriberInterface` → тег `kernel.event_subscriber`)
- **Service locator** и **service subscriber** -- для ленивой загрузки сервисов

```yaml
# config/services.yaml
services:
    _defaults:
        autowire: true
        autoconfigure: true
        public: false    # сервисы приватные по умолчанию

    App\:
        resource: '../src/'
        exclude:
            - '../src/DependencyInjection/'
            - '../src/Entity/'
            - '../src/Kernel.php'
```

### Структура каталогов проекта

```
my-project/
├── bin/console              # CLI точка входа
├── config/                  # Конфигурация (YAML/PHP)
│   ├── packages/            # Конфиги пакетов по окружениям
│   ├── routes.yaml
│   └── services.yaml
├── public/index.php         # HTTP точка входа (front controller)
├── src/
│   ├── Controller/
│   ├── Entity/
│   ├── Repository/
│   ├── Service/
│   └── Kernel.php           # Ядро приложения
├── templates/               # Twig-шаблоны
├── var/                     # Кэш и логи
├── vendor/                  # Зависимости Composer
└── .env                     # Переменные окружения
```

### Kernel приложения

`App\Kernel` наследуется от `Symfony\Component\HttpKernel\Kernel` и отвечает за регистрацию бандлов, загрузку конфигов и компиляцию контейнера. В Symfony 7 Kernel максимально прост благодаря `MicroKernelTrait`:

```php
use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
use Symfony\Component\HttpKernel\Kernel as BaseKernel;

class Kernel extends BaseKernel
{
    use MicroKernelTrait;
    // Вся конфигурация загружается автоматически из config/
}
```

### Практические советы

- Используйте команду `php bin/console debug:container` для просмотра всех зарегистрированных сервисов и их зависимостей
- Команда `php bin/console debug:event-dispatcher` покажет все зарегистрированные слушатели событий
- Для понимания того, как обрабатывается запрос, используйте Web Profiler (панель «Request/Response» и «Events»)
- Старайтесь не инжектить `ContainerInterface` напрямую -- это анти-паттерн; используйте autowiring конкретных сервисов
- Все сервисы по умолчанию приватные (private) -- это намеренно, чтобы их нельзя было получать из контейнера напрямую

## Примеры

1. Поток запроса: `/posts/10` → Router → `PostController::show()` → `Response`.
2. Событие `kernel.response` добавляет заголовок `X-Request-Id`.
3. Autowiring: сервис `MailerInterface` автоматически инжектится в контроллер.

## Доп. теория

1. HttpKernel и EventDispatcher позволяют вмешиваться в пайплайн без изменения ядра.
2. Инжект контейнера напрямую считается антипаттерном.
