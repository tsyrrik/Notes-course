## Вопрос: Миграции Doctrine
Версия: Symfony 8.0 (stable), LTS 7.4; PHP 8.4+ / 8.2+.

## Простой ответ
миграции описывают изменения схемы БД, чтобы команда накатывала одинаково. Генерируются из изменений метаданных сущностей.

## Ответ

### Что такое миграции

Миграции Doctrine -- это механизм версионирования схемы базы данных. Каждая миграция -- это PHP-класс с методами `up()` (применить изменение) и `down()` (откатить). Миграции генерируются автоматически на основе разницы между текущим состоянием метаданных сущностей и реальной схемой БД. Это обеспечивает консистентность схемы между всеми окружениями (dev, staging, production).

### Основные команды

```bash
# Сгенерировать миграцию на основе изменений в сущностях
php bin/console make:migration

# Применить все непримененные миграции
php bin/console doctrine:migrations:migrate

# Применить конкретную версию
php bin/console doctrine:migrations:migrate 'DoctrineMigrations\Version20250115120000'

# Откатить последнюю миграцию
php bin/console doctrine:migrations:migrate prev

# Показать статус миграций
php bin/console doctrine:migrations:status

# Показать список миграций (какие применены, какие нет)
php bin/console doctrine:migrations:list

# Сгенерировать пустую миграцию (для ручного SQL)
php bin/console doctrine:migrations:generate

# Показать SQL без выполнения (dry-run)
php bin/console doctrine:migrations:migrate --dry-run
```

### Пример миграции

```php
declare(strict_types=1);

namespace DoctrineMigrations;

use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;

final class Version20250115120000 extends AbstractMigration
{
    public function getDescription(): string
    {
        return 'Добавляет поле phone и индекс на email в таблицу users';
    }

    public function up(Schema $schema): void
    {
        $this->addSql('ALTER TABLE users ADD phone VARCHAR(20) DEFAULT NULL');
        $this->addSql('CREATE UNIQUE INDEX UNIQ_EMAIL ON users (email)');
    }

    public function down(Schema $schema): void
    {
        $this->addSql('DROP INDEX UNIQ_EMAIL ON users');
        $this->addSql('ALTER TABLE users DROP phone');
    }
}
```

### Конфигурация миграций

```yaml
# config/packages/doctrine_migrations.yaml
doctrine_migrations:
    migrations_paths:
        'DoctrineMigrations': '%kernel.project_dir%/migrations'
    all_or_nothing: true           # Все SQL в транзакции или ничего
    transactional: true            # Каждая миграция в транзакции
    check_database_platform: true  # Проверка платформы БД
    organize_migrations: none      # none | year | year_and_month (по подпапкам)
```

### Миграции с данными (Data Migrations)

Иногда при изменении схемы нужно мигрировать и данные. Это делается прямо в миграции:

```php
public function up(Schema $schema): void
{
    // 1. Добавить новую колонку
    $this->addSql('ALTER TABLE users ADD full_name VARCHAR(255) DEFAULT NULL');

    // 2. Заполнить данными из существующих полей
    $this->addSql("UPDATE users SET full_name = CONCAT(first_name, ' ', last_name)");

    // 3. Сделать колонку NOT NULL
    $this->addSql('ALTER TABLE users ALTER COLUMN full_name SET NOT NULL');

    // 4. Удалить старые колонки (опционально, лучше в отдельной миграции)
    // $this->addSql('ALTER TABLE users DROP first_name, DROP last_name');
}
```

### Работа в команде и CI/CD

В команде каждый разработчик создаёт свои миграции, которые коммитятся в git. При деплое на сервер выполняется `doctrine:migrations:migrate --no-interaction`. Таблица `doctrine_migration_versions` хранит список уже выполненных миграций, поэтому повторное применение невозможно.

```bash
# В CI/CD pipeline
php bin/console doctrine:migrations:migrate --no-interaction --allow-no-migration
```

### Практические советы

- Никогда не редактируйте уже применённые миграции -- создавайте новую
- Всегда проверяйте сгенерированный SQL перед применением (особенно для production)
- Используйте `--dry-run` для предварительного просмотра SQL
- Метод `down()` должен полностью откатывать `up()` -- это пригодится при откатах
- Для production используйте `all_or_nothing: true`, чтобы частично применённая миграция не оставила БД в сломанном состоянии
- На production сначала выполняйте `doctrine:migrations:migrate --dry-run`, затем без флага
- Для больших таблиц (миллионы строк) `ALTER TABLE` может блокировать таблицу -- используйте онлайн-миграции (pt-online-schema-change или gh-ost)

## Примеры

1. `php bin/console make:migration` после добавления поля в Entity.
2. `doctrine:migrations:migrate --dry-run` для просмотра SQL.
3. `doctrine:migrations:migrate prev` для отката последней миграции.

## Доп. теория

1. Миграции должны быть атомарными и воспроизводимыми в CI/CD.
2. Никогда не редактируйте уже применённые миграции.
