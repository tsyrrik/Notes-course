## Вопрос: Хранимые процедуры/функции

## Простой ответ
- Код живёт в базе и выполняется там же; меньше сетевых походов.
- Полезно для тяжёлой логики рядом с данными, но усложняет версионирование/тесты.

## Ответ

### Что такое хранимые процедуры и функции

Хранимые процедуры (stored procedures) и функции (stored functions) -- это именованные блоки кода, которые хранятся и выполняются на стороне сервера базы данных. Код компилируется один раз и сохраняется в каталоге БД, что позволяет вызывать его многократно без повторной компиляции. Они пишутся на процедурных расширениях SQL: PL/pgSQL (PostgreSQL), PL/SQL (Oracle), T-SQL (SQL Server), а также на внешних языках (Python, Perl, JavaScript через PL/v8 и др.).

### Разница между процедурой и функцией

| Критерий | Функция (FUNCTION) | Процедура (PROCEDURE) |
|----------|-------------------|----------------------|
| Возвращает значение | Да, обязательно (RETURNS type) | Нет (может использовать OUT-параметры) |
| Вызов | `SELECT my_func(...)` или в выражениях | `CALL my_proc(...)` |
| Транзакции | Не может управлять транзакциями (COMMIT/ROLLBACK) | Может содержать COMMIT/ROLLBACK (PostgreSQL 11+) |
| Использование в SQL | Можно в SELECT, WHERE, JOIN и т.д. | Нельзя использовать в SQL-выражениях |
| Побочные эффекты | Допустимы, но не рекомендуются в IMMUTABLE/STABLE | Основное предназначение -- выполнять действия |

В PostgreSQL до версии 11 были только функции. Процедуры (PROCEDURE + CALL) появились в PostgreSQL 11.

## Примеры

**Простая функция:**
```sql
CREATE OR REPLACE FUNCTION get_user_orders_count(p_user_id BIGINT)
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    SELECT count(*) INTO v_count
    FROM orders
    WHERE user_id = p_user_id;

    RETURN v_count;
END;
$$ LANGUAGE plpgsql STABLE;

-- Использование:
SELECT name, get_user_orders_count(id) AS order_count
FROM users
WHERE id = 42;
```

**Функция, возвращающая таблицу (SETOF):**
```sql
CREATE OR REPLACE FUNCTION get_active_users(p_min_orders INT DEFAULT 5)
RETURNS TABLE (user_id BIGINT, user_name TEXT, total_orders BIGINT) AS $$
BEGIN
    RETURN QUERY
    SELECT u.id, u.name, count(o.id)
    FROM users u
    JOIN orders o ON o.user_id = u.id
    WHERE o.status = 'completed'
    GROUP BY u.id, u.name
    HAVING count(o.id) >= p_min_orders
    ORDER BY count(o.id) DESC;
END;
$$ LANGUAGE plpgsql STABLE;

-- Использование:
SELECT * FROM get_active_users(10);
```

**Процедура с управлением транзакциями (PostgreSQL 11+):**
```sql
CREATE OR REPLACE PROCEDURE transfer_funds(
    p_from_account BIGINT,
    p_to_account   BIGINT,
    p_amount       NUMERIC
) LANGUAGE plpgsql AS $$
DECLARE
    v_balance NUMERIC;
BEGIN
    -- Проверяем баланс
    SELECT balance INTO v_balance
    FROM accounts WHERE id = p_from_account FOR UPDATE;

    IF v_balance < p_amount THEN
        RAISE EXCEPTION 'Недостаточно средств: баланс=%, запрошено=%', v_balance, p_amount;
    END IF;

    UPDATE accounts SET balance = balance - p_amount WHERE id = p_from_account;
    UPDATE accounts SET balance = balance + p_amount WHERE id = p_to_account;

    INSERT INTO transactions (from_acc, to_acc, amount, created_at)
    VALUES (p_from_account, p_to_account, p_amount, now());

    COMMIT;
END;
$$;

-- Вызов:
CALL transfer_funds(1, 2, 500.00);
```

**Функция с обработкой ошибок:**
```sql
CREATE OR REPLACE FUNCTION safe_divide(a NUMERIC, b NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN a / b;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'Деление на ноль, возвращаем NULL';
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE NOTICE 'Неизвестная ошибка: %', SQLERRM;
        RETURN NULL;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

### Категории волатильности (PostgreSQL)

Важно правильно указывать volatility category -- это влияет на оптимизацию запросов:

| Категория | Значение | Пример |
|-----------|----------|--------|
| **IMMUTABLE** | Всегда возвращает одинаковый результат для одинаковых аргументов. Не читает БД | Математические функции, форматирование |
| **STABLE** | Результат не меняется в пределах одного SQL-оператора. Читает БД, но не модифицирует | Функции чтения справочников, конфигурации |
| **VOLATILE** (default) | Результат может меняться при каждом вызове | Функции с INSERT/UPDATE, random(), now() |

### Преимущества хранимых процедур/функций

1. **Снижение сетевого трафика** -- вместо множества SQL-запросов из приложения выполняется один вызов процедуры, вся обработка происходит на сервере БД.
2. **Переиспользование логики** -- одна функция вызывается из разных приложений, языков, инструментов.
3. **Безопасность** -- можно дать пользователю право вызывать функцию (EXECUTE), но не давать доступ к таблицам напрямую (`SECURITY DEFINER`).
4. **Производительность** -- план запроса кэшируется; для prepared statements это даёт ускорение.
5. **Атомарность** -- весь код функции выполняется в одной транзакции.

### Недостатки и когда НЕ использовать

1. **Сложность отладки** -- нет удобных IDE/debugger'ов (хотя pgAdmin и DBeaver имеют базовую отладку).
2. **Версионирование** -- код живёт в БД, а не в git. Нужно дисциплинированно хранить определения в миграциях.
3. **Тестирование** -- сложнее писать unit-тесты для PL/pgSQL, чем для кода приложения (хотя есть pgTAP).
4. **Привязка к СУБД** -- PL/pgSQL код не портируется на MySQL и наоборот.
5. **Горизонтальное масштабирование** -- логику приложения проще масштабировать (добавить серверов), чем хранимые процедуры (привязаны к БД).

### Практические рекомендации

- Используйте функции для **инкапсуляции сложных запросов**, которые нужны в нескольких местах (расчёт скидки, проверка прав доступа, генерация отчёта).
- Не переносите **бизнес-логику приложения** в хранимые процедуры без веской причины -- это усложняет поддержку и масштабирование.
- Всегда указывайте **volatility category** (IMMUTABLE/STABLE/VOLATILE) -- это критично для производительности.
- Храните определения функций в **файлах миграций** для версионирования: `CREATE OR REPLACE FUNCTION ...` в up-миграции.
- Используйте `SECURITY DEFINER` осторожно -- функция выполняется с правами владельца, что может быть уязвимостью.
- Для списка всех функций в PostgreSQL: `\df` в psql или `SELECT * FROM pg_proc WHERE pronamespace = 'public'::regnamespace;`

## Доп. теория
- Процедуры появились в PostgreSQL 11; до этого использовали только функции.
- Из-за привязки к СУБД хранимые процедуры усложняют миграцию между движками.
