## Вопрос: Использование составного индекса по одному полю

## Простой ответ
- Составной индекс работает слева направо: если нет первого столбца в условии, индекс не поможет.

## Ответ

### Что такое составной индекс и правило левого префикса

Составной (composite) индекс -- это индекс, построенный по нескольким столбцам одновременно. Данные в таком индексе отсортированы сначала по первому столбцу, затем по второму (при равенстве первого), затем по третьему и т.д. -- как телефонный справочник, отсортированный по фамилии, затем по имени, затем по отчеству.

**Правило левого префикса** (leftmost prefix rule) гласит: составной индекс по `(a, b, c)` может быть использован планировщиком только для запросов, которые фильтруют по **непрерывному префиксу** столбцов слева направо: `(a)`, `(a, b)` или `(a, b, c)`.

### Какие запросы используют индекс `(a, b, c)`

```sql
CREATE INDEX idx_abc ON orders (status, user_id, created_at);
```

| Запрос (WHERE) | Использует индекс? | Почему |
|----------------|:------------------:|--------|
| `status = 'active'` | Да | Левый префикс (a) |
| `status = 'active' AND user_id = 42` | Да | Префикс (a, b) |
| `status = 'active' AND user_id = 42 AND created_at > '2024-01-01'` | Да | Полный индекс (a, b, c) |
| `user_id = 42` | Нет* | Пропущен первый столбец (a) |
| `created_at > '2024-01-01'` | Нет* | Пропущены (a) и (b) |
| `user_id = 42 AND created_at > '2024-01-01'` | Нет* | Пропущен первый столбец (a) |
| `status = 'active' AND created_at > '2024-01-01'` | Частично | Используется только (a), (b) пропущен -- range по (c) без (b) неэффективен |

_*В PostgreSQL планировщик может использовать Index Scan с фильтрацией (bitmap index scan), но это менее эффективно, чем прямое использование._

### Визуализация: почему это работает

Представьте B-tree для индекса `(status, user_id, created_at)`:

```
Уровень 1: status
  active
    ├── user_id = 1
    │     ├── 2024-01-01
    │     ├── 2024-01-15
    │     └── 2024-02-01
    ├── user_id = 42
    │     ├── 2024-01-10
    │     └── 2024-03-01
    └── user_id = 100
          └── 2024-02-15
  completed
    ├── user_id = 1
    │     └── 2024-01-05
    ...
```

Поиск по `status = 'active' AND user_id = 42` -- это спуск по дереву: сначала находим ветку `active`, затем внутри неё -- ветку `user_id = 42`. Быстро и эффективно.

Поиск по `user_id = 42` без `status` -- данные для `user_id = 42` разбросаны по разным веткам status. Индекс не помогает навигации.

### Составной индекс и ORDER BY

Индекс также помогает для сортировки, если ORDER BY совпадает с префиксом:

```sql
-- Использует индекс для сортировки (нет Filesort):
SELECT * FROM orders WHERE status = 'active' ORDER BY user_id, created_at;

-- НЕ использует индекс для сортировки (порядок столбцов нарушен):
SELECT * FROM orders WHERE status = 'active' ORDER BY created_at, user_id;

-- НЕ использует индекс (смешанные направления, если индекс ASC):
SELECT * FROM orders WHERE status = 'active' ORDER BY user_id ASC, created_at DESC;
-- (В PostgreSQL можно создать индекс с разными направлениями:
--  CREATE INDEX ... ON orders (status, user_id ASC, created_at DESC))
```

### Covering index (покрывающий индекс)

Если все столбцы, нужные для запроса, есть в индексе, СУБД может ответить на запрос **без обращения к таблице** (Index Only Scan в PostgreSQL, Using index в MySQL):

```sql
CREATE INDEX idx_covering ON orders (status, user_id, created_at);

-- Index Only Scan (все нужные столбцы в индексе):
SELECT user_id, created_at FROM orders WHERE status = 'active';

-- PostgreSQL INCLUDE для добавления столбцов без участия в сортировке:
CREATE INDEX idx_cover ON orders (status, user_id) INCLUDE (amount, created_at);
```

### Сколько столбцов включать в составной индекс

Общие рекомендации по выбору столбцов и их порядку:

1. **Столбцы с условием равенства (=)** -- ставьте первыми.
2. **Столбцы с range-условием (>, <, BETWEEN)** -- после столбцов равенства.
3. **Столбцы для ORDER BY** -- после фильтров.
4. **Высокая селективность** -- столбцы, которые сильнее сужают выборку, лучше ставить раньше.

```sql
-- Запрос:
SELECT * FROM orders
WHERE status = 'active' AND user_id = 42
  AND created_at BETWEEN '2024-01-01' AND '2024-12-31'
ORDER BY created_at;

-- Оптимальный индекс:
CREATE INDEX idx_optimal ON orders (status, user_id, created_at);
-- status (=), user_id (=) -- equality первыми, created_at (range + ORDER BY) -- последним
```

### Частые ошибки

1. **Создание избыточных индексов**: если есть индекс `(a, b, c)`, отдельный индекс `(a)` и `(a, b)` -- лишние. Составной индекс уже покрывает эти случаи.
2. **Создание индекса `(a, b)` при запросах только по `(b)`**: индекс не поможет. Нужен отдельный индекс по `(b)` или поменять порядок.
3. **Слишком много столбцов**: индекс из 6-7 столбцов занимает много места, медленно обновляется и редко используется полностью.

### Практические рекомендации

- Анализируйте **реальные запросы** (`pg_stat_statements`, slow query log) и создавайте составные индексы под самые частые паттерны.
- Проверяйте планы выполнения через `EXPLAIN ANALYZE` -- убедитесь, что индекс действительно используется.
- В PostgreSQL используйте `INCLUDE` для covering index вместо добавления столбцов в ключ индекса.
- Помните: каждый индекс замедляет INSERT/UPDATE/DELETE. Не создавайте индексы "на всякий случай".
- Для мониторинга неиспользуемых индексов: `SELECT * FROM pg_stat_user_indexes WHERE idx_scan = 0;`

## Примеры
```sql
CREATE INDEX idx_orders_status_user_date ON orders (status, user_id, created_at);
```

## Доп. теория
- Составной индекс может использоваться по левому префиксу, но не по «пропущенным» столбцам.
- Порядок столбцов в индексе важнее количества.
