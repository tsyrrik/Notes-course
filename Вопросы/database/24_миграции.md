## Вопрос: Миграции

## Простой ответ
- Храним изменения схемы в файлах и прогоняем их одинаково на всех средах.
- Есть `up` и `down`, чтобы откатывать при ошибках.

Пример — в конце.

## Ответ

### Что такое миграции

Миграции -- это версионированные файлы, описывающие изменения схемы базы данных (создание/изменение/удаление таблиц, столбцов, индексов, ограничений, seed-данных). Каждая миграция имеет уникальный идентификатор (обычно timestamp) и содержит два метода: `up` (применить изменение) и `down` (откатить). Миграции хранятся в системе контроля версий (git) наравне с кодом приложения, что даёт полную историю эволюции схемы БД.

### Зачем нужны миграции

Без миграций управление схемой БД превращается в хаос: разработчики вручную выполняют SQL на разных средах, схема dev/staging/production расходится, невозможно воспроизвести состояние БД для конкретной версии кода. Миграции решают эти проблемы:

1. **История изменений** -- каждое изменение схемы задокументировано, привязано к коммиту и ревью.
2. **Консистентность сред** -- одни и те же миграции выполняются на dev, staging, production.
3. **Воспроизводимость** -- новый разработчик поднимает БД с нуля командой `migrate up`.
4. **Откаты** -- при ошибке можно откатить последнюю миграцию через `down`.
5. **CI/CD** -- миграции автоматически применяются при деплое.

### Как работает механизм миграций

В базе данных создаётся служебная таблица (обычно `schema_migrations` или `migrations`), хранящая список уже применённых миграций. При запуске `migrate up` инструмент сравнивает файлы миграций с записями в этой таблице и выполняет только новые (ещё не применённые) миграции в порядке их timestamp.

```
schema_migrations
┌──────────────────────────┬─────────────────────┐
│ version                  │ applied_at           │
├──────────────────────────┼─────────────────────┤
│ 20240115100000           │ 2024-01-15 10:05:00 │
│ 20240120143000           │ 2024-01-20 14:35:00 │
│ 20240201090000           │ 2024-02-01 09:10:00 │
└──────────────────────────┴─────────────────────┘
```

### Примеры миграций в разных инструментах

**Чистый SQL (golang-migrate, Flyway, dbmate):**
```sql
-- 20240115100000_create_users.up.sql
CREATE TABLE users (
    id         BIGSERIAL PRIMARY KEY,
    email      VARCHAR(255) NOT NULL UNIQUE,
    name       VARCHAR(100) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT now(),
    updated_at TIMESTAMP NOT NULL DEFAULT now()
);
CREATE INDEX idx_users_email ON users (email);

-- 20240115100000_create_users.down.sql
DROP TABLE IF EXISTS users;
```

**Alembic (Python/SQLAlchemy):**
```python
# alembic/versions/20240120_add_role_to_users.py
def upgrade():
    op.add_column('users', sa.Column('role', sa.String(50), server_default='user'))
    op.create_index('idx_users_role', 'users', ['role'])

def downgrade():
    op.drop_index('idx_users_role')
    op.drop_column('users', 'role')
```

**ActiveRecord (Ruby on Rails):**
```ruby
class AddPhoneToUsers < ActiveRecord::Migration[7.0]
  def change
    add_column :users, :phone, :string
    add_index :users, :phone, unique: true
  end
end
```

### Типы миграций

| Тип | Описание | Пример |
|-----|----------|--------|
| **Структурные** | Изменение схемы (DDL) | CREATE TABLE, ALTER TABLE, DROP COLUMN |
| **Индексные** | Создание/удаление индексов | CREATE INDEX, DROP INDEX |
| **Данные (data migrations)** | Преобразование данных | UPDATE users SET role = 'admin' WHERE ... |
| **Seed** | Начальные/справочные данные | INSERT INTO countries ... |

### Безопасные миграции на production

На production миграции становятся критичной операцией. Важные правила:

- **Не удаляйте столбцы напрямую** -- сначала перестаньте использовать столбец в коде (деплой), затем удалите его отдельной миграцией. Иначе при откате деплоя старый код будет обращаться к удалённому столбцу.
- **Добавляйте столбцы с DEFAULT** -- в PostgreSQL 11+ `ALTER TABLE ADD COLUMN ... DEFAULT x` не перезаписывает все строки; в старых версиях это lock всей таблицы.
- **CREATE INDEX CONCURRENTLY** -- создание индекса без блокировки таблицы в PostgreSQL:
```sql
CREATE INDEX CONCURRENTLY idx_orders_user ON orders (user_id);
```
- **Разделяйте деплой и миграцию** -- миграция должна быть совместима и со старой, и с новой версией кода.
- **Не делайте `down` на production** -- откат миграции может привести к потере данных. Вместо этого создавайте новую миграцию, исправляющую проблему.

### Популярные инструменты

| Инструмент | Язык/Экосистема | Особенности |
|------------|-----------------|-------------|
| **golang-migrate** | Go | Чистый SQL, CLI + библиотека |
| **Alembic** | Python/SQLAlchemy | Автогенерация миграций из моделей |
| **Flyway** | Java/JVM | Enterprise-ready, SQL + Java callbacks |
| **Liquibase** | Java/JVM | XML/YAML/JSON формат, diff schemas |
| **ActiveRecord** | Ruby on Rails | DSL для миграций, `change` с авто-откатом |
| **Knex.js** | Node.js | JavaScript/TypeScript миграции |
| **dbmate** | Универсальный | Простой CLI, чистый SQL |

### Практические рекомендации

- **Каждая миграция -- одно логическое изменение**. Не смешивайте создание таблицы и добавление столбца в другую таблицу.
- **Тестируйте миграции на копии production данных** перед деплоем. Миграция может работать на пустой dev-базе, но зависнуть на таблице с миллионами строк.
- **Делайте backup перед миграцией** на production.
- **Не редактируйте уже применённые миграции** -- если миграция уже выполнена на staging/production, создавайте новую.
- **Следите за временем выполнения** -- длинные миграции блокируют деплой и могут вызвать downtime.

## Примеры
```sql
-- up
CREATE TABLE users (
  id serial PRIMARY KEY,
  email text NOT NULL UNIQUE
);
-- down
DROP TABLE users;
```

## Доп. теория
- Миграции должны быть воспроизводимыми: применяться на пустой базе и на боевой.
- Откат (down) полезен в dev/stage, но на production чаще делают «forward fix».
