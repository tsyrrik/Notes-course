## Вопрос: Типы сканирования

## Простой ответ
- Seq Scan — читаем таблицу целиком; ок для малых таблиц или без селективных фильтров.
- Index Scan — точечное чтение через индекс.
- Bitmap — объединяем несколько индексов/условий, читаем строки пачками.
- Index Only — быстрее, если все нужные колонки уже в индексе.

Примеры — в конце.

## Ответ

### Обзор типов сканирования

Планировщик запросов (query planner) выбирает стратегию доступа к данным на основе статистики таблицы, наличия индексов и оценки стоимости. Понимание типов сканирования критично для анализа производительности запросов через `EXPLAIN`.

| Тип сканирования | Когда используется | Скорость |
|---|---|---|
| Sequential Scan | Нет подходящего индекса или читаем >10-15% таблицы | Медленно на больших таблицах |
| Index Scan | Высокая селективность, мало строк | Быстро |
| Index Only Scan | Все нужные столбцы есть в индексе | Очень быстро |
| Bitmap Index Scan + Bitmap Heap Scan | Средняя селективность или несколько условий | Быстрее Seq Scan, медленнее Index Scan |

### Sequential Scan (Seq Scan)

Sequential Scan — последовательное чтение всех страниц таблицы от начала до конца. СУБД читает каждую строку и проверяет условие WHERE. Это самый простой, но и самый медленный способ для больших таблиц.

Когда Seq Scan оправдан:
- Таблица маленькая (помещается в несколько страниц).
- Запрос возвращает значительную часть строк (>10-15%).
- Нет подходящего индекса.
- Данные нужно прочитать целиком (например, агрегация без фильтра).

```sql
EXPLAIN ANALYZE SELECT count(*) FROM orders;
-- Aggregate  (cost=15420.00..15420.01 rows=1)
--   ->  Seq Scan on orders  (cost=0.00..13920.00 rows=600000)
-- Seq Scan оправдан: читаем все строки для COUNT(*)
```

### Index Scan

Index Scan — СУБД сначала ищет ключ в индексе (B-Tree, Hash и т.д.), получает указатель на строку (tuple ID), затем обращается к таблице (heap) за полными данными строки. Это «точечный» доступ — эффективен, когда нужно прочитать мало строк.

Особенность: каждая найденная строка требует отдельного обращения к heap (random I/O). Поэтому при большом количестве найденных строк Index Scan может быть дороже Seq Scan.

```sql
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'admin@example.com';
-- Index Scan using idx_users_email on users  (cost=0.42..8.44 rows=1 width=128)
--   Index Cond: (email = 'admin@example.com')
--   actual time=0.028..0.029 rows=1 loops=1
```

### Index Only Scan

Index Only Scan — самый быстрый тип: все необходимые столбцы находятся в индексе, поэтому обращение к таблице не требуется. Однако в PostgreSQL из-за MVCC движок должен проверить visibility map, чтобы убедиться, что строка видима текущей транзакции. Если страница не отмечена как «all-visible» (после VACUUM), PostgreSQL всё равно обратится к heap.

```sql
-- Покрывающий индекс
CREATE INDEX idx_orders_user_status ON orders (user_id, status);

EXPLAIN ANALYZE SELECT status FROM orders WHERE user_id = 42;
-- Index Only Scan using idx_orders_user_status on orders
--   Index Cond: (user_id = 42)
--   Heap Fetches: 0   <- 0 означает, что visibility map актуальна (VACUUM отработал)
```

Важно: если `Heap Fetches` значительно больше 0, выполните `VACUUM` на таблице, чтобы обновить visibility map и получить истинный Index Only Scan.

```sql
VACUUM orders;
-- После этого Heap Fetches должен снизиться до 0 или близко к нему
```

### Bitmap Index Scan + Bitmap Heap Scan

Bitmap Scan — двухфазный процесс:

1. **Bitmap Index Scan** — проход по индексу, построение битовой карты страниц (bitmap), в которых есть подходящие строки. Вместо указателей на строки строится карта «какие страницы таблицы содержат нужные данные».
2. **Bitmap Heap Scan** — чтение отмеченных страниц таблицы. Страницы читаются последовательно (sequential I/O), что значительно эффективнее множества random I/O при Index Scan.

Главное преимущество — возможность объединять bitmap от нескольких индексов через BitmapAnd и BitmapOr:

```sql
EXPLAIN ANALYZE
SELECT * FROM orders WHERE status = 'paid' AND created_at > '2024-01-01';

-- Bitmap Heap Scan on orders
--   Recheck Cond: ((status = 'paid') AND (created_at > '2024-01-01'))
--   ->  BitmapAnd
--         ->  Bitmap Index Scan on idx_orders_status
--               Index Cond: (status = 'paid')
--         ->  Bitmap Index Scan on idx_orders_created_at
--               Index Cond: (created_at > '2024-01-01')
```

Bitmap Scan выбирается планировщиком, когда селективность «средняя» — слишком много строк для Index Scan (дорого по random I/O), но слишком мало для Seq Scan.

### Как планировщик выбирает тип сканирования

Планировщик оценивает стоимость каждого варианта в условных единицах. Ключевые параметры:

```sql
SHOW seq_page_cost;       -- стоимость чтения одной страницы последовательно (default: 1.0)
SHOW random_page_cost;    -- стоимость чтения одной страницы случайно (default: 4.0)
-- Для SSD random_page_cost можно снизить до 1.1-1.5
SET random_page_cost = 1.1;  -- SSD: random I/O почти не дороже sequential
```

На SSD-дисках стоит снизить `random_page_cost`, чтобы планировщик чаще выбирал Index Scan вместо Seq Scan. Также важна актуальная статистика — выполняйте `ANALYZE` после значительных изменений данных.

### Практические рекомендации по диагностике

```sql
-- 1. Всегда используйте EXPLAIN ANALYZE (реальное выполнение, а не оценка)
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT * FROM users WHERE email = 'test@test.com';

-- 2. Обращайте внимание на:
--    - actual time — реальное время выполнения
--    - rows — сколько строк найдено (сравните с rows в оценке)
--    - Buffers: shared hit (из кеша) vs read (с диска)
--    - Heap Fetches для Index Only Scan

-- 3. Если планировщик выбрал Seq Scan вместо Index Scan:
--    а) Проверьте, есть ли индекс
--    б) Проверьте селективность — возможно, Seq Scan действительно быстрее
--    в) Проверьте актуальность статистики: ANALYZE tablename;
--    г) На SSD снизьте random_page_cost
```

## Примеры
```sql
EXPLAIN SELECT * FROM users WHERE email = 'a@b.c';
```

```sql
EXPLAIN SELECT * FROM orders WHERE status='paid' AND created_at > now()-interval '7 days';
```

## Доп. теория
- Тип сканирования выбирается планировщиком по стоимости, а не «по наличию индекса».
- На SSD часто имеет смысл снижать `random_page_cost`.
