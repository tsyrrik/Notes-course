## Вопрос: Триггеры

## Простой ответ
- Авто-хуки в базе: при вставке/обновлении/удалении выполняют ваш код.
- Полезны для аудита/updated_at, но могут скрыть логику и усложнить отладку.

Пример — в конце.

## Ответ

### Что такое триггеры

Триггер -- это именованный блок процедурного кода, который автоматически выполняется СУБД при наступлении определённого события на таблице или представлении (view). Триггер "привязан" к таблице и срабатывает при `INSERT`, `UPDATE`, `DELETE` или `TRUNCATE`. Разработчик не вызывает триггер вручную -- он активируется самой базой данных, что делает его мощным, но потенциально опасным инструментом.

### Классификация триггеров

| Критерий | Варианты | Описание |
|----------|----------|----------|
| **Момент срабатывания** | BEFORE | До выполнения операции. Можно модифицировать данные (NEW) или отменить операцию |
| | AFTER | После выполнения. Данные уже записаны, можно логировать, отправлять уведомления |
| | INSTEAD OF | Вместо операции (только для VIEW в PostgreSQL) |
| **Уровень** | FOR EACH ROW | Выполняется для каждой затронутой строки |
| | FOR EACH STATEMENT | Выполняется один раз на весь оператор, даже если затронуто 0 строк |
| **Событие** | INSERT, UPDATE, DELETE, TRUNCATE | На какое DML-событие реагировать |

### Переменные NEW и OLD

В row-level триггерах доступны специальные переменные:

- **NEW** -- новая версия строки (доступна в INSERT и UPDATE). В BEFORE-триггере можно изменить значения полей NEW, и изменённые данные будут записаны.
- **OLD** -- старая версия строки (доступна в UPDATE и DELETE). Только для чтения.

```sql
-- В BEFORE UPDATE триггере:
-- OLD.email = 'old@mail.com'  (текущее значение)
-- NEW.email = 'new@mail.com'  (новое значение, которое будет записано)
-- Можно изменить: NEW.updated_at := now();
```

### Примеры использования

**1. Автоматическое обновление updated_at:**
```sql
CREATE OR REPLACE FUNCTION trg_set_updated_at()
RETURNS trigger AS $$
BEGIN
    NEW.updated_at := now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION trg_set_updated_at();
```

**2. Аудит изменений (логирование в отдельную таблицу):**
```sql
CREATE TABLE audit_log (
    id         BIGSERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    operation  TEXT NOT NULL,
    old_data   JSONB,
    new_data   JSONB,
    changed_by TEXT DEFAULT current_user,
    changed_at TIMESTAMP DEFAULT now()
);

CREATE OR REPLACE FUNCTION trg_audit()
RETURNS trigger AS $$
BEGIN
    INSERT INTO audit_log (table_name, operation, old_data, new_data)
    VALUES (
        TG_TABLE_NAME,
        TG_OP,
        CASE WHEN TG_OP IN ('UPDATE','DELETE') THEN row_to_json(OLD)::jsonb END,
        CASE WHEN TG_OP IN ('INSERT','UPDATE') THEN row_to_json(NEW)::jsonb END
    );
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_users
    AFTER INSERT OR UPDATE OR DELETE ON users
    FOR EACH ROW EXECUTE FUNCTION trg_audit();
```

**3. Валидация бизнес-правил:**
```sql
CREATE OR REPLACE FUNCTION trg_check_balance()
RETURNS trigger AS $$
BEGIN
    IF NEW.balance < 0 THEN
        RAISE EXCEPTION 'Баланс не может быть отрицательным: %', NEW.balance;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_balance
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
    EXECUTE FUNCTION trg_check_balance();
```

**4. Синхронизация данных (денормализация):**
```sql
-- Обновление счётчика комментариев в таблице постов
CREATE OR REPLACE FUNCTION trg_update_comment_count()
RETURNS trigger AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE posts SET comment_count = comment_count + 1 WHERE id = NEW.post_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE posts SET comment_count = comment_count - 1 WHERE id = OLD.post_id;
    END IF;
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_comment_count
    AFTER INSERT OR DELETE ON comments
    FOR EACH ROW EXECUTE FUNCTION trg_update_comment_count();
```

### Порядок выполнения триггеров

Если на одну таблицу навешано несколько триггеров одного типа, они выполняются в алфавитном порядке имён (в PostgreSQL). Порядок выполнения в целом:

1. BEFORE STATEMENT triggers
2. Для каждой строки: BEFORE ROW trigger -> операция -> AFTER ROW trigger
3. AFTER STATEMENT triggers

### Преимущества триггеров

- **Гарантированное выполнение** -- логика срабатывает всегда, независимо от того, кто и как модифицирует данные (приложение, скрипт, DBA вручную).
- **Атомарность** -- триггер выполняется в той же транзакции, что и основная операция.
- **Инкапсуляция** -- бизнес-правила и аудит на уровне БД, не зависят от приложения.

### Недостатки и подводные камни

- **Скрытая логика** -- триггеры не видны в коде приложения. `INSERT INTO users ...` может запустить цепочку из 5 триггеров. Это усложняет отладку и понимание поведения системы.
- **Каскадные триггеры** -- триггер может модифицировать другую таблицу, у которой свои триггеры. Возможны бесконечные циклы (PostgreSQL защищает от рекурсии, но не от сложных цепочек).
- **Производительность** -- row-level триггеры на массовых операциях (UPDATE 1M строк) значительно замедляют выполнение.
- **Тестирование** -- триггеры сложнее тестировать, чем код приложения.
- **Версионирование** -- изменения триггеров нужно отслеживать через миграции, что часто забывают.

### Практические рекомендации

- Используйте триггеры для **инфраструктурных задач**: `updated_at`, аудит, soft delete. Для бизнес-логики предпочитайте код приложения.
- Добавляйте `WHEN` clause для условного срабатывания -- это экономит ресурсы (триггер не вызывается, если условие не выполнено).
- Используйте `FOR EACH STATEMENT` вместо `FOR EACH ROW`, если не нужен доступ к NEW/OLD -- это значительно быстрее на массовых операциях.
- Документируйте триггеры: в каждом CREATE TRIGGER добавляйте комментарий, зачем он нужен.
- Для просмотра всех триггеров в PostgreSQL: `SELECT * FROM information_schema.triggers;`

## Примеры
```sql
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;$$ LANGUAGE plpgsql;

CREATE TRIGGER users_touch
BEFORE UPDATE ON users
FOR EACH ROW EXECUTE FUNCTION set_updated_at();
```

## Доп. теория
- Триггеры выполняются в рамках той же транзакции, что и основной запрос.
- Избыточное использование триггеров часто превращается в «скрытую» бизнес‑логику.
