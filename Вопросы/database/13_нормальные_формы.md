## Вопрос: Нормальные формы

## Простой ответ
- Нормализация убирает дубли и несогласованности при апдейтах/удалениях.
- Для OLTP достаточно до 3NF/BCNF; денормализация — сознательно ради скорости чтения.

Кейс нормализации — в конце.

## Ответ

### Зачем нужна нормализация

Нормализация — это процесс организации структуры реляционной базы данных с целью **уменьшения избыточности** (дублирования данных) и **предотвращения аномалий** при вставке, обновлении и удалении. Без нормализации одна и та же информация хранится в нескольких местах, что приводит к несогласованности: обновил в одном месте — забыл в другом. Нормальные формы — это набор правил, каждая следующая форма строится на предыдущей и добавляет дополнительные ограничения.

### Первая нормальная форма (1NF)

Таблица находится в 1NF, если:
- Все значения **атомарны** (неделимы) — в ячейке нет списков, массивов, вложенных структур.
- Каждый столбец имеет уникальное имя.
- Порядок строк и столбцов не имеет значения.
- Есть первичный ключ.

```text
❌ Нарушение 1NF:
| id | name   | phones              |
|----|--------|---------------------|
| 1  | Иван   | +7-111, +7-222      |  -- список в одной ячейке

✅ В 1NF:
| id | name   | phone   |
|----|--------|---------|
| 1  | Иван   | +7-111  |
| 1  | Иван   | +7-222  |

Или лучше — отдельная таблица:
users(id, name)
phones(id, user_id, phone)
```

### Вторая нормальная форма (2NF)

Таблица в 2NF, если она в 1NF и **каждый неключевой атрибут полностью зависит от всего первичного ключа**, а не от его части. Проблема 2NF возникает только при **составном ключе**.

```text
❌ Нарушение 2NF (ключ: student_id + course_id):
| student_id | course_id | student_name | grade |
|------------|-----------|-------------|-------|
| 1          | 101       | Иван        | A     |
| 1          | 102       | Иван        | B     |
-- student_name зависит только от student_id (часть ключа)

✅ В 2NF:
students(student_id, student_name)
enrollments(student_id, course_id, grade)
```

### Третья нормальная форма (3NF)

Таблица в 3NF, если она в 2NF и **нет транзитивных зависимостей** — неключевой атрибут не должен зависеть от другого неключевого атрибута.

```text
❌ Нарушение 3NF:
| employee_id | department_id | department_name |
|-------------|---------------|-----------------|
| 1           | 10            | Продажи         |
| 2           | 10            | Продажи         |
-- department_name зависит от department_id, а не от employee_id (транзитивная зависимость)

✅ В 3NF:
employees(employee_id, department_id)
departments(department_id, department_name)
```

### Нормальная форма Бойса-Кодда (BCNF)

BCNF — усиленная версия 3NF. Таблица в BCNF, если **каждая нетривиальная функциональная зависимость** имеет в качестве детерминанты (левой части) **суперключ**. Разница с 3NF проявляется в редких случаях с перекрывающимися составными ключами.

```text
❌ Нарушение BCNF:
| student | subject | teacher   |
|---------|---------|-----------|
| Иван    | Физика  | Петров    |
| Мария   | Физика  | Сидоров   |
-- Ключ: (student, subject), но teacher → subject (учитель ведёт один предмет)
-- teacher — детерминанта, но не суперключ

✅ В BCNF:
teachers(teacher_id, subject)
assignments(student, teacher_id)
```

### Более высокие нормальные формы

**4NF** — устраняет многозначные зависимости (когда два независимых множества связаны с ключом). **5NF** — устраняет зависимости соединения. На практике эти формы применяются редко — для большинства систем достаточно 3NF или BCNF.

### Аномалии, которые устраняет нормализация

| Тип аномалии | Описание | Пример |
|-------------|----------|--------|
| Аномалия вставки | Нельзя добавить данные без избыточной информации | Нельзя добавить отдел без сотрудника |
| Аномалия обновления | Нужно обновить одно и то же значение в нескольких строках | Переименовали отдел — нужно обновить 1000 строк |
| Аномалия удаления | Удаление строки приводит к потере несвязанной информации | Удалили последнего сотрудника — потеряли информацию об отделе |

### Денормализация

Денормализация — это **сознательное** нарушение нормальных форм ради производительности чтения. Примеры:
- Добавление вычисляемого столбца (например, `order_total` в таблице заказов вместо SUM по позициям).
- Хранение имени пользователя прямо в таблице заказов для избежания JOIN.
- Материализованные представления (MATERIALIZED VIEW) — автоматическая денормализация.

```sql
-- Пример: денормализованный счётчик
ALTER TABLE posts ADD COLUMN comments_count INT DEFAULT 0;

-- Обновляется триггером или в коде приложения
UPDATE posts SET comments_count = comments_count + 1 WHERE id = :post_id;

-- Теперь не нужен COUNT(*) с JOIN для отображения числа комментариев
```

### Практические рекомендации

1. **Для OLTP-систем** (транзакционная обработка) нормализуйте до 3NF/BCNF — это уменьшает размер данных и предотвращает несогласованность.
2. **Для OLAP-систем** (аналитика) часто используется денормализация: star schema, snowflake schema — для ускорения агрегатных запросов.
3. **Денормализация — это техдолг**: вы ускоряете чтение, но усложняете запись и рискуете несогласованностью. Всегда документируйте, почему и где вы денормализовали.
4. Начинайте проектирование с нормализованной схемы и денормализуйте только по результатам **реального профилирования** — преждевременная денормализация создаёт больше проблем, чем решает.

## Примеры
```text
До: orders(id, user_name, user_email, total)
Проблема: дублируем имя/email у каждого заказа.

После:
users(id, name, email)
orders(id, user_id, total)
-- устранили повторяющиеся данные, убрали аномалии обновлений
```

## Доп. теория
- Нормальные формы — это инструмент, а не религия: иногда полезнее осознанная денормализация.
- В аналитике часто используют star/snowflake схемы, жертвуя чистой нормализацией ради скорости чтения.
