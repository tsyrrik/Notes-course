## Вопрос: ACID

## Простой ответ
- Транзакция либо проходит целиком, либо откатывается, не нарушает ограничения, изолирована от чужих незавершённых данных и не теряется после коммита.

Пример транзакции — ниже в секции «Примеры».

## Ответ

### Atomicity (Атомарность)

Атомарность гарантирует, что транзакция выполняется как **единая неделимая операция**: либо все её изменения применяются, либо ни одно. Если в середине транзакции происходит ошибка (сбой приложения, нарушение ограничения, потеря соединения), все уже выполненные операции внутри этой транзакции откатываются (ROLLBACK). В PostgreSQL атомарность реализована через механизм **WAL (Write-Ahead Log)** и систему управления транзакциями (CLOG). Каждая операция сначала записывается в журнал, и при сбое система при восстановлении определяет, какие транзакции были закоммичены, а какие — нет, и откатывает незавершённые.

```sql
BEGIN;
UPDATE accounts SET balance = balance - 500 WHERE id = 1;
-- Представим, что здесь произошёл сбой сервера
UPDATE accounts SET balance = balance + 500 WHERE id = 2;
COMMIT;
-- Если сбой до COMMIT — обе операции откатятся.
-- Деньги не исчезнут и не появятся «из ниоткуда».
```

PostgreSQL также поддерживает **SAVEPOINT** — точки сохранения внутри транзакции, позволяющие откатиться к промежуточному состоянию без отмены всей транзакции:

```sql
BEGIN;
INSERT INTO orders (user_id, total) VALUES (1, 100);
SAVEPOINT sp1;
INSERT INTO order_items (order_id, product_id) VALUES (1, 999); -- ошибка: product не существует
ROLLBACK TO SAVEPOINT sp1; -- откат только до savepoint
INSERT INTO order_items (order_id, product_id) VALUES (1, 1);   -- корректная вставка
COMMIT;
```

### Consistency (Согласованность)

Согласованность означает, что транзакция переводит базу данных из одного **валидного состояния** в другое. Все определённые правила целостности — PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL, триггеры — должны выполняться после завершения транзакции. Если транзакция нарушает любое ограничение, она будет отменена.

Важно понимать, что согласованность — это **совместная ответственность** СУБД и приложения. СУБД гарантирует соблюдение декларативных ограничений, но бизнес-логику (например, «баланс не может быть отрицательным») нужно явно выражать через CHECK-ограничения или код приложения:

```sql
ALTER TABLE accounts ADD CONSTRAINT positive_balance CHECK (balance >= 0);

BEGIN;
UPDATE accounts SET balance = balance - 1000 WHERE id = 1;
-- Если balance станет < 0, CHECK сработает,
-- транзакция будет прервана с ошибкой
COMMIT;
```

### Isolation (Изоляция)

Изоляция определяет, насколько параллельные транзакции «видят» изменения друг друга. Без изоляции одна транзакция могла бы прочитать промежуточные (ещё не закоммиченные) данные другой, что привело бы к некорректным результатам. SQL-стандарт определяет четыре уровня изоляции: Read Uncommitted, Read Committed, Repeatable Read и Serializable. PostgreSQL по умолчанию использует **Read Committed** — каждый оператор внутри транзакции видит только данные, закоммиченные до его начала.

Изоляция в PostgreSQL реализована через **MVCC (Multi-Version Concurrency Control)** — механизм, при котором каждая транзакция работает со своим «снимком» (snapshot) данных. Благодаря этому читатели не блокируют писателей и наоборот, что обеспечивает высокую производительность при конкурентном доступе.

### Durability (Долговечность)

Долговечность гарантирует, что после успешного COMMIT данные **не будут потеряны** даже при аварийном завершении: отключение питания, сбой ОС, крах процесса. PostgreSQL обеспечивает это через **WAL (Write-Ahead Logging)**: перед тем как изменения попадут в файлы данных, они записываются в журнал транзакций на диске. При восстановлении после сбоя PostgreSQL «проигрывает» WAL и восстанавливает все закоммиченные транзакции.

Параметр `synchronous_commit` контролирует, ждёт ли COMMIT физической записи WAL на диск. По умолчанию — `on` (полная гарантия durability). Для некритичных данных можно установить `off`, что ускоряет запись, но создаёт окно потери данных в несколько миллисекунд при сбое.

### Как ACID связаны между собой

| Свойство | Что гарантирует | Механизм в PostgreSQL |
|----------|----------------|----------------------|
| Atomicity | Всё или ничего | WAL, CLOG, ROLLBACK |
| Consistency | Валидное состояние | Constraints, triggers |
| Isolation | Параллельные транзакции не мешают | MVCC, уровни изоляции |
| Durability | Данные не теряются после COMMIT | WAL, fsync |

### Практические советы

1. **Держите транзакции короткими** — длинные транзакции удерживают снимки, мешают VACUUM и увеличивают вероятность deadlock.
2. **Используйте явные ограничения** (CHECK, FK, UNIQUE) — это часть Consistency, и лучше ловить ошибки на уровне СУБД, чем в коде.
3. **Не отключайте `synchronous_commit` для финансовых данных** — экономия на скорости не стоит риска потери транзакций.
4. **При retry-логике** (Serializable isolation) помните, что повтор транзакции — это норма, а не баг. Оборачивайте транзакционный код в цикл с обработкой serialization_failure.

## Примеры
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT; -- либо оба UPDATE, либо ROLLBACK
```

```sql
BEGIN;
INSERT INTO orders (user_id, total) VALUES (1, 100);
SAVEPOINT sp1;
INSERT INTO order_items (order_id, product_id) VALUES (1, 999); -- ошибка
ROLLBACK TO SAVEPOINT sp1;
INSERT INTO order_items (order_id, product_id) VALUES (1, 1);
COMMIT;
```

## Доп. теория
- ACID гарантируется транзакционным движком, но «согласованность» часто зависит и от бизнес‑логики приложения.
- На практике сильная durability может быть ослаблена ради скорости (например, async commit), но это осознанный компромисс.
