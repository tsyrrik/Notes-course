## Вопрос: Внешние ключи

## Простой ответ
- Гарантируют, что ссылка указывает на существующую строку.
- Могут каскадно удалять/обновлять или запрещать операции.
Плюсы: целостность данных. Минусы: накладные расходы на проверки.

Пример — в конце.

## Ответ

### Что такое внешний ключ

Внешний ключ (Foreign Key, FK) — это ограничение целостности (constraint), которое связывает столбец (или набор столбцов) одной таблицы с первичным ключом или уникальным ключом другой таблицы. FK гарантирует ссылочную целостность (referential integrity): невозможно вставить значение, которое не существует в родительской таблице, и невозможно удалить строку из родительской таблицы, если на неё ссылаются дочерние строки (без специальных правил).

```sql
CREATE TABLE users (
  id serial PRIMARY KEY,
  name text NOT NULL
);

CREATE TABLE orders (
  id serial PRIMARY KEY,
  user_id int NOT NULL REFERENCES users(id),  -- FK
  total numeric NOT NULL
);

-- Попытка вставить заказ несуществующему пользователю
INSERT INTO orders (user_id, total) VALUES (999, 100.00);
-- ERROR: insert or update on table "orders" violates foreign key constraint
-- Key (user_id)=(999) is not present in table "users".
```

### Действия при удалении и обновлении

При определении FK можно указать, что происходит при удалении (`ON DELETE`) или обновлении (`ON UPDATE`) ссылаемой строки в родительской таблице:

| Действие | ON DELETE | ON UPDATE | Описание |
|---|---|---|---|
| `RESTRICT` | Запретить удаление | Запретить обновление | Выбрасывает ошибку сразу |
| `NO ACTION` | Запретить (по умолчанию) | Запретить (по умолчанию) | Проверка откладывается до конца транзакции |
| `CASCADE` | Удалить дочерние строки | Обновить FK в дочерних строках | Каскадное распространение |
| `SET NULL` | Установить FK = NULL | Установить FK = NULL | Столбец должен быть nullable |
| `SET DEFAULT` | Установить FK = DEFAULT | Установить FK = DEFAULT | Должно быть DEFAULT-значение |

```sql
-- CASCADE: удаление пользователя удалит все его заказы
CREATE TABLE orders (
  id serial PRIMARY KEY,
  user_id int REFERENCES users(id) ON DELETE CASCADE,
  total numeric
);

-- SET NULL: при удалении пользователя заказы останутся, но user_id станет NULL
CREATE TABLE orders (
  id serial PRIMARY KEY,
  user_id int REFERENCES users(id) ON DELETE SET NULL,
  total numeric
);

-- RESTRICT: нельзя удалить пользователя, пока есть заказы
CREATE TABLE orders (
  id serial PRIMARY KEY,
  user_id int REFERENCES users(id) ON DELETE RESTRICT,
  total numeric
);
```

### RESTRICT vs NO ACTION

Оба запрещают удаление/обновление, но различаются моментом проверки:

- **RESTRICT** — проверяется немедленно, до выполнения других триггеров и действий в транзакции.
- **NO ACTION** (default) — проверяется в конце оператора (или транзакции, если FK объявлен как `DEFERRABLE`).

Разница важна при использовании триггеров: с NO ACTION триггер может удалить дочерние строки до проверки FK, и ошибки не будет. С RESTRICT проверка произойдёт раньше триггера.

```sql
-- Отложенная проверка FK (полезно при циклических зависимостях)
CREATE TABLE departments (
  id serial PRIMARY KEY,
  head_id int REFERENCES employees(id) DEFERRABLE INITIALLY DEFERRED
);
-- Проверка FK откладывается до COMMIT, позволяя вставлять данные в любом порядке
```

### Индексы и производительность FK

Критический момент: **PostgreSQL НЕ создаёт индекс на столбце FK автоматически** (в отличие от MySQL InnoDB, который создаёт). Отсутствие индекса на FK-столбце приводит к:

1. **Медленные JOIN** — без индекса на `orders.user_id` JOIN с таблицей users будет выполняться через Seq Scan.
2. **Медленные CASCADE DELETE** — при удалении пользователя PostgreSQL ищет все его заказы. Без индекса это Sequential Scan по таблице orders.
3. **Блокировки** — без индекса CASCADE-операции могут блокировать всю дочернюю таблицу.

```sql
-- ОБЯЗАТЕЛЬНО создавайте индекс на FK-столбце!
CREATE INDEX idx_orders_user_id ON orders (user_id);

-- Проверка: найти FK без индексов
SELECT
  conrelid::regclass AS table_name,
  conname AS fk_name,
  a.attname AS column_name
FROM pg_constraint c
JOIN pg_attribute a ON a.attrelid = c.conrelid AND a.attnum = ANY(c.conkey)
WHERE c.contype = 'f'
  AND NOT EXISTS (
    SELECT 1 FROM pg_index i
    WHERE i.indrelid = c.conrelid
      AND a.attnum = ANY(i.indkey)
  );
-- Все строки в результате — FK без индексов, нужно создать!
```

### Каскадное удаление: подводные камни

CASCADE DELETE удобен, но может быть опасен:

```sql
-- Цепочка CASCADE
-- users -> orders -> order_items -> order_item_options
-- Удаление одного пользователя каскадно удалит ВСЕ связанные данные
DELETE FROM users WHERE id = 1;
-- Может удалить тысячи строк из нескольких таблиц за одну операцию
-- Может заблокировать таблицы и вызвать таймауты
```

Рекомендации:
- Используйте CASCADE только для «владеющих» связей (user -> user_settings, order -> order_items).
- Для «ссылочных» связей (order -> user) используйте RESTRICT или SET NULL.
- В критичных системах используйте soft delete (флаг `deleted_at`) вместо CASCADE DELETE.

### FK и производительность записи

Каждая операция INSERT, UPDATE, DELETE на таблице с FK требует дополнительных проверок:

- **INSERT в дочернюю таблицу** — проверка, что значение FK существует в родительской таблице (lookup по PK/unique index родителя).
- **DELETE из родительской таблицы** — проверка/обработка дочерних строк.
- **UPDATE FK-столбца** — проверка нового значения + обработка старого.

На высоконагруженных системах с массовыми INSERT (логи, события, очереди) FK могут стать узким местом. В таких случаях иногда отказываются от FK на уровне СУБД и обеспечивают целостность на уровне приложения:

```sql
-- Подход 1: FK на уровне СУБД (безопасно, но медленнее)
CREATE TABLE events (
  id bigserial PRIMARY KEY,
  user_id int REFERENCES users(id),
  payload jsonb
);

-- Подход 2: без FK (быстрее, но без гарантий СУБД)
CREATE TABLE events (
  id bigserial PRIMARY KEY,
  user_id int NOT NULL,  -- без REFERENCES
  payload jsonb
);
CREATE INDEX idx_events_user_id ON events (user_id);
-- Целостность проверяется в коде приложения
```

### Самоссылающиеся FK

FK может ссылаться на ту же таблицу — полезно для иерархий:

```sql
CREATE TABLE categories (
  id serial PRIMARY KEY,
  name text NOT NULL,
  parent_id int REFERENCES categories(id) ON DELETE CASCADE
);

-- Корневая категория
INSERT INTO categories (name, parent_id) VALUES ('Electronics', NULL);
-- Дочерняя
INSERT INTO categories (name, parent_id) VALUES ('Laptops', 1);
```

### Практические рекомендации

1. **Всегда создавайте индекс на FK-столбце** — PostgreSQL не делает это автоматически.
2. **Выбирайте ON DELETE осознанно** — CASCADE удобен, но опасен для больших цепочек.
3. **Используйте DEFERRABLE** для циклических зависимостей или сложных миграций.
4. **Мониторьте блокировки** — CASCADE-операции на больших таблицах могут блокировать другие транзакции.
5. **На OLTP-системах с высокой нагрузкой** оценивайте, не является ли FK узким местом — иногда проверку целостности лучше перенести в приложение.

## Примеры
```sql
CREATE TABLE orders (
  id serial PRIMARY KEY,
  user_id int REFERENCES users(id) ON DELETE CASCADE,
  total numeric
);
-- удаление пользователя удалит его заказы
```

## Доп. теория
- FK — это ограничение целостности, а не «связь» на уровне приложения.
- В PostgreSQL индексы на FK‑колонках нужно создавать вручную.
