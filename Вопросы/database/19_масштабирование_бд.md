## Вопрос: Масштабирование БД

## Простой ответ
- Сначала усиливаем железо, потом добавляем реплики на чтение.
- Когда пишем много или данных слишком много — шардируем/партиционируем.
- Горячее кэшируем, но следим за консистентностью.

## Ответ

### Вертикальное масштабирование (Scale Up)

Самый простой подход — увеличить мощность **одного сервера**: больше CPU, RAM, быстрый SSD (NVMe). Не требует изменений в архитектуре приложения и работает «из коробки». Однако у вертикального масштабирования есть жёсткий **потолок** — максимальная конфигурация сервера ограничена, а стоимость растёт экспоненциально (удвоение производительности может стоить в 4 раза дороже).

Когда применять: на ранних стадиях проекта, при умеренной нагрузке. Часто бывает достаточно перейти с 4 ядер на 16 и с 16 GB RAM на 64 GB, чтобы решить проблему на год-два.

### Реплики для чтения (Read Replicas)

Когда нагрузка на чтение значительно превышает запись (а это 80-95% случаев для веб-приложений), создают **одну или несколько реплик**, которые принимают читающие запросы. Мастер (primary) обрабатывает запись, реплики получают изменения через **streaming replication** (PostgreSQL) или binlog (MySQL).

```
              ┌──────────────┐
  Запись ────▶│   Primary    │
              └──────┬───────┘
                     │ WAL streaming
              ┌──────┴───────┐
              ▼              ▼
        ┌──────────┐  ┌──────────┐
        │ Replica 1│  │ Replica 2│
        └──────────┘  └──────────┘
              ▲              ▲
              └──── Чтение ──┘
```

```sql
-- Настройка streaming replication в PostgreSQL (на primary):
-- postgresql.conf
-- wal_level = replica
-- max_wal_senders = 10

-- На реплике:
-- primary_conninfo = 'host=primary_host port=5432 user=replicator'
```

**Нюансы**:
- Репликация **асинхронная по умолчанию** — реплика может отставать на миллисекунды-секунды (replication lag). Для критичных чтений после записи используйте синхронную репликацию или читайте с мастера.
- Балансировка чтения: через pgBouncer, HAProxy или на уровне приложения.

### Шардирование (Sharding)

Шардирование — это **горизонтальное разделение данных** между несколькими независимыми серверами (шардами). Каждый шард содержит подмножество данных. В отличие от реплик, шарды содержат **разные данные**, что позволяет масштабировать и запись, и хранение.

**Стратегии шардирования**:

| Стратегия | Описание | Пример |
|-----------|----------|--------|
| По диапазону (Range) | Данные делятся по диапазону ключа | user_id 1-1M → шард 1, 1M-2M → шард 2 |
| По хешу (Hash) | hash(key) % N определяет шард | hash(user_id) % 4 → шард 0-3 |
| По справочнику (Directory) | Таблица маппинга ключ → шард | Гибко, но доп. запрос |
| По географии | Данные по регионам | EU → шард 1, US → шард 2 |

**Проблемы шардирования**:
- **Cross-shard запросы** — JOIN между шардами очень дорогой.
- **Ребалансировка** — добавление нового шарда требует перемещения данных.
- **Распределённые транзакции** — ACID между шардами сложен (2PC).
- **Уникальность глобальных ID** — нужны UUID или генераторы последовательностей (Snowflake ID).

### Партиционирование (Partitioning)

Партиционирование — разделение **одной большой таблицы** на несколько физических частей (партиций) **внутри одного сервера**. Не путать с шардированием — данные остаются в одной СУБД и доступны через единый запрос.

```sql
-- Партиционирование по диапазону дат
CREATE TABLE orders (
    id BIGSERIAL,
    user_id INT,
    amount NUMERIC,
    created_at TIMESTAMP
) PARTITION BY RANGE (created_at);

CREATE TABLE orders_2024_q1 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');
CREATE TABLE orders_2024_q2 PARTITION OF orders
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');

-- Запрос автоматически сканирует только нужные партиции (partition pruning)
SELECT * FROM orders WHERE created_at >= '2024-03-01' AND created_at < '2024-04-01';
-- PostgreSQL читает только orders_2024_q1
```

**Типы партиционирования в PostgreSQL**:
- `RANGE` — по диапазону (даты, числа) — самый популярный.
- `LIST` — по конкретным значениям (страна, статус).
- `HASH` — по хешу ключа (равномерное распределение).

### Кеширование (Caching)

Кеширование горячих данных в **Redis** или **Memcached** кардинально снижает нагрузку на БД. Типичные паттерны:

```
1. Cache-Aside (Lazy Loading):
   Приложение → проверяет кеш → если нет → читает из БД → кладёт в кеш

2. Write-Through:
   Приложение → пишет в кеш И в БД одновременно

3. Write-Behind:
   Приложение → пишет в кеш → кеш асинхронно пишет в БД
```

```python
# Пример Cache-Aside с Redis (Python)
import redis, json

r = redis.Redis()

def get_user(user_id):
    cached = r.get(f"user:{user_id}")
    if cached:
        return json.loads(cached)

    user = db.execute("SELECT * FROM users WHERE id = %s", (user_id,))
    r.setex(f"user:{user_id}", 3600, json.dumps(user))  # TTL 1 час
    return user
```

**Проблемы кеширования**: инвалидация кеша (когда данные обновились), cache stampede (при истечении TTL множество запросов идут в БД одновременно), консистентность.

### Connection Pooling

Часто забываемый, но эффективный способ масштабирования — **пулинг соединений**. PostgreSQL создаёт отдельный процесс на каждое соединение, что дорого. PgBouncer или встроенный пул (pgpool-II) уменьшают число реальных соединений:

```
100 приложений × 10 соединений = 1000 → PgBouncer → 50 реальных соединений к PostgreSQL
```

### Порядок масштабирования (рекомендация)

```
1. Оптимизация запросов (EXPLAIN, индексы)     — бесплатно
2. Connection pooling (PgBouncer)               — просто
3. Вертикальное масштабирование (больше RAM/CPU) — просто, но дорого
4. Кеширование (Redis)                          — умеренная сложность
5. Read replicas                                 — умеренная сложность
6. Партиционирование                            — изменение схемы
7. Шардирование                                  — значительная сложность
```

### Практические советы

1. **Не шардируйте преждевременно** — 90% проектов никогда не дорастут до необходимости шардирования. Начните с оптимизации и реплик.
2. **Выбирайте ключ шардирования тщательно** — плохой ключ приводит к «горячим» шардам (hot spots). Хороший ключ — тот, по которому идут большинство запросов (обычно user_id или tenant_id).
3. **Мониторьте replication lag** — если реплика отстаёт на секунды, пользователь может не увидеть только что созданные данные.
4. **Партиционирование + pg_partman** — автоматическое создание новых партиций по расписанию.
5. **Материализованные представления** — промежуточный вариант между нормализованной схемой и денормализацией для тяжёлых аналитических запросов.

## Примеры
```sql
-- Пример партиционирования по дате
CREATE TABLE events (
  id BIGSERIAL,
  created_at DATE
) PARTITION BY RANGE (created_at);
```

## Доп. теория
- Масштабирование — это не только инфраструктура, но и качество запросов/схемы.
- Реплики дают масштабирование чтения, шардирование — записи и объёма данных.
