## Вопрос: B-Tree устройство и скорость

## Простой ответ
- Дерево поиска: за логарифм шагов находим нужный ключ.
- Универсальный индекс для равенства, диапазонов и сортировки.

Примеры — в конце.

## Ответ

### Структура B-Tree

B-Tree (Balanced Tree, точнее B+ Tree в большинстве СУБД) — это сбалансированное дерево поиска, в котором все листовые узлы находятся на одном уровне. Структура состоит из трёх типов узлов:

- **Корневой узел (root)** — верхний узел дерева, от которого начинается поиск.
- **Внутренние узлы (internal/branch nodes)** — содержат ключи и указатели на дочерние узлы. Ключи разделяют пространство значений на диапазоны.
- **Листовые узлы (leaf nodes)** — содержат ключи и указатели на реальные строки таблицы (tuple ID / row pointer). В B+ Tree листья связаны между собой двусвязным списком, что позволяет эффективно обходить диапазоны.

```
          [  50  |  100  ]           <- корень
         /       |        \
   [10|30]    [60|80]    [110|150]   <- внутренние узлы
   / | \      / | \       / | \
  L1 L2 L3  L4 L5 L6   L7 L8 L9    <- листья (связаны между собой ->)
```

### Почему именно B-Tree, а не бинарное дерево

Обычное бинарное дерево поиска (BST) имеет по 2 потомка на узел. При миллионе записей глубина дерева ~20. Каждый переход — это обращение к диску (random I/O). B-Tree имеет высокий порядок ветвления (fanout): каждый узел содержит сотни ключей (определяется размером страницы, обычно 8 KB в PostgreSQL). Это даёт глубину дерева 3-4 даже для таблиц с сотнями миллионов строк.

| Количество строк | Глубина B-Tree (fanout ~500) | Количество I/O |
|---|---|---|
| 1 000 | 1-2 | 1-2 |
| 1 000 000 | 2-3 | 2-3 |
| 1 000 000 000 | 3-4 | 3-4 |

Таким образом, даже на таблице в миллиард строк поиск по индексу требует всего 3-4 обращения к диску. Корневой и часто используемые внутренние узлы обычно кешируются в памяти, поэтому реально с диска читается 1-2 страницы.

### Сложность операций

- **Поиск (точный):** O(log_b n), где b — порядок ветвления. На практике 2-4 шага.
- **Поиск (диапазон):** O(log_b n + k), где k — количество найденных строк. После нахождения начала диапазона проход по связному списку листьев.
- **Вставка:** O(log_b n). Если лист заполнен — происходит split (расщепление): лист делится на два, средний ключ поднимается в родительский узел.
- **Удаление:** O(log_b n). Если лист слишком пуст — происходит merge (слияние) с соседним узлом.

### Какие запросы ускоряет B-Tree

```sql
-- Точное равенство
SELECT * FROM users WHERE id = 42;

-- Диапазон
SELECT * FROM orders WHERE created_at BETWEEN '2024-01-01' AND '2024-03-31';

-- Сравнения
SELECT * FROM products WHERE price > 1000;

-- Сортировка (данные уже упорядочены в индексе)
SELECT * FROM orders ORDER BY created_at DESC LIMIT 20;

-- MIN / MAX (крайний лист дерева)
SELECT MIN(created_at) FROM orders;  -- мгновенно, читает один лист

-- LIKE с префиксом
SELECT * FROM users WHERE name LIKE 'Ivan%';

-- IS NULL (в PostgreSQL NULL входит в B-Tree; в Oracle — нет!)
SELECT * FROM users WHERE deleted_at IS NULL;
```

### Чего B-Tree НЕ может

```sql
-- LIKE с паттерном не в начале — полный скан
SELECT * FROM users WHERE name LIKE '%ivan%';

-- Функция от столбца — индекс не используется
SELECT * FROM users WHERE LOWER(email) = 'user@example.com';
-- Решение: функциональный индекс
CREATE INDEX idx_users_email_lower ON users (LOWER(email));

-- Поиск по выражению
SELECT * FROM orders WHERE total * 0.9 > 1000;
-- Решение: переписать условие
SELECT * FROM orders WHERE total > 1000 / 0.9;
```

### Фрагментация и обслуживание

После множества UPDATE и DELETE в B-Tree остаются «мёртвые» записи и полупустые страницы. Это увеличивает размер индекса и снижает производительность. В PostgreSQL VACUUM помечает мёртвые записи как доступные для повторного использования, но не уменьшает физический размер индекса. Для полной перестройки используйте:

```sql
-- Перестроить индекс (блокирует таблицу)
REINDEX INDEX idx_users_email;

-- Перестроить без блокировки (PostgreSQL 12+)
REINDEX INDEX CONCURRENTLY idx_users_email;

-- Проверить bloat (раздутие) индекса
SELECT
  indexrelname,
  pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,
  idx_scan AS times_used
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;
```

### Особенности B-Tree в разных СУБД

В **PostgreSQL** B-Tree поддерживает NULL, мультиверсионность (каждая версия строки видна в индексе), дедупликацию (PostgreSQL 13+, одинаковые ключи хранятся один раз). В **MySQL InnoDB** первичный ключ — это кластеризованный B-Tree (clustered index), и все данные таблицы физически хранятся в порядке PRIMARY KEY. Вторичные индексы хранят значение первичного ключа вместо указателя на строку, поэтому при использовании вторичного индекса происходит дополнительный lookup в кластеризованный индекс.

## Примеры
```sql
CREATE INDEX idx_users_name ON users (name);
```

```sql
CREATE INDEX idx_orders_created_at ON orders (created_at DESC);
SELECT id FROM orders ORDER BY created_at DESC LIMIT 20;
-- план: Index Only Scan по idx_orders_created_at (если покрывает запрос)
```

## Доп. теория
- Большинство СУБД используют B+Tree: все значения лежат в листьях, а внутренние узлы хранят только ключи.
- Эффективность B‑Tree зависит от селективности и физической локальности данных.
