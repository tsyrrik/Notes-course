## Вопрос: Уровни изоляции и аномалии

## Простой ответ
- Чем выше уровень, тем меньше аномалий, но больше риск блокировок/ретраев.
- Read Committed — дефолт в PostgreSQL; Repeatable Read/Serializable — для денег/отчётов, но готовьтесь к retry.

Пример установки уровня — ниже в секции «Примеры».

## Ответ

### Что такое уровни изоляции

Уровни изоляции определяют, какие **аномалии** (побочные эффекты параллельного выполнения) допускаются при одновременной работе нескольких транзакций. Чем выше уровень изоляции, тем строже гарантии корректности, но тем выше накладные расходы: блокировки, откаты, повторные попытки. SQL-стандарт определяет четыре уровня, PostgreSQL поддерживает три реальных (Read Uncommitted работает как Read Committed).

### Аномалии параллельного доступа

**Dirty Read (грязное чтение)** — транзакция читает данные, которые другая транзакция изменила, но ещё не закоммитила. Если та транзакция откатится, прочитанные данные окажутся «мусором». В PostgreSQL грязные чтения **невозможны** на любом уровне изоляции благодаря MVCC.

**Non-repeatable Read (неповторяемое чтение)** — транзакция читает одну и ту же строку дважды и получает разные значения, потому что другая транзакция успела её изменить и закоммитить между чтениями.

**Phantom Read (фантомное чтение)** — транзакция повторяет запрос с WHERE-условием и получает другой набор строк, потому что другая транзакция вставила или удалила подходящие строки.

**Serialization Anomaly** — результат параллельного выполнения не соответствует никакому последовательному порядку (например, write skew).

### Таблица уровней изоляции

| Уровень | Dirty Read | Non-repeatable Read | Phantom Read | Serialization Anomaly |
|---------|-----------|--------------------|--------------|-----------------------|
| Read Uncommitted* | Нет (в PG) | Да | Да | Да |
| Read Committed | Нет | Да | Да | Да |
| Repeatable Read | Нет | Нет | Нет (в PG) | Да |
| Serializable | Нет | Нет | Нет | Нет |

*В PostgreSQL Read Uncommitted идентичен Read Committed.

### Read Committed (уровень по умолчанию)

Каждый **отдельный оператор** внутри транзакции видит снимок данных на момент начала этого оператора. Если другая транзакция закоммитила изменения между двумя вашими SELECT — вы увидите разные результаты. Это самый популярный уровень, потому что он обеспечивает хороший баланс между производительностью и корректностью.

```sql
-- Транзакция 1                          -- Транзакция 2
BEGIN;                                    BEGIN;
SELECT balance FROM accounts WHERE id=1;
-- balance = 1000
                                          UPDATE accounts SET balance = 500 WHERE id=1;
                                          COMMIT;
SELECT balance FROM accounts WHERE id=1;
-- balance = 500 (изменилось!)
COMMIT;
```

### Repeatable Read

Транзакция видит **снимок данных на момент первого не-транзакционного оператора** (первого SELECT, UPDATE и т.д.). Все последующие операторы видят тот же снимок, независимо от того, что коммитят другие транзакции. В PostgreSQL на этом уровне фантомы тоже не проявляются (в отличие от стандарта SQL, где они допускаются).

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
SELECT SUM(balance) FROM accounts;  -- снимок зафиксирован
-- Другая транзакция добавляет строку и коммитит
SELECT SUM(balance) FROM accounts;  -- тот же результат, новая строка не видна
COMMIT;
```

Если на уровне Repeatable Read ваша транзакция пытается обновить строку, которую уже изменила и закоммитила другая транзакция, PostgreSQL выбросит ошибку: `ERROR: could not serialize access due to concurrent update`. Нужно поймать эту ошибку и **повторить транзакцию**.

### Serializable

Самый строгий уровень — гарантирует, что результат параллельного выполнения эквивалентен **некоторому последовательному порядку**. PostgreSQL использует механизм **SSI (Serializable Snapshot Isolation)**, отслеживая зависимости между транзакциями. Если обнаруживается потенциальная аномалия, одна из транзакций прерывается с ошибкой `serialization_failure`.

```sql
-- Пример write skew (без Serializable — баг, с Serializable — ошибка)
-- Правило: в отделе должен быть хотя бы 1 дежурный
-- Транзакция 1                                Транзакция 2
BEGIN ISOLATION LEVEL SERIALIZABLE;            BEGIN ISOLATION LEVEL SERIALIZABLE;
SELECT COUNT(*) FROM on_call WHERE dept='ER';  SELECT COUNT(*) FROM on_call WHERE dept='ER';
-- count = 2                                   -- count = 2
DELETE FROM on_call WHERE name='Alice';        DELETE FROM on_call WHERE name='Bob';
COMMIT;                                        COMMIT; -- ERROR: serialization_failure
-- Без Serializable обе транзакции прошли бы, и в отделе не осталось бы дежурных
```

### Реализация в PostgreSQL: MVCC

PostgreSQL реализует изоляцию через **MVCC (Multi-Version Concurrency Control)**. Каждая строка хранит идентификаторы транзакций, которые её создали (`xmin`) и удалили (`xmax`). Читающие транзакции видят только те версии строк, которые были закоммичены до начала их снимка. Благодаря этому **читатели никогда не блокируют писателей**, а писатели — читателей. Блокировки возникают только при конфликте двух пишущих транзакций на одну строку.

### Практические рекомендации

1. **Read Committed** подходит для большинства OLTP-задач: веб-приложения, CRUD-операции, где допустимы неповторяемые чтения.
2. **Repeatable Read** используйте для отчётов, которые должны видеть консистентный снимок данных, а также для операций, где неповторяемое чтение критично (финансовые расчёты).
3. **Serializable** нужен, когда бизнес-логика зависит от инвариантов, проверяемых SELECT-ами (write skew). Всегда реализуйте **retry-цикл**:

```python
import psycopg2

for attempt in range(5):
    try:
        with conn:
            with conn.cursor() as cur:
                cur.execute("SET TRANSACTION ISOLATION LEVEL SERIALIZABLE")
                # ... бизнес-логика ...
        break  # успех
    except psycopg2.errors.SerializationFailure:
        continue  # повтор
```

4. **Не смешивайте уровни изоляции** в рамках одного бизнес-процесса — все участвующие транзакции должны работать на одном уровне, иначе гарантии не работают.
5. Помните: повышение уровня изоляции не замедляет запросы само по себе — оно увеличивает вероятность **откатов и повторов**, что влияет на throughput при высокой конкуренции.

## Примеры
```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
SELECT * FROM products WHERE id = 1; -- повторный SELECT вернёт такой же снапшот
COMMIT;
```

## Доп. теория
- В PostgreSQL `READ UNCOMMITTED` работает как `READ COMMITTED`.
- Serializable в PostgreSQL реализован через SSI: возможны `serialization_failure`, их нужно обрабатывать повтором транзакции.
