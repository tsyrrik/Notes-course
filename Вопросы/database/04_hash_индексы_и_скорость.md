## Вопрос: Hash индексы и скорость

## Простой ответ
- Хороши только для `=` по конкретному значению.
- Бесполезны для `<`, `>`, `ORDER BY` и префиксных LIKE.

Примеры — в конце.

## Ответ

### Принцип работы hash-индекса

Hash-индекс основан на хэш-таблице. При индексировании значение ключа пропускается через хэш-функцию, которая вычисляет номер bucket (корзины). В этот bucket записывается указатель на строку таблицы. При поиске значение из WHERE-условия также хэшируется, и СУБД сразу переходит к нужному bucket, не проходя по дереву.

```
Значение ключа     hash()      Bucket       Строки таблицы
─────────────      ──────      ──────       ──────────────
"token_abc"   -->  hash() = 7  [bucket 7]   -> row 42, row 198
"token_xyz"   -->  hash() = 3  [bucket 3]   -> row 5
"token_def"   -->  hash() = 7  [bucket 7]   -> row 42 (коллизия!)
```

### Сложность операций

| Операция | B-Tree | Hash |
|---|---|---|
| Точное равенство `=` | O(log n) ~3-4 I/O | O(1) ~1-2 I/O |
| Диапазон `<, >, BETWEEN` | O(log n + k) | **Не поддерживается** |
| Сортировка `ORDER BY` | Бесплатно (данные упорядочены) | **Не поддерживается** |
| `LIKE 'prefix%'` | Да | **Нет** |
| `IS NULL` | Да (PostgreSQL) | **Нет** |
| `MIN` / `MAX` | O(1) — крайний лист | **Нет** |

Теоретическое преимущество O(1) vs O(log n) на практике невелико: для таблицы в 100 млн строк B-Tree требует 3-4 обращения к страницам, из которых 2-3 обычно в кеше. Поэтому реальная разница — 1-2 random I/O, что составляет единицы микросекунд на SSD.

### Коллизии

Коллизия — ситуация, когда разные значения ключа дают одинаковый хэш. В этом случае в одном bucket оказывается несколько записей. СУБД перебирает их линейно, сравнивая оригинальные значения. При большом числе коллизий производительность деградирует до O(n). Хорошая хэш-функция минимизирует коллизии, но полностью избежать их невозможно.

### Когда hash-индекс полезен

Hash-индекс имеет смысл в узком наборе сценариев:

1. **Lookup по длинным ключам** — UUID, токены, API-ключи длиной 64+ символов. Hash-индекс хранит фиксированный 4-байтовый хэш вместо полного значения, экономя место.
2. **Только equality-запросы** — если по столбцу никогда не делают диапазонных запросов и сортировок.
3. **Высокая нагрузка на точные совпадения** — когда даже разница в 1 I/O имеет значение при миллионах запросов в секунду.

```sql
-- Хороший кандидат: токены сессий (только = запросы, длинные строки)
CREATE INDEX idx_sessions_token ON sessions USING hash (token);

-- Плохой кандидат: дата создания (нужны диапазоны)
-- CREATE INDEX idx_orders_date ON orders USING hash (created_at);  -- НЕ ДЕЛАЙТЕ ТАК
```

### История hash-индексов в PostgreSQL

До PostgreSQL 10 hash-индексы не записывались в WAL (Write-Ahead Log), а значит не реплицировались и не восстанавливались после сбоя. Их использование было фактически запрещено в production. Начиная с PostgreSQL 10, hash-индексы полностью WAL-logged и безопасны. В PostgreSQL 11+ они ещё и занимают меньше места при большом числе дубликатов. Несмотря на это, на практике B-Tree остаётся предпочтительным выбором в подавляющем большинстве случаев.

### Hash-индексы в MySQL

В MySQL hash-индексы доступны только в движке MEMORY (HEAP). InnoDB не поддерживает явные hash-индексы. Однако InnoDB использует Adaptive Hash Index (AHI) — автоматический механизм, который строит hash-индекс в памяти поверх часто используемых страниц B-Tree. AHI управляется автоматически и не требует действий DBA.

```sql
-- MySQL: hash-индекс только для MEMORY engine
CREATE TABLE cache (
  key_val VARCHAR(255),
  data TEXT,
  INDEX USING HASH (key_val)
) ENGINE = MEMORY;
```

### Практические рекомендации

- В 95% случаев **используйте B-Tree**, даже для точного равенства — разница в скорости минимальна, а гибкость значительно выше.
- Рассматривайте hash-индекс, если: столбец содержит длинные строки (100+ символов), по нему делают только `=` запросы, и вы хотите сэкономить дисковое пространство.
- Всегда измеряйте реальную производительность с помощью `EXPLAIN (ANALYZE, BUFFERS)` перед тем, как выбирать между B-Tree и Hash.

```sql
-- Сравнение размеров (пример на таблице 10M строк с UUID-ключом)
CREATE INDEX idx_btree ON tokens USING btree (token_value);
CREATE INDEX idx_hash  ON tokens USING hash  (token_value);

SELECT pg_size_pretty(pg_relation_size('idx_btree'));  -- ~750 MB
SELECT pg_size_pretty(pg_relation_size('idx_hash'));   -- ~320 MB
-- Hash занимает вдвое меньше места для длинных ключей
```

## Примеры
```sql
CREATE INDEX idx_sessions_token_hash ON sessions USING hash (token);
SELECT * FROM sessions WHERE token = 'abc123';
```

```sql
CREATE INDEX idx_api_keys_hash ON api_keys USING hash (key);
EXPLAIN SELECT id FROM api_keys WHERE key = 'k_123';
```

## Доп. теория
- Hash‑индекс не поддерживает порядок, поэтому не помогает `ORDER BY` и диапазонам.
- В большинстве случаев B‑Tree остаётся более универсальным и предсказуемым выбором.
