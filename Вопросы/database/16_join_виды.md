## Вопрос: JOIN виды

## Простой ответ
- INNER — только пересечение.
- LEFT/RIGHT — вся левая/правая таблица плюс совпадения.
- FULL — объединение обеих сторон.
- CROSS — декартово произведение.

Пример — в конце.

## Ответ

### Что такое JOIN

JOIN — операция соединения строк из двух (или более) таблиц на основе связанного условия. Это фундаментальная операция реляционных баз данных, позволяющая получать связанные данные, хранящиеся в нормализованных таблицах. Тип JOIN определяет, какие строки попадут в результат при отсутствии совпадений.

### INNER JOIN

Возвращает только те строки, для которых есть совпадение **в обеих таблицах**. Если для строки из левой таблицы нет пары в правой — она не попадёт в результат (и наоборот).

```sql
SELECT u.name, o.id AS order_id, o.amount
FROM users u
INNER JOIN orders o ON o.user_id = u.id;
-- Пользователи без заказов НЕ попадут в результат
-- Заказы без пользователей тоже НЕ попадут
```

### LEFT JOIN (LEFT OUTER JOIN)

Возвращает **все строки из левой таблицы** и совпадающие строки из правой. Если для строки из левой таблицы нет пары — столбцы правой таблицы заполняются NULL.

```sql
SELECT u.name, o.id AS order_id, o.amount
FROM users u
LEFT JOIN orders o ON o.user_id = u.id;
-- Все пользователи, даже без заказов (order_id и amount будут NULL)
```

Типичное применение — найти записи **без** связей:
```sql
-- Пользователи, у которых нет ни одного заказа
SELECT u.name
FROM users u
LEFT JOIN orders o ON o.user_id = u.id
WHERE o.id IS NULL;
```

### RIGHT JOIN (RIGHT OUTER JOIN)

Зеркальная версия LEFT JOIN — возвращает **все строки из правой таблицы**. На практике используется редко, потому что любой RIGHT JOIN можно переписать как LEFT JOIN, поменяв таблицы местами. Большинство команд придерживается конвенции использовать только LEFT JOIN для единообразия.

```sql
-- Эквивалентные запросы:
SELECT * FROM orders o RIGHT JOIN users u ON o.user_id = u.id;
SELECT * FROM users u LEFT JOIN orders o ON o.user_id = u.id;
```

### FULL JOIN (FULL OUTER JOIN)

Возвращает **все строки из обеих таблиц**. Если совпадение есть — строки соединяются. Если нет — отсутствующая сторона заполняется NULL.

```sql
SELECT u.name, o.id AS order_id
FROM users u
FULL JOIN orders o ON o.user_id = u.id;
-- Показывает: пользователей с заказами, пользователей без заказов,
-- и заказы без пользователей (если такие есть)
```

### CROSS JOIN

Декартово произведение — каждая строка левой таблицы соединяется с **каждой** строкой правой. Если в первой таблице N строк, а во второй M — результат содержит N × M строк. Используется редко и осторожно.

```sql
-- Генерация всех комбинаций размеров и цветов
SELECT s.size, c.color
FROM sizes s
CROSS JOIN colors c;
-- 3 размера × 4 цвета = 12 строк
```

### SELF JOIN

Это не отдельный тип JOIN, а паттерн — соединение таблицы **с самой собой**. Используется для иерархических данных или сравнения строк внутри одной таблицы.

```sql
-- Найти сотрудника и его менеджера
SELECT e.name AS employee, m.name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;

-- Найти пары пользователей из одного города
SELECT u1.name, u2.name, u1.city
FROM users u1
JOIN users u2 ON u1.city = u2.city AND u1.id < u2.id;
```

### Визуальная схема (диаграмма Венна)

```
INNER JOIN:        (A ∩ B)        — только пересечение
LEFT JOIN:         A + (A ∩ B)    — вся левая + пересечение
RIGHT JOIN:        (A ∩ B) + B    — пересечение + вся правая
FULL JOIN:         A + (A ∩ B) + B — всё из обеих таблиц
CROSS JOIN:        A × B          — каждый с каждым
```

### Условия ON vs WHERE в контексте JOIN

Важное различие для OUTER JOIN: условие в `ON` определяет, как строки соединяются, а `WHERE` фильтрует **итоговый результат**. Для INNER JOIN разницы нет, но для LEFT JOIN — принципиальная:

```sql
-- Все пользователи + их заказы за 2024 год (если есть)
SELECT u.name, o.id
FROM users u
LEFT JOIN orders o ON o.user_id = u.id AND o.created_at >= '2024-01-01';
-- Пользователи без заказов за 2024 год тоже покажутся (с NULL)

-- Только пользователи, у которых ЕСТЬ заказы за 2024 год
SELECT u.name, o.id
FROM users u
LEFT JOIN orders o ON o.user_id = u.id
WHERE o.created_at >= '2024-01-01';
-- LEFT JOIN здесь бессмысленно превращается в INNER JOIN из-за WHERE
```

### Производительность JOIN

PostgreSQL использует три алгоритма выполнения JOIN:

| Алгоритм | Когда эффективен | Описание |
|----------|-----------------|----------|
| Nested Loop | Малый внешний набор, индекс на внутреннем | Для каждой строки внешней таблицы ищет во внутренней |
| Hash Join | Средние/большие таблицы, достаточно памяти | Строит хеш-таблицу из меньшей таблицы |
| Merge Join | Обе таблицы отсортированы по ключу JOIN | Параллельный проход по двум отсортированным потокам |

Для оптимизации JOIN:
- Убедитесь, что столбцы в ON проиндексированы (особенно foreign key).
- Проверяйте план через EXPLAIN ANALYZE.
- Фильтруйте данные в WHERE до JOIN, чтобы уменьшить объём соединения.

### Множественные JOIN

В реальных запросах часто нужно соединить 3+ таблиц:

```sql
SELECT
    u.name,
    o.id AS order_id,
    p.title AS product,
    oi.quantity
FROM users u
JOIN orders o ON o.user_id = u.id
JOIN order_items oi ON oi.order_id = o.id
JOIN products p ON p.id = oi.product_id
WHERE o.created_at >= '2024-01-01'
ORDER BY u.name, o.id;
```

### Практические советы

1. **LEFT JOIN + WHERE IS NULL** — самый читаемый способ найти «сирот» (записи без связей). Альтернатива — `NOT EXISTS`, которая иногда быстрее.
2. **Избегайте RIGHT JOIN** — перепишите как LEFT JOIN для единообразия в кодовой базе.
3. **CROSS JOIN на больших таблицах** — потенциальная катастрофа. Всегда считайте ожидаемое количество строк.
4. **NATURAL JOIN** — соединяет по одноимённым столбцам. Опасен: при добавлении столбца с одинаковым именем запрос неявно меняет поведение. Не используйте в продакшн-коде.
5. **USING вместо ON** — если столбцы называются одинаково: `JOIN orders USING (user_id)` — более лаконично.

## Примеры
```sql
SELECT u.id, u.name, o.id AS order_id
FROM users u
LEFT JOIN orders o ON o.user_id = u.id;
```

## Доп. теория
- Для OUTER JOIN условия в `ON` и `WHERE` дают разный результат — это частая ловушка.
- `NOT EXISTS` часто лучше масштабируется, чем `LEFT JOIN ... IS NULL`.
