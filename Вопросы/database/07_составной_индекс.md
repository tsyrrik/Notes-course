## Вопрос: Составной индекс

## Простой ответ
- Порядок важен: движок читает индекс слева направо.
- Включайте в начало наиболее селективное и часто фильтруемое поле.

Пример — в конце.

## Ответ

### Что такое составной индекс

Составной индекс (composite / compound index) — это индекс, построенный по нескольким столбцам. Данные в B-Tree сортируются сначала по первому столбцу, затем — по второму внутри одинаковых значений первого, затем по третьему и т.д. Это аналогично сортировке телефонного справочника: сначала по фамилии, потом по имени, потом по отчеству.

```
Индекс (user_id, status, created_at):

user_id | status    | created_at
--------|-----------|------------
1       | active    | 2024-01-01
1       | active    | 2024-03-15
1       | inactive  | 2024-02-20
2       | active    | 2024-01-10
2       | inactive  | 2024-04-05
3       | active    | 2024-02-01
```

### Правило левого префикса (Leftmost Prefix Rule)

Это ключевое правило составных индексов: СУБД может использовать индекс только начиная с первого (левого) столбца. Индекс `(a, b, c)` может быть использован для:

| Условие WHERE | Использует индекс? | Примечание |
|---|---|---|
| `WHERE a = 1` | Да | Первый столбец |
| `WHERE a = 1 AND b = 2` | Да | Первые два столбца |
| `WHERE a = 1 AND b = 2 AND c = 3` | Да | Все три столбца |
| `WHERE b = 2` | Нет | Пропущен первый столбец |
| `WHERE c = 3` | Нет | Пропущены первые два столбца |
| `WHERE a = 1 AND c = 3` | Частично | Используется только `a`, `c` фильтруется через Filter |
| `WHERE b = 2 AND c = 3` | Нет | Пропущен первый столбец |

```sql
CREATE INDEX idx_orders_composite ON orders (user_id, status, created_at);

-- Использует индекс полностью
EXPLAIN SELECT * FROM orders
WHERE user_id = 5 AND status = 'paid' AND created_at > '2024-01-01';

-- Использует только user_id
EXPLAIN SELECT * FROM orders
WHERE user_id = 5 AND created_at > '2024-01-01';
-- Index Cond: (user_id = 5)
-- Filter: (created_at > '2024-01-01')  <- фильтрация БЕЗ индекса

-- НЕ использует индекс
EXPLAIN SELECT * FROM orders WHERE status = 'paid';
-- Seq Scan with Filter
```

### Порядок столбцов: как выбирать

Правильный порядок столбцов в составном индексе — одно из важнейших решений при проектировании. Общие рекомендации:

1. **Первым — столбец с equality-условиями** (=), а не с диапазонами (<, >, BETWEEN).
2. **Далее — остальные equality-столбцы** по убыванию селективности.
3. **Последним — столбец с диапазоном или ORDER BY**.

Это связано с тем, что после диапазонного условия B-Tree не может эффективно использовать следующие столбцы индекса.

```sql
-- ПЛОХО: диапазон первым
CREATE INDEX idx_bad ON orders (created_at, user_id, status);
-- WHERE user_id = 5 AND status = 'paid' AND created_at > '2024-01-01'
-- Индекс НЕ используется для user_id и status

-- ХОРОШО: equality первым, диапазон последним
CREATE INDEX idx_good ON orders (user_id, status, created_at);
-- WHERE user_id = 5 AND status = 'paid' AND created_at > '2024-01-01'
-- Все три столбца используются!
```

### Составной индекс и сортировка

Составной индекс может ускорять ORDER BY, если порядок сортировки совпадает с порядком столбцов в индексе:

```sql
CREATE INDEX idx_orders_user_date ON orders (user_id, created_at DESC);

-- Индекс используется для сортировки
SELECT * FROM orders WHERE user_id = 5 ORDER BY created_at DESC LIMIT 10;
-- Index Scan (без дополнительной сортировки)

-- Индекс НЕ помогает с сортировкой (неправильное направление)
SELECT * FROM orders WHERE user_id = 5 ORDER BY created_at ASC LIMIT 10;
-- Index Scan Backward (PostgreSQL может сканировать индекс в обратном направлении)
-- В MySQL аналогично с 8.0+
```

### Составной индекс vs несколько одиночных

Планировщик может комбинировать несколько одиночных индексов через Bitmap Scan, но составной индекс почти всегда эффективнее:

```sql
-- Два одиночных индекса
CREATE INDEX idx_user ON orders (user_id);
CREATE INDEX idx_status ON orders (status);

EXPLAIN SELECT * FROM orders WHERE user_id = 5 AND status = 'paid';
-- BitmapAnd
--   -> Bitmap Index Scan on idx_user (user_id = 5)
--   -> Bitmap Index Scan on idx_status (status = 'paid')
-- Bitmap Heap Scan

-- Один составной индекс
CREATE INDEX idx_user_status ON orders (user_id, status);

EXPLAIN SELECT * FROM orders WHERE user_id = 5 AND status = 'paid';
-- Index Scan using idx_user_status
-- Быстрее: один проход по индексу вместо двух + объединение bitmap
```

### Сколько столбцов включать

PostgreSQL поддерживает до 32 столбцов в составном индексе. Однако на практике более 3-4 столбцов используются редко. Каждый дополнительный столбец:
- Увеличивает размер индекса.
- Замедляет INSERT/UPDATE/DELETE.
- Может не использоваться, если запросы не содержат все предшествующие столбцы.

### Практические рекомендации

```sql
-- 1. Анализируйте реальные запросы перед созданием индекса
-- Смотрите pg_stat_statements для поиска медленных запросов

-- 2. Один составной индекс покрывает несколько запросов
CREATE INDEX idx_orders_user_status_date ON orders (user_id, status, created_at);
-- Покрывает: WHERE user_id = ?
--            WHERE user_id = ? AND status = ?
--            WHERE user_id = ? AND status = ? AND created_at > ?

-- 3. Используйте INCLUDE для покрытия без расширения ключа
CREATE INDEX idx_orders_lookup ON orders (user_id, status)
  INCLUDE (total, created_at);
-- Index Only Scan для: SELECT total, created_at FROM orders WHERE user_id = ? AND status = ?

-- 4. Проверяйте, что индекс реально используется
SELECT indexrelname, idx_scan, idx_tup_read, idx_tup_fetch
FROM pg_stat_user_indexes
WHERE indexrelname = 'idx_orders_user_status_date';
```

## Примеры
```sql
CREATE INDEX idx_orders_user_status ON orders (user_id, status);
```

## Доп. теория
- Составной индекс эффективнее двух одиночных, если запросы регулярно фильтруют по обоим столбцам.
- После диапазонного условия дальнейшие столбцы индекса почти не участвуют.
