## Вопрос: Индексы по выражению

## Простой ответ
- Индексируем не колонку напрямую, а её преобразование.
- Работает только если запрос использует то же самое выражение.

## Ответ

### Что такое индекс по выражению

Индекс по выражению (expression index, functional index) -- это индекс, построенный не по значениям столбца напрямую, а по результату вычисления функции или выражения над столбцами. СУБД вычисляет выражение для каждой строки при вставке/обновлении и сохраняет результат в B-tree (или другой структуре индекса). При выполнении запроса, содержащего то же самое выражение в WHERE или ORDER BY, планировщик использует этот индекс вместо full table scan.

### Как это работает

Обычный индекс по столбцу `name` не поможет запросу `WHERE LOWER(name) = 'john'`, потому что СУБД применяет функцию `LOWER()` к каждой строке и не может использовать B-tree для поиска трансформированного значения. Индекс по выражению решает эту проблему: значения `LOWER(name)` заранее вычислены и отсортированы в индексе.

**Ключевое правило**: индекс по выражению используется планировщиком только тогда, когда выражение в запросе **точно совпадает** с выражением в индексе. `LOWER(name)` в индексе не поможет запросу с `UPPER(name)` или `lower(trim(name))`.

### Примеры создания и использования

**1. Регистронезависимый поиск:**
```sql
-- Создаём индекс
CREATE INDEX idx_users_lower_email ON users (LOWER(email));

-- Этот запрос ИСПОЛЬЗУЕТ индекс:
SELECT * FROM users WHERE LOWER(email) = 'john@example.com';

-- Этот запрос НЕ ИСПОЛЬЗУЕТ индекс (выражение другое):
SELECT * FROM users WHERE email = 'john@example.com';
SELECT * FROM users WHERE UPPER(email) = 'JOHN@EXAMPLE.COM';
```

**2. Поиск по части даты:**
```sql
-- Индекс по году из timestamp
CREATE INDEX idx_orders_year ON orders (EXTRACT(YEAR FROM created_at));

-- Использует индекс:
SELECT * FROM orders WHERE EXTRACT(YEAR FROM created_at) = 2024;

-- Альтернатива: индекс по дате (приведение типа)
CREATE INDEX idx_orders_date ON orders ((created_at::date));
SELECT * FROM orders WHERE created_at::date = '2024-01-15';
```

**3. Поиск по вычисляемому полю:**
```sql
-- Индекс по длине текста
CREATE INDEX idx_posts_title_len ON posts ((length(title)));
SELECT * FROM posts WHERE length(title) > 100;

-- Индекс по JSON-полю (PostgreSQL)
CREATE INDEX idx_users_city ON users ((data->>'city'));
SELECT * FROM users WHERE data->>'city' = 'Moscow';

-- Индекс по конкатенации
CREATE INDEX idx_full_name ON users ((first_name || ' ' || last_name));
SELECT * FROM users WHERE first_name || ' ' || last_name = 'Ivan Petrov';
```

**4. Partial expression index (комбинация):**
```sql
-- Индекс только по активным пользователям с нормализованным email
CREATE INDEX idx_active_lower_email ON users (LOWER(email))
WHERE active = true;

-- Использует индекс:
SELECT * FROM users WHERE LOWER(email) = 'test@mail.com' AND active = true;
```

### Проверка использования индекса

Всегда проверяйте, что планировщик действительно использует ваш индекс:

```sql
EXPLAIN ANALYZE
SELECT * FROM users WHERE LOWER(email) = 'test@example.com';

-- Ожидаем увидеть:
-- Index Scan using idx_users_lower_email on users
-- а не:
-- Seq Scan on users (Filter: lower(email) = ...)
```

### Expression index vs Generated columns

В PostgreSQL 12+ появились generated columns -- вычисляемые столбцы, которые хранятся физически. Это альтернативный подход:

```sql
-- Вариант 1: Expression index
CREATE INDEX idx_lower_email ON users (LOWER(email));

-- Вариант 2: Generated column + обычный индекс
ALTER TABLE users ADD COLUMN email_lower TEXT
    GENERATED ALWAYS AS (LOWER(email)) STORED;
CREATE INDEX idx_email_lower ON users (email_lower);
```

| Критерий | Expression index | Generated column |
|----------|-----------------|------------------|
| Хранение | Только в индексе | В таблице + индексе |
| Чтение без индекса | Нельзя прочитать вычисленное значение напрямую | Можно SELECT email_lower |
| Overhead записи | Меньше (только обновление индекса) | Больше (обновление столбца + индекса) |
| Совместимость | PostgreSQL, MySQL 8.0+, Oracle, SQL Server | PostgreSQL 12+, MySQL 5.7+ (virtual/stored) |

### Ограничения

- **Только IMMUTABLE функции** -- в PostgreSQL выражение индекса должно быть IMMUTABLE (результат зависит только от аргументов, а не от состояния БД или времени). Например, `now()` нельзя использовать.
- **Overhead на запись** -- при каждом INSERT/UPDATE выражение вычисляется заново и индекс обновляется.
- **Точное совпадение** -- запрос должен содержать в точности то же выражение, что и индекс.
- **Размер индекса** -- зависит от результата выражения. Если выражение возвращает длинные строки, индекс будет большим.

### Поддержка в разных СУБД

| СУБД | Поддержка | Синтаксис |
|------|-----------|-----------|
| PostgreSQL | Полная, с версии 7.4 | `CREATE INDEX ... ON t (expr)` |
| MySQL | С версии 8.0.13 | `CREATE INDEX ... ON t ((expr))` (двойные скобки) |
| Oracle | Полная (function-based index) | `CREATE INDEX ... ON t (func(col))` |
| SQL Server | Через computed columns + индекс | `ALTER TABLE ADD col AS expr; CREATE INDEX ON t (col)` |
| SQLite | С версии 3.9.0 | `CREATE INDEX ... ON t (expr)` |

### Практические рекомендации

- Прежде чем создавать expression index, подумайте: **можно ли нормализовать данные при записи?** Например, всегда хранить email в lowercase -- тогда достаточно обычного индекса.
- Expression index идеален для случаев, когда **вы не контролируете формат входных данных** или работаете с legacy-схемой.
- Используйте `EXPLAIN ANALYZE` для проверки: иногда планировщик не распознаёт эквивалентные выражения (например, `a + b` и `b + a`).
- Помните про **COLLATION**: для регистронезависимого поиска в PostgreSQL можно также использовать `CITEXT` тип или `CREATE INDEX ... ON t (col COLLATE "und-x-icu") -- case-insensitive collation`.

## Примеры
```sql
CREATE INDEX idx_users_lower_email ON users (LOWER(email));
```

## Доп. теория
- Индекс по выражению работает только при точном совпадении выражения в запросе.
- Для простых кейсов часто выгоднее нормализовать данные на записи.
