## Вопрос: Попали ли в кеш

## Простой ответ
- `hit` — из памяти, `read` — с диска (медленнее).
- Для точной картины гоняйте два раза: первый холодный, второй тёплый кеш.

Пример — в конце.

## Ответ

### Как работает кеширование в PostgreSQL

PostgreSQL использует двухуровневую систему кеширования:

1. **Shared Buffers** — собственный кеш PostgreSQL в оперативной памяти. Размер задаётся параметром `shared_buffers` (обычно 25% RAM). Здесь хранятся страницы таблиц и индексов, к которым недавно обращались.
2. **OS Page Cache** — кеш операционной системы. Когда PostgreSQL читает файл с диска, ОС также кеширует его в page cache. Даже если данных нет в shared buffers, они могут быть в page cache, и чтение будет быстрым.

Когда PostgreSQL показывает `read` в EXPLAIN, это означает «данные не нашлись в shared buffers». Но они могут быть в OS page cache, и фактического обращения к диску не произошло. Поэтому `read` != физическое чтение диска.

### EXPLAIN (ANALYZE, BUFFERS) — основной инструмент

```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM users WHERE id = 42;

-- Index Scan using users_pkey on users
--   Index Cond: (id = 42)
--   Buffers: shared hit=3              <- 3 страницы из кеша
--   Planning Time: 0.085 ms
--   Execution Time: 0.032 ms
```

Ключевые поля в секции `Buffers`:

| Поле | Значение |
|---|---|
| `shared hit` | Страницы, найденные в shared buffers (кеш) |
| `shared read` | Страницы, прочитанные мимо shared buffers (из OS cache или диска) |
| `shared dirtied` | Страницы, изменённые в кеше (при UPDATE/INSERT) |
| `shared written` | Страницы, записанные из кеша на диск |
| `temp read/written` | Страницы во временных файлах (сортировка, hash join не поместились в work_mem) |

### Холодный vs тёплый кеш

Для объективной оценки производительности запроса важно понимать состояние кеша:

```sql
-- Шаг 1: Очищаем кеш (только для тестирования!)
-- Перезапуск PostgreSQL очистит shared buffers
-- Или для конкретной таблицы можно прочитать другую большую таблицу, вытеснив данные

-- Шаг 2: Первый запрос — холодный кеш
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders WHERE user_id = 42;
-- Buffers: shared hit=0 read=15       <- всё с диска/OS cache
-- Execution Time: 2.5 ms

-- Шаг 3: Второй запрос — тёплый кеш
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders WHERE user_id = 42;
-- Buffers: shared hit=15 read=0       <- всё из shared buffers
-- Execution Time: 0.3 ms
```

Разница во времени между холодным и тёплым кешем может быть 5-50x, особенно на HDD.

### Мониторинг cache hit ratio

Для production-систем критически важен показатель cache hit ratio — процент обращений, обслуженных из кеша:

```sql
-- Cache hit ratio для таблиц
SELECT
  relname,
  heap_blks_hit,
  heap_blks_read,
  CASE WHEN heap_blks_hit + heap_blks_read = 0 THEN 0
       ELSE round(100.0 * heap_blks_hit / (heap_blks_hit + heap_blks_read), 2)
  END AS hit_ratio_pct
FROM pg_statio_user_tables
ORDER BY heap_blks_read DESC
LIMIT 10;

-- Cache hit ratio для индексов
SELECT
  indexrelname,
  idx_blks_hit,
  idx_blks_read,
  CASE WHEN idx_blks_hit + idx_blks_read = 0 THEN 0
       ELSE round(100.0 * idx_blks_hit / (idx_blks_hit + idx_blks_read), 2)
  END AS hit_ratio_pct
FROM pg_statio_user_indexes
ORDER BY idx_blks_read DESC
LIMIT 10;

-- Общий cache hit ratio по всей базе
SELECT
  round(100.0 * sum(blks_hit) / nullif(sum(blks_hit) + sum(blks_read), 0), 2) AS cache_hit_ratio
FROM pg_stat_database
WHERE datname = current_database();
-- Хороший показатель: > 99%
-- Приемлемый: > 95%
-- Проблемный: < 90% — нужно увеличить shared_buffers или оптимизировать запросы
```

### Настройка shared_buffers

```sql
-- Посмотреть текущее значение
SHOW shared_buffers;
-- Типичные значения: 256MB (default) -> рекомендуется 25% RAM

-- Пример для сервера с 16 GB RAM
-- postgresql.conf:
-- shared_buffers = 4GB
-- effective_cache_size = 12GB   <- подсказка планировщику о суммарном объёме кеша (shared_buffers + OS cache)
```

Параметр `effective_cache_size` не выделяет память — он лишь сообщает планировщику, сколько данных может быть кешировано. Это влияет на выбор между Index Scan и Seq Scan: при большом `effective_cache_size` планировщик охотнее выбирает Index Scan, зная, что random I/O будет обслужен из кеша.

### Расширение pg_buffercache

Для детального анализа содержимого shared buffers можно использовать расширение `pg_buffercache`:

```sql
CREATE EXTENSION pg_buffercache;

-- Какие таблицы занимают больше всего кеша
SELECT
  c.relname,
  count(*) AS buffers,
  pg_size_pretty(count(*) * 8192) AS size_in_cache
FROM pg_buffercache b
JOIN pg_class c ON b.relfilenode = c.relfilenode
WHERE b.reldatabase = (SELECT oid FROM pg_database WHERE datname = current_database())
GROUP BY c.relname
ORDER BY buffers DESC
LIMIT 10;
```

### Практические рекомендации

1. **Всегда используйте `EXPLAIN (ANALYZE, BUFFERS)`** вместо просто `EXPLAIN` — без BUFFERS вы не увидите информацию о кеше.
2. **Запускайте запрос дважды** — первый раз для прогрева кеша, второй для оценки «обычной» производительности.
3. **Следите за cache hit ratio** — если он ниже 95%, рассмотрите увеличение `shared_buffers`.
4. **temp read/written > 0** — значит, операция (сортировка, hash join) не поместилась в `work_mem`. Увеличьте `work_mem` для конкретного запроса или глобально.
5. **Используйте `pg_stat_statements`** — расширение показывает суммарную статистику по shared buffers для каждого типа запроса, что помогает найти запросы с плохим cache hit ratio.

## Примеры
```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM users WHERE id = 42;
-- Buffers: shared hit=3 read=0  -- все из кеша
```

## Доп. теория
- `shared read` означает промах по shared buffers, но данные могли быть в OS page cache.
- Для честного бенчмарка сравнивайте «холодный» и «тёплый» прогон.
