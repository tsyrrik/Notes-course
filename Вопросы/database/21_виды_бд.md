## Вопрос: Типы БД

## Простой ответ
- Выбор зависит от модели данных и нагрузки: CRUD/транзакции → реляционные, аналитика → колонка, связи → граф, кэш → key-value, лог/метрики → time-series.

## Ответ

### Реляционные базы данных (RDBMS)

Реляционные БД — фундамент большинства приложений. Данные хранятся в **таблицах** (отношениях) со строго определённой схемой. Связи между таблицами выражаются через внешние ключи (Foreign Key). Поддерживают SQL и ACID-транзакции, что делает их надёжным выбором для транзакционных систем.

**Примеры**: PostgreSQL, MySQL, Oracle, MS SQL Server, SQLite.

**Когда использовать**: CRUD-приложения, финансовые системы, e-commerce, CRM — везде, где важны целостность данных и сложные запросы с JOIN.

```sql
-- Типичный реляционный запрос
SELECT u.name, COUNT(o.id) AS order_count, SUM(o.amount) AS total
FROM users u
JOIN orders o ON o.user_id = u.id
WHERE u.created_at > '2024-01-01'
GROUP BY u.name
HAVING SUM(o.amount) > 10000;
```

### Документоориентированные БД

Данные хранятся в виде **документов** (обычно JSON/BSON) без фиксированной схемы. Каждый документ может иметь произвольную структуру. Это удобно для приложений с часто меняющейся схемой, вложенными данными и когда один документ содержит всю необходимую информацию (нет необходимости в JOIN).

**Примеры**: MongoDB, CouchDB, Amazon DocumentDB.

**Когда использовать**: каталоги товаров (разные атрибуты у разных категорий), CMS, мобильные приложения, прототипирование.

```json
// Документ в MongoDB — заказ с вложенными товарами
{
  "_id": "order_123",
  "user": {"name": "Иван", "email": "ivan@example.com"},
  "items": [
    {"product": "Ноутбук", "price": 75000, "qty": 1},
    {"product": "Мышь", "price": 2000, "qty": 2}
  ],
  "total": 79000,
  "status": "delivered"
}
```

**Нюансы**: отсутствие JOIN означает денормализацию — данные дублируются, и обновление (например, email пользователя) требует обновления во всех документах.

### Key-Value хранилища

Простейшая модель — **ключ → значение**. Значением может быть строка, число, JSON или бинарные данные. Обеспечивают минимальную задержку (микросекунды) для операций чтения/записи по ключу.

**Примеры**: Redis, Memcached, Amazon DynamoDB, etcd.

**Когда использовать**: кеширование, сессии пользователей, счётчики, очереди, pub/sub.

```bash
# Redis — типичные операции
SET user:1:session "abc123" EX 3600    # сессия с TTL 1 час
GET user:1:session                      # получить сессию
INCR page:views:homepage               # атомарный инкремент счётчика
LPUSH queue:emails "send_welcome"       # добавить в очередь
```

**Redis** выделяется тем, что поддерживает структуры данных (списки, множества, хеши, sorted sets), что делает его гораздо мощнее простого key-value.

### Колончатые (Column-Oriented) БД

В отличие от строковых БД, где данные хранятся **по строкам**, колончатые БД хранят данные **по столбцам**. Это даёт огромное преимущество для аналитических запросов, которые агрегируют один-два столбца из миллиардов строк: читается только нужный столбец, плюс данные одного типа отлично сжимаются.

**Примеры**: ClickHouse, Apache Cassandra*, Vertica, Amazon Redshift, Google BigQuery.

*Cassandra — wide-column store, немного другая концепция.

**Когда использовать**: OLAP-аналитика, логирование, метрики, отчёты по большим данным.

```sql
-- ClickHouse: агрегация по миллиарду строк за секунды
SELECT
    toDate(event_time) AS day,
    countIf(event = 'purchase') AS purchases,
    sumIf(amount, event = 'purchase') AS revenue
FROM events
WHERE event_time >= '2024-01-01'
GROUP BY day
ORDER BY day;
```

### Графовые БД

Данные представлены в виде **узлов** (nodes) и **рёбер** (edges/relationships). Оптимизированы для запросов, которые обходят граф связей: «друзья друзей», «кратчайший путь», «рекомендации».

**Примеры**: Neo4j, Amazon Neptune, ArangoDB, JanusGraph.

**Когда использовать**: социальные сети, рекомендательные системы, fraud detection, управление знаниями, сетевая топология.

```cypher
// Neo4j (Cypher): найти друзей друзей
MATCH (me:User {name: "Иван"})-[:FRIEND]->(friend)-[:FRIEND]->(fof)
WHERE fof <> me AND NOT (me)-[:FRIEND]->(fof)
RETURN fof.name, COUNT(friend) AS mutual_friends
ORDER BY mutual_friends DESC
LIMIT 10;
```

В реляционной БД такой запрос потребовал бы нескольких рекурсивных JOIN, что на больших графах работает значительно медленнее.

### Time Series БД

Оптимизированы для хранения и запросов **временных рядов** — данных, привязанных ко времени: метрики серверов, IoT-данные, биржевые котировки. Поддерживают эффективное сжатие, автоматическую агрегацию (downsampling) и TTL для старых данных.

**Примеры**: InfluxDB, TimescaleDB (расширение PostgreSQL), Prometheus, VictoriaMetrics.

**Когда использовать**: мониторинг (CPU, память, latency), IoT, финансовые котировки, логи с метками времени.

```sql
-- TimescaleDB (SQL-совместимый)
SELECT time_bucket('1 hour', time) AS hour,
       avg(cpu_usage) AS avg_cpu,
       max(cpu_usage) AS max_cpu
FROM server_metrics
WHERE time > NOW() - INTERVAL '7 days'
  AND host = 'web-01'
GROUP BY hour
ORDER BY hour;
```

### NewSQL

Попытка совместить **горизонтальное масштабирование** NoSQL с **ACID-гарантиями** реляционных БД. Данные распределяются между узлами, но при этом поддерживаются SQL-запросы и транзакции.

**Примеры**: CockroachDB, YugabyteDB, Google Spanner, TiDB.

**Когда использовать**: глобально распределённые приложения, где нужны и масштабирование, и строгая консистентность.

### Vector DB

Хранят и ищут **векторные представления** (embeddings) — числовые массивы, создаваемые ML-моделями. Поддерживают поиск по **семантическому сходству** (ближайшие соседи в многомерном пространстве), а не по точному совпадению.

**Примеры**: Pinecone, Weaviate, Milvus, Qdrant, pgvector (расширение PostgreSQL).

**Когда использовать**: семантический поиск, RAG (Retrieval-Augmented Generation) для LLM, рекомендательные системы, поиск похожих изображений.

```sql
-- pgvector: поиск похожих документов
SELECT title, content,
       embedding <=> '[0.1, 0.2, 0.3, ...]'::vector AS distance
FROM documents
ORDER BY embedding <=> '[0.1, 0.2, 0.3, ...]'::vector
LIMIT 10;
```

### Сводная таблица

| Тип БД | Модель данных | Сильные стороны | Слабые стороны | Пример |
|--------|-------------|-----------------|----------------|--------|
| Реляционная | Таблицы, SQL | ACID, сложные запросы | Масштабирование записи | PostgreSQL |
| Документная | JSON-документы | Гибкая схема | Нет JOIN, дубликаты | MongoDB |
| Key-Value | Ключ-значение | Скорость, простота | Нет сложных запросов | Redis |
| Колончатая | Столбцы | Аналитика, сжатие | Медленная вставка по одной строке | ClickHouse |
| Графовая | Узлы и рёбра | Обход связей | Агрегация, масштабирование | Neo4j |
| Time Series | Временные ряды | Метрики, сжатие, TTL | Только временные данные | InfluxDB |
| NewSQL | Таблицы, SQL | Масштабирование + ACID | Сложность эксплуатации | CockroachDB |
| Vector DB | Векторы (embeddings) | Семантический поиск | Узкая специализация | Pinecone |

### Практические советы

1. **PostgreSQL как «швейцарский нож»**: с расширениями (pgvector, TimescaleDB, PostGIS, hstore) PostgreSQL может выполнять роль документной, векторной, time-series и геопространственной БД. Начинайте с PostgreSQL и добавляйте специализированные БД по мере роста нагрузки.
2. **Polyglot persistence** — в реальных проектах часто используют несколько типов БД: PostgreSQL для транзакций + Redis для кеша + ClickHouse для аналитики + Elasticsearch для полнотекстового поиска.
3. **Не выбирайте БД по хайпу** — выбирайте по модели данных и паттернам нагрузки. Если ваши данные укладываются в таблицы и нужны транзакции — реляционная БД будет лучшим выбором.
4. **CAP-теорема**: распределённые системы могут обеспечить только два из трёх свойств — Consistency, Availability, Partition tolerance. Реляционные БД обычно выбирают CP, NoSQL (Cassandra, DynamoDB) — AP.

## Примеры
```text
Транзакции → PostgreSQL/MySQL
Аналитика → ClickHouse/BigQuery
Кеш → Redis/Memcached
```

## Доп. теория
- PostgreSQL с расширениями может закрывать много кейсов, но специализированные БД всё равно выигрывают на экстремальных нагрузках.
- Для сложных систем обычно используется polyglot‑подход: несколько БД под разные задачи.
