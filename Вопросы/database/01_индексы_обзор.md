## Вопрос: Индексы: зачем и плюсы/минусы

## Простой ответ
- Индекс — оглавление книги: ускоряет чтение нужных строк.
- Хорош, если фильтруем/сортируем по полю; вреден, если поле почти у всех одинаково или много записей/апдейтов.

Примеры — в конце.

## Ответ

### Что такое индекс

Индекс в базе данных — это отдельная структура данных, которая хранит отсортированные значения одного или нескольких столбцов таблицы вместе с указателями на соответствующие строки. Аналогия с оглавлением книги очень точна: вместо того чтобы перелистывать каждую страницу, вы смотрите в оглавление, находите нужную тему и переходите сразу на нужную страницу. Без индекса СУБД вынуждена выполнять Sequential Scan — последовательное чтение всей таблицы, что на больших объёмах данных крайне медленно.

### Какие операции ускоряют индексы

Индексы ускоряют не только простые `WHERE`-фильтры, но и целый ряд других операций:

| Операция | Как помогает индекс |
|---|---|
| `WHERE col = value` | Прямой поиск по ключу — самый частый сценарий |
| `WHERE col BETWEEN a AND b` | Диапазонный поиск по B-Tree |
| `ORDER BY col` | Данные уже отсортированы в индексе |
| `JOIN t1 ON t1.id = t2.fk` | Быстрый lookup для каждой строки из другой таблицы |
| `MIN(col)` / `MAX(col)` | Крайние значения лежат на краях B-Tree |
| `GROUP BY col` | Может использоваться для Index Scan вместо hash/sort aggregation |
| `DISTINCT col` | Аналогично GROUP BY |

### Как СУБД решает, использовать ли индекс

Планировщик запросов (query planner) оценивает стоимость разных стратегий выполнения. Он учитывает статистику таблицы — количество строк, распределение значений (histogram), корреляцию данных с физическим порядком на диске. Если планировщик видит, что запрос вернёт более ~5-15% строк таблицы, он может предпочесть Sequential Scan, потому что случайное чтение через индекс обходится дороже последовательного чтения.

```sql
-- Проверяем план выполнения
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user@example.com';
-- Index Scan using idx_users_email on users  (cost=0.42..8.44 rows=1 width=128)
--   actual time=0.025..0.026 rows=1 loops=1

EXPLAIN ANALYZE SELECT * FROM users WHERE active = true;
-- Seq Scan on users  (cost=0.00..1542.00 rows=98000 width=128)
-- Если 98% пользователей active=true, индекс по active бесполезен
```

### Селективность — ключевой фактор

Селективность (selectivity) — это доля строк, возвращаемых условием, от общего числа строк в таблице. Чем меньше эта доля, тем выше селективность и тем полезнее индекс. Уникальные столбцы (email, UUID, номер телефона) имеют максимальную селективность. Столбцы с малым количеством уникальных значений (пол, boolean-флаги, статус из 3-4 вариантов) имеют низкую селективность — индекс по ним обычно не используется.

```sql
-- Высокая селективность — индекс полезен
SELECT * FROM users WHERE email = 'user@example.com';   -- 1 из 1 000 000

-- Низкая селективность — индекс бесполезен
SELECT * FROM users WHERE gender = 'M';                  -- 500 000 из 1 000 000
```

### Плюсы индексов

1. **Ускорение чтения** — поиск за O(log n) вместо O(n) для B-Tree.
2. **Ускорение сортировки** — если ORDER BY совпадает с порядком индекса, сортировка не нужна.
3. **Ускорение JOIN** — Nested Loop Join с индексом работает значительно быстрее.
4. **Поддержка уникальности** — UNIQUE INDEX гарантирует отсутствие дубликатов на уровне СУБД.
5. **Покрывающие запросы** — Index Only Scan позволяет вообще не обращаться к таблице.

### Минусы индексов

1. **Замедление записи** — каждый INSERT, UPDATE, DELETE должен обновить не только таблицу, но и все индексы. Для таблицы с 5 индексами INSERT в ~5 раз дороже по I/O.
2. **Расход дискового пространства** — индекс может занимать 10-30% от размера таблицы. При большом количестве индексов суммарный объём индексов может превысить объём данных.
3. **Фрагментация** — после множества UPDATE/DELETE B-Tree становится фрагментированным, требуется REINDEX.
4. **Усложнение планирования** — слишком много индексов заставляют планировщик тратить время на выбор оптимального плана.

### Практические рекомендации

```sql
-- 1. Всегда индексируйте foreign key
CREATE INDEX idx_orders_user_id ON orders (user_id);

-- 2. Индексируйте столбцы в WHERE, JOIN, ORDER BY
CREATE INDEX idx_users_email ON users (email);

-- 3. Проверяйте размер индексов
SELECT indexname, pg_size_pretty(pg_relation_size(indexname::regclass))
FROM pg_indexes WHERE tablename = 'users';

-- 4. Находите неиспользуемые индексы
SELECT indexrelname, idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0 AND indexrelname NOT LIKE '%pkey%';
-- Если idx_scan = 0 за долгий период — индекс можно удалить

-- 5. Partial index — индексируем только нужные строки
CREATE INDEX idx_orders_unpaid ON orders (created_at)
WHERE status = 'unpaid';
-- Меньше размер, быстрее обновление, точнее попадание
```

### Когда НЕ стоит создавать индекс

- Таблица маленькая (менее ~1000 строк) — Sequential Scan быстрее.
- Столбец имеет очень низкую селективность (boolean, enum с 2-3 значениями).
- Таблица подвергается массовым INSERT/UPDATE (логи, очереди) — overhead от индексов критичен.
- Запрос всё равно читает большую часть таблицы — индекс не поможет.

## Примеры
```sql
CREATE INDEX idx_users_email ON users (email);
-- ускорит WHERE email = 'user@example.com'
```

```sql
CREATE INDEX idx_posts_published_at ON posts (published_at DESC);
-- EXPLAIN покажет Index Scan вместо Seq Scan при ORDER BY published_at LIMIT 10
```

## Доп. теория
- Индекс — это компромисс: ускорение чтения ценой записи и диска.
- Всегда проверяйте планы `EXPLAIN`, иначе можно создать «мертвый» индекс, который не используется.
