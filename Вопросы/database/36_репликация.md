## Вопрос: Репликация баз данных

## Простой ответ
- Несколько копий БД синхронизируются с лидера, чтобы дать отказоустойчивость и масштабирование чтения.
- Запись репликация не масштабирует — для write нужен шардинг.

## Ответ
## Зачем
- N копий данных: 1 мастер/лидер и N слейвов/ведомых (обычно для чтения).
- HA/failover: при падении мастера можно переключиться на реплику.
- Read scaling: читаем с реплик, разгружая мастер.
- Не даёт масштабирования записи.

## Топологии
- Master-Slave: один мастер для записи, слейвы для чтения.
- Master-Master: несколько мастеров, сложнее, риск конфликтов/потери данных.
- Leaderless (Dynamo-style: Cassandra, Riak): нет лидера, клиент/координатор пишет на несколько реплик без общего порядка.

## Способы репликации
- Операторная (statement-based): пересылка SQL операторов; проблемы с недетерминизмом/порядком.
- Физическая (WAL/логическое копирование блоков): низкий уровень, привязка к формату хранения/версии.
- Логическая (row-based): журнальные записи изменения строк; проще разбирать, версии независимее.
- Триггерная: приложение/триггеры пишут изменения в лог; гибко, но дороже и сложнее.

## Синхронная vs асинхронная vs полусинхронная
- Синхронная: коммит успешен, когда записано на мастер и на синхронную реплику → надёжно, но медленнее.
- Асинхронная: мастер подтверждает коммит сразу, реплики отстают → быстрее, но риск потери последних данных при падении мастера.
- Полусинхронная: мастер ждёт доставки на реплику (но не обязательно применения) или ждёт 1 синхронную, остальные асинхронные.

## Как работает (классика)
- Мастер пишет изменения в журнал (WAL/binlog).
- Реплика получает журнал (relay), применяет изменения.

## Ограничения/риски
- Запаздывание реплик: последовательные операции, требующие актуальных данных, читайте с мастера.
- Версии/форматы: физическая репликация часто требует одинаковых версий/форматов хранения.
- Конфликты порядка при statement-based/leaderless.

## Вспомогательные эффекты
- Балансировка чтения (load balancing).
- Резерв для бэкапов (но не заменяет бэкап!), аналитика на отдельной реплике.

Коротко: репликация = HA + масштабирование чтений + offload бэкапов/аналитики; для записи — шардить.
