## Вопрос: WHERE vs HAVING

## Простой ответ
- WHERE отсекает строки перед агрегацией, HAVING — уже готовые группы.

Пример — в конце.

## Ответ

### Фундаментальное различие

`WHERE` и `HAVING` — это оба фильтры, но они работают на **разных этапах** выполнения запроса. WHERE фильтрует **отдельные строки** до группировки и агрегации. HAVING фильтрует **группы** (результаты агрегации) после того, как GROUP BY сформировал их. Это не взаимозаменяемые конструкции — каждая имеет своё место в логическом порядке обработки запроса.

### Порядок выполнения

```
FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT
```

WHERE выполняется **до** GROUP BY — он уменьшает количество строк, которые попадут в группировку. HAVING выполняется **после** GROUP BY — он уже работает с агрегированными результатами. Это значит, что в WHERE нельзя использовать агрегатные функции (строки ещё не сгруппированы), а в HAVING — можно.

### Примеры использования

```sql
-- Найти отделы с более чем 5 сотрудниками, зарабатывающими больше 50000
SELECT department, COUNT(*) AS emp_count, AVG(salary) AS avg_salary
FROM employees
WHERE salary > 50000          -- фильтр строк: берём только сотрудников с зарплатой > 50000
GROUP BY department
HAVING COUNT(*) > 5           -- фильтр групп: оставляем отделы с > 5 таких сотрудников
ORDER BY avg_salary DESC;
```

Если бы мы попытались поместить `salary > 50000` в HAVING, это бы не имело смысла: после группировки отдельных значений salary уже не существует — есть только агрегаты (`AVG(salary)`, `SUM(salary)` и т.д.).

### Что можно использовать в WHERE и HAVING

| Конструкция | WHERE | HAVING |
|------------|-------|--------|
| Сравнение столбцов: `salary > 1000` | ✅ | ✅ (но неэффективно) |
| Агрегатные функции: `COUNT(*) > 5` | ❌ | ✅ |
| Подзапросы | ✅ | ✅ |
| Псевдонимы (alias) | ❌ | ❌ (в стандартном SQL)* |

*PostgreSQL позволяет использовать alias в HAVING как расширение, но лучше дублировать выражение для переносимости.

### Распространённая ошибка

```sql
-- ❌ Ошибка: агрегатная функция в WHERE
SELECT department, COUNT(*)
FROM employees
WHERE COUNT(*) > 5       -- ERROR: aggregate functions are not allowed in WHERE
GROUP BY department;

-- ✅ Правильно: используем HAVING
SELECT department, COUNT(*)
FROM employees
GROUP BY department
HAVING COUNT(*) > 5;
```

### Производительность: WHERE vs HAVING

Если условие **можно** выразить и в WHERE, и в HAVING (например, фильтрация по обычному столбцу), **всегда используйте WHERE**. Причина — WHERE уменьшает объём данных до группировки, что снижает нагрузку на память и CPU:

```sql
-- ❌ Плохо: фильтрация в HAVING по не-агрегатному полю
SELECT department, COUNT(*)
FROM employees
GROUP BY department
HAVING department != 'Archive';   -- PostgreSQL это допускает, но это неэффективно

-- ✅ Хорошо: фильтрация в WHERE
SELECT department, COUNT(*)
FROM employees
WHERE department != 'Archive'     -- отсекаем строки ДО группировки
GROUP BY department;
```

В первом варианте PostgreSQL сначала сгруппирует все строки (включая 'Archive'), а потом отбросит группу. Во втором — строки 'Archive' не попадут в группировку вообще.

### HAVING без GROUP BY

HAVING можно использовать даже без GROUP BY — в этом случае вся таблица считается одной группой:

```sql
-- Проверить, есть ли в таблице более 1000 записей
SELECT COUNT(*) AS total
FROM users
HAVING COUNT(*) > 1000;
-- Если < 1000, запрос вернёт пустой результат (а не 0)
```

### Комбинирование WHERE и HAVING: практический пример

```sql
-- Отчёт: месяцы, в которых активные пользователи сделали более 100 заказов
-- на сумму более 50000
SELECT
    DATE_TRUNC('month', o.created_at) AS month,
    COUNT(*) AS order_count,
    SUM(o.amount) AS total_revenue
FROM orders o
JOIN users u ON u.id = o.user_id
WHERE u.is_active = true              -- WHERE: только активные пользователи
  AND o.created_at >= '2024-01-01'    -- WHERE: только заказы с 2024 года
GROUP BY DATE_TRUNC('month', o.created_at)
HAVING COUNT(*) > 100                 -- HAVING: только месяцы с > 100 заказами
   AND SUM(o.amount) > 50000         -- HAVING: и суммой > 50000
ORDER BY month;
```

### Практические советы

1. **Мнемоника**: WHERE — «до» (фильтр строк), HAVING — «после» (фильтр групп). Если в условии есть `COUNT`, `SUM`, `AVG` — это HAVING.
2. **Всегда предпочитайте WHERE** для не-агрегатных условий — это быстрее и понятнее.
3. **HAVING без GROUP BY** — допустимый, но редкий паттерн. Чаще для проверок «существует ли определённое количество записей».
4. На собеседовании ключевой ответ: «WHERE фильтрует строки до агрегации, HAVING — группы после агрегации. В WHERE нельзя использовать агрегатные функции».

## Примеры
```sql
SELECT department, COUNT(*)
FROM employees
WHERE salary > 1000      -- фильтрация строк
GROUP BY department
HAVING COUNT(*) > 5;     -- фильтрация сгруппированных результатов
```

## Доп. теория
- HAVING без GROUP BY работает, но вся таблица считается одной группой.
- Если условие можно выразить в WHERE — это почти всегда быстрее.
