## Вопрос: Оконные функции

## Простой ответ
- Считают агрегаты/ранги поверх «окна» строк, но не склеивают их в одну строку.

## Ответ

### Что такое оконные функции

Оконные функции (window functions) выполняют вычисления **по набору строк, связанных с текущей строкой**, но в отличие от GROUP BY **не схлопывают строки** в одну. Каждая строка результата сохраняется, и к ней добавляется вычисленное значение. Это делает оконные функции незаменимыми для задач ранжирования, нарастающих итогов, сравнения с предыдущей/следующей строкой и аналитики.

### Синтаксис

```sql
функция(...) OVER (
    [PARTITION BY столбец1, столбец2, ...]   -- разбиение на группы (окна)
    [ORDER BY столбец3 [ASC|DESC], ...]      -- порядок внутри окна
    [ROWS/RANGE BETWEEN ... AND ...]         -- рамка окна (frame)
)
```

- **PARTITION BY** — разбивает строки на независимые группы (окна). Аналогично GROUP BY, но строки не объединяются.
- **ORDER BY** — определяет порядок строк внутри окна. Обязателен для ранжирующих функций.
- **Frame** — определяет, какие строки относительно текущей участвуют в вычислении (по умолчанию: от начала партиции до текущей строки при наличии ORDER BY).

### Категории оконных функций

**1. Ранжирующие функции**

| Функция | Описание | Пример при одинаковых значениях |
|---------|----------|---------------------------------|
| `ROW_NUMBER()` | Уникальный номер строки | 1, 2, 3, 4 |
| `RANK()` | Ранг с пропусками | 1, 2, 2, 4 |
| `DENSE_RANK()` | Ранг без пропусков | 1, 2, 2, 3 |
| `NTILE(n)` | Разбиение на n равных групп | 1, 1, 2, 2 (при NTILE(2)) |

```sql
-- Топ-3 сотрудника по зарплате в каждом отделе
SELECT name, department, salary,
       ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS rn,
       RANK()       OVER (PARTITION BY department ORDER BY salary DESC) AS rnk,
       DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS drnk
FROM employees;

-- Получить только топ-3:
SELECT * FROM (
    SELECT name, department, salary,
           ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS rn
    FROM employees
) sub
WHERE rn <= 3;
```

**2. Функции смещения (навигации)**

| Функция | Описание |
|---------|----------|
| `LAG(col, n, default)` | Значение столбца из строки на n позиций назад |
| `LEAD(col, n, default)` | Значение столбца из строки на n позиций вперёд |
| `FIRST_VALUE(col)` | Первое значение в окне |
| `LAST_VALUE(col)` | Последнее значение в окне* |
| `NTH_VALUE(col, n)` | N-е значение в окне |

*`LAST_VALUE` с дефолтной рамкой показывает текущую строку, а не последнюю. Используйте `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`.

```sql
-- Сравнение выручки с предыдущим месяцем
SELECT
    month,
    revenue,
    LAG(revenue, 1) OVER (ORDER BY month) AS prev_month,
    revenue - LAG(revenue, 1) OVER (ORDER BY month) AS diff,
    ROUND(
        (revenue - LAG(revenue, 1) OVER (ORDER BY month))::numeric /
        LAG(revenue, 1) OVER (ORDER BY month) * 100, 1
    ) AS growth_pct
FROM monthly_sales;
```

**3. Агрегатные функции как оконные**

Любая агрегатная функция (`SUM`, `AVG`, `COUNT`, `MIN`, `MAX`) может работать как оконная:

```sql
-- Нарастающий итог (running total)
SELECT
    order_date,
    amount,
    SUM(amount) OVER (ORDER BY order_date) AS running_total,
    AVG(amount) OVER (ORDER BY order_date) AS running_avg,
    COUNT(*)    OVER (ORDER BY order_date) AS running_count
FROM orders;

-- Процент от общей суммы по отделу
SELECT
    name, department, salary,
    SUM(salary) OVER (PARTITION BY department) AS dept_total,
    ROUND(salary::numeric / SUM(salary) OVER (PARTITION BY department) * 100, 1) AS pct
FROM employees;
```

### Рамка окна (Window Frame)

Рамка определяет, какие строки участвуют в вычислении относительно текущей:

```sql
-- Скользящее среднее за последние 3 записи
SELECT
    order_date,
    amount,
    AVG(amount) OVER (
        ORDER BY order_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_avg_3
FROM orders;

-- Сумма от начала до конца окна (вся партиция)
SUM(amount) OVER (
    ORDER BY order_date
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
)
```

| Опция | Значение |
|-------|----------|
| `UNBOUNDED PRECEDING` | Начало партиции |
| `n PRECEDING` | n строк назад |
| `CURRENT ROW` | Текущая строка |
| `n FOLLOWING` | n строк вперёд |
| `UNBOUNDED FOLLOWING` | Конец партиции |

### Именованные окна (WINDOW)

Если несколько функций используют одно и то же окно, его можно вынести в именованное определение:

```sql
SELECT
    name, department, salary,
    ROW_NUMBER() OVER w AS rn,
    RANK()       OVER w AS rnk,
    SUM(salary)  OVER w AS running_sum
FROM employees
WINDOW w AS (PARTITION BY department ORDER BY salary DESC);
```

### Оконные функции vs GROUP BY

| Аспект | GROUP BY | Оконные функции |
|--------|----------|-----------------|
| Строки в результате | Одна строка на группу | Все исходные строки |
| Доступ к деталям | Только агрегаты | Агрегаты + детали |
| Ранжирование | Невозможно | ROW_NUMBER, RANK |
| Сравнение строк | Невозможно | LAG, LEAD |

### Порядок выполнения

Оконные функции вычисляются **после** WHERE, GROUP BY, HAVING — но **до** ORDER BY и LIMIT. Это значит, что оконную функцию нельзя использовать в WHERE:

```sql
-- ❌ Ошибка: оконная функция в WHERE
SELECT * FROM employees WHERE ROW_NUMBER() OVER (...) <= 3;

-- ✅ Нужен подзапрос или CTE
WITH ranked AS (
    SELECT *, ROW_NUMBER() OVER (ORDER BY salary DESC) AS rn
    FROM employees
)
SELECT * FROM ranked WHERE rn <= 3;
```

### Практические советы

1. **ROW_NUMBER для пагинации и дедупликации** — классический паттерн для удаления дубликатов:
```sql
DELETE FROM users WHERE id IN (
    SELECT id FROM (
        SELECT id, ROW_NUMBER() OVER (PARTITION BY email ORDER BY created_at) AS rn
        FROM users
    ) sub WHERE rn > 1
);
```
2. **PARTITION BY для отчётов** — считайте метрики по группам без потери детализации.
3. **Производительность**: оконные функции требуют сортировки данных. Индекс на столбцы из PARTITION BY + ORDER BY ускоряет выполнение.
4. **Будьте аккуратны с LAST_VALUE** — без явного указания рамки он показывает текущую строку, а не последнюю в окне.

## Примеры
```sql
SELECT name, department, salary,
       ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS rn
FROM employees;
```

## Доп. теория
- Оконные функции вычисляются после WHERE/GROUP BY/HAVING и до ORDER BY/LIMIT.
- Для фильтрации по оконным значениям используйте подзапрос или CTE.
