## Вопрос: Виды индексов

## Простой ответ
- B-Tree — универсальный по умолчанию.
- Hash — только точное равенство.
- GIN/GiST/Fulltext/Geo — ищут внутри текста/JSON/гео.
- BRIN — для очень больших таблиц, где данные на диске уже коррелированы со временем/ID.

Примеры
```sql
-- B-Tree для диапазона
CREATE INDEX idx_orders_created_at ON orders (created_at);
SELECT * FROM orders WHERE created_at BETWEEN now()-INTERVAL '7 days' AND now();

-- Hash в PostgreSQL (редко нужен)
CREATE INDEX idx_sessions_token_hash ON sessions USING hash (token);

-- GIN для JSONB поля
CREATE INDEX idx_events_payload_gin ON events USING gin (payload jsonb_path_ops);
SELECT * FROM events WHERE payload @> '{"type":"login"}';
```

## Ответ

### Сводная таблица видов индексов

| Тип индекса | Поддерживаемые операции | Когда использовать | СУБД |
|---|---|---|---|
| **B-Tree** | `=`, `<`, `>`, `<=`, `>=`, `BETWEEN`, `IN`, `LIKE 'prefix%'`, `ORDER BY` | Универсальный, по умолчанию | Все |
| **Hash** | Только `=` | Точное совпадение по длинным строкам (токены, хэши) | PostgreSQL, MySQL (Memory engine) |
| **GIN** | `@>`, `<@`, `?`, `?&`, `?\|`, полнотекстовый `@@` | JSONB, массивы, полнотекстовый поиск | PostgreSQL |
| **GiST** | `<<`, `>>`, `@>`, `<@`, `&&`, `~=`, геометрические операторы | Геоданные, диапазоны, полнотекст | PostgreSQL |
| **SP-GiST** | Аналогично GiST | Данные с естественным разбиением (IP-адреса, телефоны) | PostgreSQL |
| **BRIN** | `=`, `<`, `>`, `BETWEEN` | Огромные таблицы с естественной корреляцией данных | PostgreSQL |
| **Fulltext** | `MATCH ... AGAINST` | Полнотекстовый поиск | MySQL |
| **R-Tree** | Пространственные операции | Геоданные | MySQL (через SPATIAL INDEX) |

### B-Tree — универсальный индекс

B-Tree (Balanced Tree) — индекс по умолчанию в PostgreSQL и MySQL (InnoDB). Хранит ключи в отсортированном порядке, поэтому поддерживает не только точный поиск, но и диапазоны, сортировку, а также поиск по префиксу строки. Это самый часто используемый тип индекса — по статистике, более 90% индексов в типичной production-базе являются B-Tree.

```sql
-- Создаётся по умолчанию (USING btree можно не указывать)
CREATE INDEX idx_users_email ON users (email);

-- Поддерживает диапазоны
SELECT * FROM orders WHERE created_at BETWEEN '2024-01-01' AND '2024-12-31';

-- Поддерживает LIKE с префиксом (но НЕ '%suffix')
SELECT * FROM users WHERE name LIKE 'Alex%';   -- использует индекс
SELECT * FROM users WHERE name LIKE '%alex';    -- НЕ использует индекс
```

### Hash-индексы

Hash-индексы вычисляют хэш-функцию от значения ключа и хранят результат в хэш-таблице. Поиск точного совпадения выполняется за O(1), что теоретически быстрее B-Tree. Однако они не поддерживают диапазоны, сортировку и частичное совпадение. В PostgreSQL до версии 10 hash-индексы не были WAL-logged (не восстанавливались после crash), поэтому их использование было не рекомендовано. Начиная с PostgreSQL 10 они безопасны, но всё ещё применяются редко.

```sql
CREATE INDEX idx_tokens_hash ON tokens USING hash (token_value);
-- Полезен, если token_value — длинная строка и ищем только по =
```

### GIN (Generalized Inverted Index)

GIN — инвертированный индекс, который хранит маппинг «значение элемента -> список строк, содержащих этот элемент». Идеально подходит для составных значений: массивов, JSONB, полнотекстовых векторов (`tsvector`). Каждый элемент внутри значения индексируется отдельно.

```sql
-- Полнотекстовый поиск
CREATE INDEX idx_articles_fts ON articles USING gin (to_tsvector('russian', body));
SELECT * FROM articles WHERE to_tsvector('russian', body) @@ to_tsquery('индекс & база');

-- JSONB-поиск
CREATE INDEX idx_events_payload ON events USING gin (payload jsonb_path_ops);
SELECT * FROM events WHERE payload @> '{"type": "login", "success": true}';

-- Поиск по массивам
CREATE INDEX idx_posts_tags ON posts USING gin (tags);
SELECT * FROM posts WHERE tags @> ARRAY['postgresql', 'performance'];
```

GIN-индексы медленнее обновляются, чем B-Tree, из-за необходимости обновлять множество записей в инвертированном индексе. Для ускорения записи PostgreSQL поддерживает параметр `fastupdate`, который буферизует изменения.

### GiST (Generalized Search Tree)

GiST — обобщённое дерево поиска, поддерживающее произвольные стратегии индексирования. Используется для геоданных (PostGIS), диапазонных типов (`int4range`, `tsrange`), а также полнотекстового поиска (как альтернатива GIN — меньше размер, но медленнее поиск).

```sql
-- Геоданные с PostGIS
CREATE INDEX idx_places_location ON places USING gist (geom);
SELECT * FROM places WHERE ST_DWithin(geom, ST_MakePoint(37.6, 55.7)::geography, 1000);

-- Диапазонные типы
CREATE INDEX idx_reservations_period ON reservations USING gist (period);
SELECT * FROM reservations WHERE period && '[2024-06-01, 2024-06-30]'::daterange;
```

### BRIN (Block Range Index)

BRIN — компактный индекс, который хранит минимальное и максимальное значение для каждого блока (группы страниц) таблицы. Занимает в сотни раз меньше места, чем B-Tree. Работает хорошо только тогда, когда физический порядок данных на диске коррелирует со значениями столбца — например, столбец `created_at` в append-only таблице логов.

```sql
-- Идеально для таблицы логов, куда данные вставляются хронологически
CREATE INDEX idx_logs_created_at ON logs USING brin (created_at);

-- Проверяем корреляцию (должна быть близка к 1.0 или -1.0)
SELECT correlation FROM pg_stats WHERE tablename = 'logs' AND attname = 'created_at';
-- correlation = 0.998 — BRIN будет эффективен
-- correlation = 0.05  — BRIN бесполезен, используйте B-Tree
```

### Практические рекомендации по выбору типа индекса

1. **По умолчанию используйте B-Tree** — он покрывает 90% задач.
2. **Hash** — рассматривайте только для lookup по очень длинным ключам (UUID, токены), где B-Tree занимает много места.
3. **GIN** — обязателен для JSONB-столбцов с `@>` запросами и полнотекстового поиска.
4. **GiST** — нужен для PostGIS и диапазонных типов; для полнотекста предпочитайте GIN.
5. **BRIN** — используйте для таблиц с миллиардами строк, где данные упорядочены по времени (логи, события, метрики). Размер индекса будет в 100-1000 раз меньше B-Tree.

```sql
-- Сравнение размеров индексов на таблице 100M строк (пример)
-- B-Tree:  2.1 GB
-- BRIN:    48 KB (!)
-- Но BRIN подходит ТОЛЬКО при высокой корреляции
```

## Примеры
```sql
CREATE INDEX idx_events_payload_gin ON events USING gin (payload jsonb_path_ops);
```

## Доп. теория
- Тип индекса выбирают под конкретные операции: нет «идеального» индекса для всех запросов.
- Для PostgreSQL большинство практических кейсов закрывает B‑Tree + GIN для JSON/FTS.
