## Вопрос: EXPLAIN в PostgreSQL

## Простой ответ
- Показывает план выполнения: какие узлы, индексы, оценки строк/стоимости и, с ANALYZE, реальные цифры и буферы.

## Ответ
## Варианты
- `EXPLAIN` — план без выполнения.
- `EXPLAIN ANALYZE` — выполняет и показывает фактические метрики.
- `EXPLAIN (ANALYZE, BUFFERS)` — добавляет работу с памятью/диском.
- `EXPLAIN (ANALYZE, BUFFERS, VERBOSE, FORMAT JSON)` — максимум деталей и JSON-вывод.

Пример — в конце.

## Ключевые метрики
- `cost=startup..total` — оценка планировщика (не время), старта и полного прохода.
- `rows` — сколько строк ждёт узел.
- `width` — средний размер строки (байт).
- `Actual Time start..end`, `Actual Rows` — фактические метрики (только с ANALYZE).
- `Loops` — сколько раз узел выполнялся.
- `Buffers: shared hit/read/dirtied/written` — кеш/диск (только BUFFERS).

## Work_mem и сортировки/хеши
- Sort: `Sort Method: quicksort Memory: ...` или `external merge Disk: ...` — если ушло на диск, `work_mem` мало.
- Hash: `Buckets/ Batches/ Memory Usage` — если Batches > 1, хеш не влез в память.

## Основные узлы плана
- `Seq Scan` — полное сканирование таблицы.
- `Index Scan` — по индексу, потом таблица.
- `Index Only Scan` — всё из индекса.
- `Bitmap Index + Bitmap Heap Scan` — собирает адреса, читает блоки пачками.
- `Nested Loop` — хорошо при малом внешнем наборе.
- `Hash Join` — быстрый при достаточной памяти.
- `Merge Join` — по отсортированным потокам.

## Как читать
1) Найти самый дорогой по `Actual Time`.
2) Сравнить `rows` vs `Actual Rows`.
3) Смотреть `Buffers`: много `read` → I/O узкое место.
4) Проверить Sort/Hash на выход в диск (work_mem).
5) `Loops` — нет ли многократного выполнения.
6) Тип скана — нужен ли индекс/покрытие.

## Подробная теория и практика

### Зачем нужен EXPLAIN

EXPLAIN — это основной инструмент анализа производительности запросов в PostgreSQL. Когда вы пишете SQL-запрос, планировщик (query planner) строит **план выполнения** — дерево операций, которые будут применены к данным. EXPLAIN позволяет увидеть этот план до или после выполнения запроса. Без этого инструмента оптимизация запросов превращается в гадание: вы не знаете, используется ли индекс, сколько строк реально обрабатывается, и где именно запрос «тормозит».

### Разница между EXPLAIN и EXPLAIN ANALYZE

Важно понимать ключевое различие: `EXPLAIN` без `ANALYZE` **не выполняет запрос** — он лишь показывает предполагаемый план на основе статистики таблиц (pg_statistic). Это безопасно для тяжёлых запросов и запросов на запись. `EXPLAIN ANALYZE` **реально выполняет запрос**, поэтому для `DELETE` или `UPDATE` обязательно оборачивайте в транзакцию с откатом:

```sql
BEGIN;
EXPLAIN ANALYZE DELETE FROM orders WHERE created_at < '2020-01-01';
ROLLBACK; -- данные не удалены, но план получен
```

### Понимание cost

Значение `cost` — это **условная единица**, а не миллисекунды. Она основана на параметрах конфигурации (`seq_page_cost`, `random_page_cost`, `cpu_tuple_cost` и др.). Первое число — стоимость получения первой строки (startup cost), второе — стоимость получения всех строк (total cost). Высокий startup cost характерен для операций, требующих предварительной подготовки: сортировка, Hash Join, Materialize. Сравнивать cost между разными серверами нельзя — значения зависят от настроек.

### Анализ расхождения оценок

Одна из самых полезных практик — сравнение `rows` (оценка планировщика) с `Actual Rows`. Если расхождение значительное (например, планировщик ожидает 10 строк, а получает 100 000), это сигнал о неактуальной статистике. Решения:

```sql
-- Обновить статистику по таблице
ANALYZE users;

-- Увеличить точность статистики для конкретного столбца
ALTER TABLE users ALTER COLUMN email SET STATISTICS 1000;
ANALYZE users;
```

Неточная статистика приводит к выбору неоптимального плана: например, Nested Loop вместо Hash Join, или Seq Scan вместо Index Scan.

### Типы сканирования: когда что выбирается

| Тип скана | Когда выбирается | Характеристика |
|-----------|------------------|----------------|
| Seq Scan | Нет подходящего индекса или выбирается >5-10% таблицы | Читает всю таблицу последовательно |
| Index Scan | Выбирается мало строк, есть индекс | Идёт по индексу, для каждой записи обращается к таблице (heap) |
| Index Only Scan | Все нужные столбцы есть в индексе | Самый быстрый — не обращается к таблице |
| Bitmap Index Scan + Bitmap Heap Scan | Средняя селективность | Сначала собирает bitmap адресов из индекса, потом читает блоки пачками |

Для Index Only Scan важно, чтобы Visibility Map была актуальной (после `VACUUM`), иначе PostgreSQL всё равно обратится к heap для проверки видимости строк.

### Типы соединений (Join) в плане

```
Nested Loop     — оптимален, когда внешний набор маленький (десятки строк)
Hash Join       — внутренняя таблица помещается в хеш-таблицу в памяти
Merge Join      — оба входа отсортированы по ключу соединения
```

Если вы видите `Hash Join` с `Batches: 4`, это значит, что хеш-таблица не поместилась в `work_mem` и была записана на диск по частям. Увеличьте `work_mem` для сессии:

```sql
SET work_mem = '256MB';
EXPLAIN ANALYZE SELECT ...;
RESET work_mem;
```

### Практический пример полного разбора

```sql
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT u.name, COUNT(o.id)
FROM users u
JOIN orders o ON o.user_id = u.id
WHERE u.created_at > '2024-01-01'
GROUP BY u.name;
```

На что смотреть в выводе:
- Если `users` фильтруется по `created_at` через Seq Scan — нужен индекс `CREATE INDEX idx_users_created ON users(created_at)`.
- Если Join идёт через Nested Loop с большим числом Loops — возможно, лучше Hash Join (проверьте `enable_nestloop = off` для теста).
- `Buffers: shared read=50000` — значит 50000 блоков (по 8 KB = ~400 MB) прочитано с диска. Повторный запуск покажет `shared hit` — данные уже в кеше.

### Полезные инструменты визуализации

Текстовый вывод EXPLAIN сложно читать для больших запросов. Используйте визуализаторы:
- **explain.dalibo.com** — вставляете JSON-вывод `EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON)` и получаете интерактивное дерево.
- **pgMustard** — автоматически подсказывает проблемы.
- В IDE (DataGrip, DBeaver) есть встроенная визуализация планов.

### Типичные ошибки и советы

1. **Не используйте EXPLAIN ANALYZE на продакшене для тяжёлых мутирующих запросов** без транзакции с ROLLBACK.
2. **Не гонитесь за Index Scan** — для аналитических запросов, читающих >20% таблицы, Seq Scan может быть быстрее.
3. **Проверяйте «тёплый» кеш** — первый запуск показывает `shared read`, повторный — `shared hit`. Оба сценария важны.
4. **Следите за Rows Removed by Filter** — если узел отбрасывает 99% строк, возможно, нужен более точный индекс.
5. **Всегда обновляйте статистику** (`ANALYZE`) после массовых INSERT/UPDATE/DELETE перед исследованием плана.

## Примеры
```sql
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM users WHERE email = 'a@b.c';
```

## Доп. теория
- `EXPLAIN` без `ANALYZE` показывает план по статистике, но не гарантирует реальное выполнение.
- Для тяжелых UPDATE/DELETE используйте транзакцию и `ROLLBACK`.
