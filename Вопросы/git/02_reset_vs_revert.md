## Вопрос: reset vs revert

## Простой ответ
- `reset` двигает указатель ветки назад/вперёд и может переписать историю.
- `revert` делает новый коммит, который отменяет изменения старого, историю не трогает.

- `git reset --hard <commit>` — двигает HEAD и ветку, меняет рабочее дерево и индекс (опасно для публичных веток).
- `git reset --soft <commit>` — двигает HEAD, оставляя изменения в индексе.
- `git reset --mixed <commit>` (по умолчанию) — оставляет изменения в рабочем каталоге, очищает индекс.
- `git revert <commit>` — делает обратный патч как новый коммит, безопасен для опубликованных веток.

## Ответ

### Суть различий

`git reset` и `git revert` — два способа «отменить» изменения, но с принципиально разным подходом. Reset двигает указатель ветки (HEAD) назад, фактически удаляя коммиты из истории. Revert создаёт новый коммит, содержащий обратные изменения — история остаётся нетронутой. Выбор между ними зависит от того, публичная ветка или локальная.

### git reset: три режима

Reset перемещает HEAD и указатель текущей ветки на указанный коммит. Три режима определяют, что происходит с рабочим каталогом и индексом (staging area):

| Режим | HEAD | Индекс (staging) | Рабочий каталог | Использование |
|---|---|---|---|---|
| `--soft` | Перемещается | Не трогает | Не трогает | Переделать коммит (изменения остаются staged) |
| `--mixed` (default) | Перемещается | Сбрасывается | Не трогает | Убрать из staging, изменения остаются в файлах |
| `--hard` | Перемещается | Сбрасывается | Сбрасывается | Полная отмена — всё как в указанном коммите |

```bash
# Отменить последний коммит, оставив изменения staged
git reset --soft HEAD~1

# Отменить последний коммит, изменения в рабочем каталоге (unstaged)
git reset HEAD~1          # --mixed по умолчанию

# Полностью откатиться на 3 коммита назад (ОПАСНО — потеря данных!)
git reset --hard HEAD~3

# Убрать файл из staging (не трогая рабочий каталог)
git reset HEAD -- file.txt

# Откатиться к конкретному коммиту
git reset --hard abc1234
```

### git revert: безопасная отмена

Revert не удаляет коммиты — он создаёт новый коммит, который содержит обратный патч (inverse diff) указанного коммита. Это безопасно для публичных веток, потому что история не переписывается.

```bash
# Отменить конкретный коммит
git revert abc1234

# Отменить несколько коммитов (каждый — отдельный revert-коммит)
git revert abc1234 def5678

# Отменить диапазон коммитов (не включая начальный)
git revert abc1234..def5678

# Отменить merge-коммит (нужно указать, какой parent сохранить)
git revert -m 1 <merge-commit-hash>

# Revert без автоматического коммита (для объединения нескольких revert)
git revert --no-commit abc1234
git revert --no-commit def5678
git commit -m "Revert: откат фичи X"

# Отменить revert в процессе
git revert --abort
```

### Сравнительная таблица

| Характеристика | `git reset` | `git revert` |
|---|---|---|
| Меняет историю | Да (удаляет коммиты) | Нет (добавляет новый коммит) |
| Безопасен для публичных веток | Нет | Да |
| Требует force push | Да | Нет |
| Можно отменить merge | Нет (только --hard) | Да (`-m 1`) |
| Можно выбрать режим | Да (soft/mixed/hard) | Нет |
| Влияет на коллег | Да (конфликты при force push) | Нет |

### Восстановление после reset --hard

Если вы случайно сделали `reset --hard`, коммиты не потеряны безвозвратно — они доступны через reflog в течение ~30 дней (по умолчанию):

```bash
# Посмотреть историю перемещений HEAD
git reflog

# Пример вывода:
# abc1234 HEAD@{0}: reset: moving to HEAD~3
# def5678 HEAD@{1}: commit: важная фича
# ghi9012 HEAD@{2}: commit: ещё изменения

# Восстановить потерянный коммит
git reset --hard def5678
# или создать новую ветку из потерянного коммита
git checkout -b recovery def5678
```

### Практические сценарии

```bash
# Сценарий 1: Переделать последний коммит (лучше, чем amend, если нужно разбить)
git reset --soft HEAD~1
# Теперь изменения staged, можно разбить на несколько коммитов

# Сценарий 2: Откатить фичу в production (публичная ветка)
git checkout main
git revert <feature-merge-commit> -m 1
git push origin main

# Сценарий 3: Очистить неудачные локальные эксперименты
git reset --hard origin/main   # локальная ветка = remote

# Сценарий 4: Убрать файл из staging, но оставить изменения
git reset HEAD -- config.yml
```

### Правило выбора

- **Ветка локальная, не запушена** → `git reset` (можно переписывать историю).
- **Ветка публичная, запушена** → `git revert` (история не переписывается, коллеги не страдают).
- **Нужно «переделать» последний коммит** → `git reset --soft HEAD~1` или `git commit --amend`.

## Примеры
```bash
# Откатить последний коммит в публичной ветке
git revert HEAD
```

## Доп. теория
- `reset --hard` опасен на публичных ветках: ломает историю и требует force‑push.
- Revert безопаснее, но может давать конфликты, если изменения уже были переработаны.
