## Вопрос: Разница между git merge и git rebase

## Простой ответ
- merge соединяет ветки через merge-коммит без переписывания истории.
- rebase переписывает историю, «переигрывая» коммиты поверх базовой ветки, чтобы история была линейной.

## Ответ

### Суть различий

`git merge` и `git rebase` решают одну задачу — интеграцию изменений из одной ветки в другую — но делают это принципиально по-разному. Merge создаёт новый коммит слияния (merge commit), который имеет двух родителей и сохраняет полную историю ветвления. Rebase «переигрывает» коммиты текущей ветки поверх целевой, создавая новые коммиты с другими хэшами и формируя линейную историю.

### git merge подробно

Merge объединяет две ветки, создавая специальный merge-коммит с двумя родителями. Это неразрушающая операция — существующие коммиты не изменяются, их хэши остаются прежними. Git использует three-way merge: берёт общего предка двух веток и сравнивает изменения с обеих сторон.

Существует несколько стратегий merge:
- **recursive** (по умолчанию для двух веток) — рекурсивно находит общего предка и объединяет изменения.
- **ort** (новая стратегия в Git 2.33+) — оптимизированная замена recursive, быстрее на больших репозиториях.
- **octopus** — для слияния более двух веток одновременно.

```bash
# Обычный merge с merge-коммитом
git checkout dev
git merge feature

# Принудительно создать merge-коммит даже при fast-forward
git merge --no-ff feature

# Merge с указанием стратегии
git merge -s ort feature

# Merge без автоматического коммита (для ревью изменений)
git merge --no-commit feature

# Отменить merge в процессе (при конфликтах)
git merge --abort
```

### git rebase подробно

Rebase берёт коммиты текущей ветки, временно «снимает» их, перематывает ветку на целевой коммит и последовательно применяет снятые коммиты поверх. Каждый применённый коммит получает новый хэш, поскольку меняется его parent.

Interactive rebase (`git rebase -i`) — мощный инструмент для редактирования истории: можно объединять коммиты (squash), менять сообщения (reword), переупорядочивать, удалять и даже разделять коммиты.

```bash
# Простой rebase
git checkout feature
git rebase dev

# Interactive rebase — редактирование последних 3 коммитов
git rebase -i HEAD~3

# Пример содержимого интерактивного редактора:
# pick abc1234 Добавить модель User
# squash def5678 Фикс модели User
# reword ghi9012 Добавить тесты

# Rebase с автоматическим squash (для fixup! коммитов)
git rebase -i --autosquash dev

# Продолжить rebase после разрешения конфликта
git add .
git rebase --continue

# Отменить rebase
git rebase --abort

# Безопасный push после rebase
git push --force-with-lease
```

### Сравнительная таблица

| Характеристика | `git merge` | `git rebase` |
|---|---|---|
| История | Нелинейная, с ветвлениями | Линейная, чистая |
| Хэши коммитов | Сохраняются | Новые хэши |
| Merge-коммит | Да (кроме fast-forward) | Нет |
| Безопасность для команды | Безопасен всегда | Опасен для публичных веток |
| Разрешение конфликтов | Один раз при merge | На каждом переигрываемом коммите |
| Отслеживаемость | Видно, когда и что сливали | Выглядит как последовательная работа |
| `git log --graph` | Ветвистый граф | Прямая линия |

### Когда что использовать

- **Merge** — для публичных/общих веток (`main`, `develop`), когда важно сохранить контекст слияния. Обязательно, если ветка уже была запушена и другие разработчики на ней работают.
- **Rebase** — для локальных feature-веток перед созданием PR, чтобы получить чистую линейную историю. Идеально для «причёсывания» коммитов перед code review.
- **Squash merge** (`git merge --squash feature`) — объединяет все коммиты ветки в один коммит на целевой ветке. Удобно для маленьких фич.

### Популярные workflow

```bash
# Feature branch workflow с rebase
git checkout feature
git fetch origin
git rebase origin/dev        # подтянуть изменения dev
# ... разрешить конфликты если есть ...
git push --force-with-lease   # обновить remote feature
# Затем создать PR → merge в dev через GitHub/GitLab

# Trunk-based workflow
git checkout main
git pull
git merge --no-ff feature    # всегда merge-коммит для отслеживания
```

### Золотое правило

**Никогда не делайте rebase публичных веток**, на которых работают другие люди. Rebase переписывает историю (меняет хэши), и у коллег, работающих с теми же коммитами, возникнут конфликты и дублирование. Используйте `--force-with-lease` вместо `--force` при push после rebase — это предотвратит затирание чужих изменений.

## Примеры
```bash
# Локально: подчистить историю перед PR
git rebase -i origin/main
```

## Доп. теория
- Merge сохраняет историю слияния, rebase делает линейную историю.
- Для публичных веток используйте merge или squash‑merge.
