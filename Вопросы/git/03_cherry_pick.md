## Вопрос: git cherry-pick

## Простой ответ
- Копирует выбранный коммит в текущую ветку, создавая новый коммит с теми же изменениями.

```bash
git checkout feature
git cherry-pick abc123   # применить коммит abc123 поверх текущей ветки
```

Использование: вытянуть нужный фикс из другой ветки, не сливая всю ветку. Конфликты решаются как при merge/rebase. Не применять массово на публичных ветках без синка истории.

## Ответ

### Что делает cherry-pick

`git cherry-pick` берёт diff конкретного коммита и применяет его как новый коммит поверх текущей ветки. Новый коммит получает другой хэш, но содержит те же изменения и то же сообщение (если не указано иное). Это не перемещение коммита, а именно копирование его изменений.

### Как это работает внутри

Git вычисляет разницу (diff) между указанным коммитом и его родителем. Затем эта разница применяется к текущему HEAD как патч. Если патч применяется без конфликтов — создаётся новый коммит. Если есть конфликты — процесс останавливается, и разработчик должен разрешить их вручную.

### Основные команды

```bash
# Применить один коммит
git cherry-pick abc1234

# Применить несколько коммитов
git cherry-pick abc1234 def5678 ghi9012

# Применить диапазон коммитов (не включая начальный!)
git cherry-pick abc1234..ghi9012

# Применить диапазон включая начальный коммит
git cherry-pick abc1234^..ghi9012

# Применить без автоматического коммита (изменения в staging)
git cherry-pick --no-commit abc1234
git cherry-pick --no-commit def5678
git commit -m "Backport: фикс авторизации"

# Cherry-pick merge-коммита (указать parent)
git cherry-pick -m 1 <merge-commit-hash>

# При конфликте: разрешить и продолжить
git add .
git cherry-pick --continue

# Отменить cherry-pick
git cherry-pick --abort

# Пропустить текущий коммит и продолжить
git cherry-pick --skip
```

### Типичные сценарии использования

**Hotfix в production.** Баг найден в main, фикс сделан в develop. Нужно перенести именно этот фикс в main, не сливая весь develop:

```bash
git checkout main
git cherry-pick <fix-commit-hash>
git push origin main
```

**Backport в старую версию.** Фикс безопасности нужно применить к нескольким release-веткам:

```bash
git checkout release/2.0
git cherry-pick <security-fix-hash>

git checkout release/1.9
git cherry-pick <security-fix-hash>
```

**Выборочный перенос фичи.** Из большой feature-ветки нужны только определённые коммиты:

```bash
git checkout dev
git cherry-pick feat-abc1 feat-abc3 feat-abc5   # только нужные коммиты
```

### Опасности и подводные камни

- **Дублирование коммитов.** Cherry-pick создаёт новый коммит с тем же diff. Если потом слить ветку-источник, Git может показать конфликт, потому что одни и те же изменения уже есть в обеих ветках.
- **Потеря контекста.** Коммит мог зависеть от предыдущих изменений в своей ветке. Cherry-pick без контекста может сломать код.
- **Не для массового переноса.** Если нужно перенести десятки коммитов — лучше merge или rebase.

### Cherry-pick vs merge vs rebase

| Операция | Что переносит | Когда использовать |
|---|---|---|
| `cherry-pick` | Один/несколько конкретных коммитов | Hotfix, backport, выборочный перенос |
| `merge` | Всю ветку целиком | Интеграция feature-ветки |
| `rebase` | Все коммиты ветки поверх другой | Линейная история перед merge |

### Полезные флаги

```bash
# Добавить строку "(cherry picked from commit ...)" в сообщение
git cherry-pick -x abc1234

# Указать автора (если cherry-pick от чужого коммита)
# автор сохраняется автоматически, committer — текущий пользователь

# Изменить сообщение коммита при cherry-pick
git cherry-pick -e abc1234
```

## Примеры
```bash
# Backport фиксa в release-ветку
git checkout release/1.9
git cherry-pick <fix-commit>
```

## Доп. теория
- Cherry-pick копирует изменения и создаёт новый коммит с другим хэшем.
- При массовом переносе удобнее merge или rebase.
