# Lifecycle PHP-запроса
Сводная схема:
1. Клиент отправляет HTTP-запрос → веб-сервер (nginx / Apache).
2. Веб-сервер передаёт .php-запрос в PHP-FPM (через FastCGI).
3. FPM выбирает свободный воркер, инициализирует SAPI и суперглобальные ($_GET, $_POST, $_SERVER и т.д.).
4. PHP парсит код → Tokenizer → AST (транслируется)→ Opcodes, кеширует в OpCache.
5. Zend VM исполняет опкоды (при необходимости — JIT компиляция).
6. Пользовательский код выполняется: файлы, БД, логика, вывод.
7. Результат возвращается через FPM → веб-сервер → клиент.
8. Воркер возвращается в пул; OpCache и расширения остаются в памяти.

Схема: клиент → веб-сервер (nginx/Apache) → PHP-FPM → Zend Engine (Tokenizer → AST → Opcodes → OpCache → Zend VM/JIT) → ответ → клиент. Воркеры остаются в пуле, OpCache и расширения живут между запросами.

## Кратко по шагам
| Этап | Что происходит |
| --- | --- |
| 1 | nginx/Apache передаёт .php в PHP-FPM (FastCGI) |
| 2 | FPM выбирает воркер |
| 3 | Инициализация окружения: php.ini, параметры пула, SAPI, суперглобальные |
| 4 | Парсинг кода: токены → AST → опкоды |
| 5 | Опкоды кладутся/читаются из OpCache |
| 6 | Zend VM исполняет байткод |
| 7 | (опц.) JIT компилирует горячие трассы |
| 8 | Выполняется пользовательский код/автозагрузка |
| 9 | Ответ возвращается через FPM → веб-сервер |
| 10 | Воркер остаётся в пуле; OpCache/расширения — в памяти |

## Подробно
1) Запуск через PHP-FPM: master слушает сокет/порт, выбирает свободный воркер.  
2) Воркер уже прогрет: Zend Engine загружен, php.ini прочитан при старте пула.  
3) Инициализация SAPI (fpm-fcgi), суперглобальных (`$_SERVER`, `$_GET`, `$_POST`, `$_COOKIE`, `$_FILES`, `$_ENV`, `$_REQUEST`, сессия при auto_start).  
4) Токенизация → AST → опкоды.  
5) OpCache: пропускает парсер/компилятор, если байткод в кеше (`opcache.enable=1`).  
6) Исполнение в Zend VM — стековая машина; ошибки через `zend_error_cb`.  
7) JIT (PHP 8+): компилирует горячие трассы в машинный код, прирост на CPU-heavy задачах.  
8) Autoload/require: при первом обращении файл компилируется и (если включено) кешируется в OpCache.  
9) Shutdown: вызываются `register_shutdown_function()`, освобождаются переменные запроса, закрывается вывод.  
10) Ответ идёт назад по FastCGI → веб-сервер → клиент; воркер возвращён в пул.

## Что сохраняется между запросами
- Интерпретатор, Zend Engine, расширения.
- OpCache (скомпилированные опкоды).
- Настройки php.ini, параметры пула FPM.

## Что очищается каждый запрос
- Пользовательские переменные/объекты.
- Суперглобальные, буферы вывода/ошибок, контекст запроса.

## Визуально
```
[nginx] -> FastCGI -> [php-fpm master] -> [php-fpm worker]
  Zend Engine: Tokenizer -> AST -> Opcodes -> OpCache
  Zend VM -> (JIT) -> машинный код -> Output -> FastCGI -> nginx -> клиент
```
