## Вопрос: GET vs POST

## Простой ответ
- GET — читаем, параметры в URL, кэшируется, идемпотентен.
- POST — отправляем/меняем, данные в теле, не кэшируется, не идемпотентен.

| Характеристика | GET | POST |
| --- | --- | --- |
| Данные в URL | Да | Нет |
| Идемпотентность | Да | Нет |
| Кэширование | Можно | Нет |
| Макс. длина | Ограничена настройками клиента/сервера | Ограничена настройками сервера |
| Использование | Получение данных | Отправка данных |
- Семантика важнее: можно передавать тело в GET и query в POST, но это обычно не рекомендуется. POST по умолчанию не кэшируется и не идемпотентен.

```bash
curl -X GET "https://api.example.com/users?limit=10"
curl -X POST "https://api.example.com/users" -H "Content-Type: application/json" -d '{"email":"a@b.c"}'
```

## Ответ

### Что такое HTTP-методы и зачем нужна семантика

HTTP-протокол определяет набор методов (verbs), каждый из которых несёт определённую семантику. GET и POST — два самых распространённых метода. Согласно спецификации RFC 7231, GET предназначен исключительно для получения представления ресурса, а POST — для отправки данных на сервер с целью обработки (создание, обновление, триггер действий). Соблюдение семантики критически важно: поисковые роботы, прокси-серверы, CDN и браузеры принимают решения о кэшировании, повторных запросах и prefetch на основании метода.

### Подробная таблица сравнения

| Характеристика         | GET                                      | POST                                       |
|------------------------|------------------------------------------|--------------------------------------------|
| Назначение             | Получение (read) ресурса                 | Отправка/создание/изменение данных         |
| Параметры              | Query string (`?key=val&...`)            | Request body (form-data, JSON, XML и др.)  |
| Видимость данных       | В URL, логах, Referer-заголовке          | В теле запроса, не видны в URL             |
| Максимальная длина     | ~2048–8192 символов (зависит от браузера/сервера) | Практически не ограничена (настройка `client_max_body_size` в Nginx) |
| Идемпотентность        | Да (повторный запрос = тот же результат) | Нет (повторный POST может создать дубликат)|
| Safe (безопасный)      | Да (не меняет состояние сервера)         | Нет                                        |
| Кэширование            | Да (браузер, прокси, CDN)                | По умолчанию нет, но возможно при явных заголовках |
| Закладки/история       | Сохраняется в истории браузера           | Не сохраняется                             |
| Тип Content-Type       | Не требуется                             | Нужен, если есть тело (`application/json`, `multipart/form-data` и др.) |
| Ограничение по типу данных | Только ASCII в URL (URL-encoding)     | Любые бинарные данные, файлы               |
| Back/Forward в браузере| Безопасен (повторный запрос)             | Браузер предупреждает о повторной отправке |
| Prefetch / robots      | Могут быть выполнены автоматически       | Никогда не выполняются автоматически       |

### Структура HTTP-запроса: GET vs POST

```text
--- GET-запрос ---
GET /api/users?page=2&limit=20 HTTP/1.1
Host: example.com
Accept: application/json
Cookie: session=abc123

(тело отсутствует)

--- POST-запрос ---
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 42
Cookie: session=abc123

{"name": "Ivan", "email": "ivan@mail.ru"}
```

### Идемпотентность и безопасность: матрица HTTP-методов

```text
Метод     | Safe | Idempotent | Описание
----------|------|------------|----------------------------------
GET       |  Да  |    Да      | Получить ресурс
HEAD      |  Да  |    Да      | Только заголовки (без тела)
OPTIONS   |  Да  |    Да      | Узнать поддерживаемые методы
POST      |  Нет |    Нет     | Создать / обработать данные
PUT       |  Нет |    Да      | Заменить ресурс целиком
PATCH     |  Нет |    Нет     | Частичное обновление
DELETE    |  Нет |    Да      | Удалить ресурс
```

Safe = запрос не меняет состояние на сервере. Idempotent = повторный вызов даёт тот же результат. GET — и безопасный, и идемпотентный, поэтому браузер может свободно его кэшировать или повторять. POST — ни то, ни другое, поэтому браузер предупреждает при повторной отправке формы.

### Кэширование GET-запросов

GET-запросы кэшируются на нескольких уровнях:

```text
Браузер (memory/disk cache)
    ↓
Прокси / CDN (Varnish, CloudFlare)
    ↓
Reverse-proxy (Nginx proxy_cache)
    ↓
Origin-сервер
```

Управление кэшем осуществляется HTTP-заголовками:

```http
Cache-Control: public, max-age=3600
ETag: "abc123"
Last-Modified: Mon, 01 Jan 2024 00:00:00 GMT
Vary: Accept-Encoding
```

POST-запросы по умолчанию не кэшируются. Технически спецификация допускает кэширование POST при наличии заголовков `Content-Location` и `Expires`, но на практике это не используется.

### Безопасность: что важно понимать

GET-запросы несут повышенные риски утечки данных, потому что параметры попадают в:
- URL-строку браузера (видно пользователю и плечевому серфингу)
- Серверные логи (`access.log`: `GET /login?user=admin&pass=secret`)
- Заголовок `Referer` при переходе на другой сайт
- Историю браузера и закладки
- Кэш прокси-серверов

Именно поэтому **никогда** нельзя передавать пароли, токены и другие секреты через GET. Однако POST — это **не шифрование**: без HTTPS тело POST-запроса точно так же видно в сети. HTTPS шифрует и URL, и тело, но URL всё равно попадает в логи сервера.

## Примеры
### Практические примеры на PHP

```php
// GET — получение списка с фильтрацией
// URL: /api/articles?category=php&sort=date&page=2
$category = $_GET['category'] ?? 'all';
$sort     = $_GET['sort'] ?? 'date';
$page     = (int)($_GET['page'] ?? 1);

$articles = $repository->findBy($category, $sort, $page);
header('Cache-Control: public, max-age=60');
echo json_encode($articles);

// POST — создание нового ресурса
// Content-Type: application/json
$data = json_decode(file_get_contents('php://input'), true);
$article = new Article($data['title'], $data['body']);
$repository->save($article);

http_response_code(201);
header('Location: /api/articles/' . $article->getId());
echo json_encode($article);
```

### Когда используются нестандартные сочетания

В реальных API встречаются ситуации, которые ломают классические правила:

1. **GET с телом** — технически допустим по HTTP/1.1, но не рекомендован. Elasticsearch исторически использовал GET с JSON-телом для поисковых запросов (`GET /index/_search`), позже добавили POST как альтернативу.

2. **POST для чтения** — GraphQL использует POST для всех запросов, включая queries (чтение), потому что query-строка может не вместить сложный GraphQL-запрос.

3. **POST для идемпотентных операций** — платёжные системы используют idempotency key в заголовках (`Idempotency-Key: uuid`), чтобы сделать POST идемпотентным и предотвратить двойные списания.

### Диаграмма принятия решений

```text
Нужно получить данные?
├── Да → GET
│    ├── Данные чувствительные? → Всё равно GET, но через HTTPS
│    └── Сложный запрос (тело)? → Рассмотри POST (как GraphQL)
└── Нет → Нужно изменить состояние?
     ├── Создать ресурс? → POST (ответ 201 Created)
     ├── Заменить ресурс? → PUT
     ├── Частично обновить? → PATCH
     └── Удалить? → DELETE
```

### Итоги

- GET и POST различаются не по техническим возможностям (оба могут передавать данные), а по **семантике** и **контрактам**.
- GET безопасен и идемпотентен — его можно кэшировать, повторять, prefetch'ить. POST — нет.
- Данные GET попадают в URL/логи/Referer — не передавайте секреты. POST скрывает данные в теле, но без HTTPS это не защита.
- Соблюдение семантики HTTP-методов обеспечивает корректную работу кэшей, CDN, API-шлюзов и делает API предсказуемым для потребителей.

## Доп. теория
- GET может содержать тело запроса, но спецификация не определяет его семантику — поэтому многие клиенты/прокси его игнорируют.
- POST может быть кэширован, если заданы корректные заголовки `Cache-Control`/`Expires`, но это редкая практика.
