## Вопрос: SQL-инъекция

## Простой ответ
- Никогда не конкатенируем ввод в SQL. Используем подготовленные выражения/плейсхолдеры и белые списки для имен таблиц/полей.

## Ответ

### Что такое SQL Injection

SQL-инъекция (SQL Injection, SQLi) — это атака, при которой злоумышленник внедряет произвольный SQL-код в запрос к базе данных через пользовательский ввод. Это происходит, когда приложение формирует SQL-запрос путём конкатенации строк, включая данные, полученные от пользователя, без надлежащей обработки. SQL-инъекция стабильно входит в OWASP Top 10 и является одной из самых опасных и распространённых уязвимостей веб-приложений.

### Как работает атака

Суть атаки заключается в том, что пользовательский ввод интерпретируется не как данные, а как часть SQL-команды. Например, если в поле логина ввести `admin' --`, то закрывающая кавычка завершает строковый литерал, а `--` комментирует остаток запроса (включая проверку пароля). Злоумышленник может читать, изменять и удалять данные, обходить аутентификацию, а при высоких привилегиях СУБД — выполнять команды ОС (RCE через `xp_cmdshell` в MSSQL, `LOAD_FILE`/`INTO OUTFILE` в MySQL).

### Виды SQL-инъекций

Существует несколько типов SQL-инъекций. **Classic (In-Band) SQLi** — результат атаки виден прямо в ответе сервера (UNION-based, Error-based). **Blind SQLi** — результат не виден напрямую, но атакующий извлекает информацию побитно через булевы условия (Boolean-based) или через задержки ответа (Time-based, например `SLEEP(5)`). **Out-of-Band SQLi** — данные извлекаются через сторонний канал (DNS-запросы, HTTP-запросы от СУБД). **Second-Order SQLi** — вредоносный ввод сохраняется в базе и срабатывает позже, когда используется в другом запросе.

### Уязвимый код (PHP)

```php
// УЯЗВИМО — конкатенация пользовательского ввода
$username = $_POST['username'];
$password = $_POST['password'];

$query = "SELECT * FROM users WHERE username = '$username' AND password = '$password'";
$result = mysqli_query($conn, $query);

// Атакующий вводит в поле username: admin' OR '1'='1' --
// Итоговый запрос:
// SELECT * FROM users WHERE username = 'admin' OR '1'='1' --' AND password = ''
// Результат: вход без пароля под любым пользователем
```

```php
// УЯЗВИМО — динамическая сортировка
$order = $_GET['sort']; // Пользователь передаёт: id; DROP TABLE users; --
$query = "SELECT * FROM products ORDER BY $order";
// Плейсхолдеры НЕ работают для имён столбцов и ключевых слов SQL!
```

### Исправленный код (PHP)

```php
// БЕЗОПАСНО — подготовленные выражения (PDO)
$stmt = $pdo->prepare('SELECT * FROM users WHERE username = :username AND password = :password');
$stmt->execute([
    'username' => $username,
    'password' => $password,
]);
$user = $stmt->fetch();

// БЕЗОПАСНО — белый список для динамических идентификаторов
$allowedColumns = ['id', 'name', 'price', 'created_at'];
$order = in_array($_GET['sort'], $allowedColumns, true) ? $_GET['sort'] : 'id';
$direction = ($_GET['dir'] ?? 'ASC') === 'DESC' ? 'DESC' : 'ASC';
$stmt = $pdo->query("SELECT * FROM products ORDER BY {$order} {$direction}");
```

```php
// БЕЗОПАСНО — использование Query Builder (Laravel Eloquent)
$users = User::where('email', '=', $request->input('email'))->first();

// БЕЗОПАСНО — проверка привилегий и минимальные права
// Подключение к БД с read-only пользователем для запросов чтения
$readOnlyPdo = new PDO($dsn, 'app_readonly', $password, [
    PDO::ATTR_EMULATE_PREPARES => false,  // Важно: отключить эмуляцию!
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
]);
```

### Продвинутые техники атаки

UNION-based инъекция позволяет объединить результат атакующего запроса с оригинальным: `' UNION SELECT username, password FROM users --`. Для этого атакующий сначала определяет число столбцов через `ORDER BY N`. Blind Boolean-based инъекция извлекает данные по одному биту: `' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='admin')='a' --`. Time-based blind использует задержки: `' AND IF(1=1, SLEEP(5), 0) --` — если ответ задерживается на 5 секунд, условие истинно.

### Меры защиты

1. **Подготовленные выражения (Prepared Statements)** — основной и самый надёжный метод. Данные передаются отдельно от SQL-кода и никогда не интерпретируются как команды. Обязательно отключайте эмуляцию (`PDO::ATTR_EMULATE_PREPARES => false`).
2. **Белые списки (Whitelisting)** — для динамических имён таблиц, столбцов, направлений сортировки, которые нельзя параметризовать.
3. **ORM / Query Builder** — фреймворки (Laravel, Doctrine, Symfony) используют параметризованные запросы под капотом, но сырые выражения (`DB::raw()`, `whereRaw()`) остаются уязвимыми.
4. **Принцип минимальных привилегий** — приложение не должно подключаться к БД с правами root/admin. Используйте отдельных пользователей для чтения и записи.
5. **WAF (Web Application Firewall)** — дополнительный слой защиты, но не замена параметризации. WAF можно обойти через encoding, case-mixing, комментарии.
6. **Валидация входных данных** — проверяйте тип (числовое поле — только числа), длину, формат. Это не защита от SQLi сама по себе, но уменьшает поверхность атаки.
7. **Скрытие ошибок** — никогда не показывайте пользователю сообщения об ошибках СУБД в production. Используйте generic error pages и логируйте детали на сервере.

### Практические советы

- Всегда используйте `PDO::ATTR_EMULATE_PREPARES => false` в PDO, иначе плейсхолдеры подставляются на стороне PHP, а не СУБД, что может быть уязвимо.
- Аудит кода: ищите любое использование `mysqli_query()`, `$pdo->query()`, `DB::raw()`, `whereRaw()` с пользовательским вводом.
- Используйте инструменты автоматического тестирования: `sqlmap`, `Burp Suite`, `OWASP ZAP` для проверки своих endpoint-ов.
- Stored Procedures не панацея — если внутри процедуры используется динамический SQL, уязвимость сохраняется.
- Помните о Second-Order SQLi: данные, безопасно сохранённые в БД, могут стать опасными, если потом используются в запросе без параметризации.

## Примеры

1. Уязвимо: `"SELECT * FROM users WHERE id = $id"`.
2. Безопасно: `prepare('... WHERE id = :id')` + `execute()`.
3. Белый список для `ORDER BY`: `['id','created_at']`.

## Доп. теория

1. Плейсхолдеры не работают для имён колонок — нужен allowlist.
2. Минимальные права БД снижают ущерб при SQLi.
